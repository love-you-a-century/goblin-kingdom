<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>哥布林王國v5.00</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=MedievalSharp&display=swap"
        rel="stylesheet">
    <style>
         /* 【新增此段】地圖響應式樣式 */
        .map-container-responsive {
            width: 100%;
            max-width: 480px; /* 【修改】地圖最大不會超過 480px */
            aspect-ratio: 480 / 700; /* 【修改】維持新的直式長寬比 */
            position: relative;
            margin: 0 auto; /* 置中 */
        }
        .map-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 480px; /* 【修改】畫布的邏輯尺寸更新 */
            height: 700px; /* 【修改】畫布的邏輯尺寸更新 */
            transform-origin: top left; /* 設定縮放的基準點為左上角 */
        }
        :root {
            --primary-bg: #2d3748;
            --secondary-bg: #1a202c;
            --border-color: #4a5568;
            --text-primary: #cbd5e0;
            --text-secondary: #a0aec0;
            --accent-color: #8C6D46;
            --accent-hover: #A98458;
            --accent-text: #F0E6D2;
            --danger-color: #e53e3e;
            --success-color: #48bb78;
            --warning-color: #f6e05e;
            --crit-color: #f6e05e;
            --skill-color: #f687b3;
        }

        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: var(--secondary-bg);
            color: var(--text-primary);
        }

        .font-medieval {
            font-family: 'MedievalSharp', cursive;
        }

        .game-container {
            border: 4px solid var(--border-color);
            background: linear-gradient(145deg, #3a475b, #2d3748); /* 新增漸層背景 */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 10px rgba(0,0,0,0.3); /* 新增內陰影增加深度 */
            border-image: url('https://i.imgur.com/g23zL5V.png') 10 stretch; /* 新增圖片邊框，創造雕刻感 */
        }

        .game-title-wrapper {
            position: relative;
        }

        .game-title {
            font-family: 'MedievalSharp', cursive; /* 將所有標題改為中世紀字體 */
            background-color: var(--primary-bg);
            font-size: 1.5rem;
            color: var(--text-secondary);
            display: inline-block;
            padding: 0 0.5rem;
            position: absolute;
            top: -1.2rem;
            left: 1rem;
            z-index: 1;
        }

        .modal-content h2.game-title {
            font-family: 'MedievalSharp', cursive;
        }

        .font-accent {
            font-family: 'MedievalSharp', cursive;
            color: var(--warning-color); /* 給予一個醒目的顏色 */
        }

        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 700;
            transition: all 0.2s ease;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .btn-sm {
            padding: 4px 8px;
            font-size: 0.875rem;
        }

        .btn-xs {
            padding: 2px 6px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: var(--accent-text);
            border: 2px solid #5A4429;
            box-shadow: 0 2px 0 #5A4429; /* 加上底部陰影 */
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: 0 3px 0 #5A4429; /* 滑鼠懸浮時陰影加深 */
        }

        .btn-secondary {
            background-color: #4a5568;
            color: var(--accent-text);
            border-color: #2d3748;
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: #718096;
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: white;
            border-color: #c53030;
        }

        .btn-success {
            background-color: var(--success-color);
            color: white;
            border-color: #38a169;
        }

        .btn:disabled {
            background-color: #575757;
            color: #9e9e9e;
            cursor: not-allowed;
            border-color: #444;
        }

        .modal {
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        .modal-content {
            max-height: 90vh;
            width: 100%;
            max-width: 600px;
            animation: fadeIn 0.3s ease-out; /* 新增淡入動畫 */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .log-panel::-webkit-scrollbar {
            width: 8px;
        }
        .log-panel::-webkit-scrollbar-track {
            background: #2d3748;
            border-radius: 4px;
        }
        .log-panel::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 4px;
        }
        .log-panel::-webkit-scrollbar-thumb:hover {
            background: var(--accent-hover);
        }

        .log-panel {
            background-color: rgba(0, 0, 0, 0.4); /* 背景加深 */
            border-radius: 8px;
            padding: 12px;
            height: 200px;
            overflow-y: scroll;
            font-family: monospace;
            font-size: 0.875rem;
            border: 2px solid #1a202c; /* 邊框加深 */
            box-shadow: inset 0 0 8px rgba(0,0,0,0.5); /* 加上內陰影 */
        }

        .log-entry {
            padding-bottom: 4px;
            border-bottom: 1px dashed var(--border-color);
            margin-bottom: 4px;
        }

        .log-entry.player {
            color: #63b3ed;
        }

        .log-entry.enemy {
            color: #f56565;
        }

        .log-entry.system {
            color: #f6e05e;
        }

        .log-entry.info {
            color: #90cdf4;
        }

        .log-entry.success {
            color: var(--success-color);
        }

        .log-entry.crit {
            color: var(--crit-color);
            font-weight: bold;
        }

        .log-entry.skill {
            color: var(--skill-color);
            font-weight: bold;
        }

        .stat-input::-webkit-outer-spin-button,
        .stat-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .stat-input[type=number] {
            -moz-appearance: textfield;
        }

        .hidden {
            display: none;
        }

        [x-cloak] {
            display: none !important;
        }

        .glow-pulse {
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 5px #f6e05e, 0 0 10px #f6e05e;
            }

            to {
                box-shadow: 0 0 15px #f6e05e, 0 0 25px #f6e05e;
            }
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .btn:active:not(:disabled) {
            transform: translateY(2px); /* 按下時的下沉效果 */
            box-shadow: none; /* 按下時陰影消失 */
        }
        /* --- 新增的場景樣式 (2D版本) --- */
        .scene-container {
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            position: relative;
            background: radial-gradient(circle, #2d3748 50%, #1a202c 100%);
            overflow: hidden;
            border-radius: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .arena-floor {
            position: relative;
            width: 85%;
            height: 85%;
            background: #2a3442;
            border-radius: 50%;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 20px rgba(0,0,0,0.5);
            border: 2px solid #1e2530;
        }

        /* 使用偽元素繪製六芒星 */
        .arena-floor::before, .arena-floor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-left: 120px solid transparent;
            border-right: 120px solid transparent;
            transform-origin: center;
        }
        .arena-floor::before {
            border-bottom: 208px solid rgba(246, 224, 94, 0.1);
            transform: translate(-50%, -66.66%);
        }
        .arena-floor::after {
            border-top: 208px solid rgba(246, 224, 94, 0.1);
            transform: translate(-50%, -33.33%);
        }
        
        /* 石柱 */
        .pillar {
            position: absolute;
            width: 25px;
            height: 25px;
            background: linear-gradient(45deg, #333, #555);
            border: 2px solid #222;
            border-radius: 50%;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }

        /* 單位 (點) */
        .unit {
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            box-shadow: 0 0 10px 3px currentColor, inset 0 0 5px rgba(255,255,255,0.3);
            transform: translate(-50%, -50%); /* 讓 top/left 定位點在中心 */
            cursor: pointer; /* 新增鼠標指針 */
            transition: transform 0.2s ease; /* 新增懸停動畫 */
        }
        .unit:hover {
            transform: translate(-50%, -50%) scale(1.5); /* 懸停時放大 */
        }
        .player { background-color: var(--player-color); color: var(--player-color); cursor: default; }
        .knight { background-color: var(--knight-color); color: var(--knight-color); }
        .princess { background-color: var(--princess-color); color: var(--princess-color); }
        
        /* 王座 */
        .throne {
            position: absolute;
            width: 50px;
            height: 40px;
            background-color: #4a3a2a;
            border: 2px solid #2a1a0a;
            border-radius: 10px;
            transform: translate(-50%, -50%);
        }

        /* 光塵特效 */
        .dust-particle {
            position: absolute;
            background-color: rgba(255, 255, 220, 0.4);
            border-radius: 50%;
            animation: float 20s infinite linear;
            pointer-events: none; /* 讓粒子不影響點擊 */
        }
        @keyframes float {
            0% { transform: translate(0, 0); opacity: 0; }
            25% { opacity: 1; }
            50% { transform: translate(var(--tx), var(--ty)); }
            75% { opacity: 1; }
            100% { transform: translate(0, 0); opacity: 0; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
</head>

<body class="p-4 md:p-6" x-data="game()">
    <div class="max-w-7xl mx-auto">

        <audio x-ref="audioPlayer" loop></audio>

        <template x-if="screen === 'api_key_input'">
        <div id="api-key-screen" x-cloak>
            <div class="max-w-xl mx-auto game-container relative p-8 rounded-lg pt-10 text-center">
                <h1 class="game-title font-medieval">設定 API 金鑰</h1>
                <p class="text-left text-gray-300 mb-4">
                    本遊戲的 AI 敘事功能（如序幕、誕生、繁衍故事）由 Google Gemini Pro 提供技術支援。為了使用這些功能，您需要一組自己的 API 金鑰。
                </p>
                <p class="text-left text-gray-300 mb-4">
                    您可以點擊下方連結免費取得。取得後，請將金鑰貼入輸入框中。
                </p>
                <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-400 hover:underline mb-4 inline-block">
                    前往 Google AI Studio 取得免費 API 金鑰
                </a>

                <input type="text" x-model="userApiKey" class="w-full bg-gray-700 border-2 border-gray-600 rounded px-3 py-2 mb-6" placeholder="請在此貼上您的 API 金鑰...">

                <div class="flex justify-center space-x-4">
                    <button @click="submitApiKey()" class="btn btn-primary">儲存金鑰並開始遊戲</button>
                    <button @click="proceedToGame()" class="btn btn-secondary">跳過，直接開始</button>
                </div>
                <p class="text-xs text-gray-500 mt-4">（金鑰將只會儲存在您的瀏覽器本機，不會上傳到任何伺服器。）</p>
            </div>
        </div>
    </template>
    <!-- 遊戲開場敘事畫面 -->
     <div> <template x-if="screen === 'intro'">
        <div id="intro-screen" x-cloak>
        <div class="max-w-3xl mx-auto game-container relative p-8 rounded-lg flex flex-col items-center pt-10">
            <h1 class="game-title font-medieval">序幕</h1>
            <div class="min-h-[300px] w-full flex items-center justify-center p-4 bg-black bg-opacity-20 rounded mb-4">
                <div x-show="modals.narrative.isAwaitingConfirmation" class="text-center">
                    <p class="mb-4">是否要使用 AI 生成遊戲序幕故事？</p>
                    <button @click="generateIntroNarrative()" class="btn btn-primary">是，生成序幕</button>
                </div>
                <div x-show="modals.narrative.isLoading" class="loader"></div>
                <p x-show="!modals.narrative.isLoading && !modals.narrative.isAwaitingConfirmation" x-html="modals.narrative.content"
                    class="text-lg leading-relaxed"></p>
            </div>
            <button @click="screen = 'creation'" class="btn btn-primary">跳過</button>
        </div>
    </div> </template>

    <!-- 角色創建畫面 -->
    <template x-if="screen === 'creation'">
        <div id="creation-screen" x-cloak>
        <div class="max-w-4xl mx-auto game-container relative p-8 rounded-lg pt-10">
            <h1 class="game-title font-medieval">創建你的哥布林王</h1>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div class="space-y-4">
                    <input type="text" x-model="creation.name" class="w-full bg-gray-700 border-2 border-gray-600 rounded px-3 py-2" placeholder="哥布林名稱">
                    <input type="number" x-model.number="creation.height" class="w-full bg-gray-700 border-2 border-gray-600 rounded px-3 py-2" placeholder="身高">
                    <input type="number" x-model.number="creation.penisSize" class="w-full bg-gray-700 border-2 border-gray-600 rounded px-3 py-2" placeholder="王的雄風 (公分)">
                    <textarea x-model="creation.appearance" rows="4" class="w-full bg-gray-700 border-2 border-gray-600 rounded px-3 py-2" placeholder="外貌描述..."></textarea>
                </div>
                <div class="space-y-4">
                    <h2 class="text-xl font-bold text-center text-amber-200">能力點數</h2>
                    <p class="text-center mb-2">剩餘點數:
                        <span x-text="creation.pointsRemaining" :class="creation.pointsRemaining < 0 ? 'text-red-400' : 'text-green-400'"></span>
                    </p>
                    <p class="text-center text-yellow-400 h-6" x-text="creation.statWarningMessage"></p>
                    <template x-for="stat in Object.keys(creation.stats)" :key="stat">
                        <div class="space-y-2">
                            <div class="flex items-center justify-between">
                                <label class="font-bold capitalize" x-text="STAT_NAMES[stat]"></label>
                                <div class="flex items-center">
                                    <button @click="updateStat(stat, creation.stats[stat] - 1)" class="px-3 py-1 bg-gray-700 rounded-l-md">-</button>
                                    <input type="number" min="-10" max="999" x-model.number="creation.stats[stat]" @input="checkStatValue(stat, $event.target.value)" class="stat-input w-16 text-center bg-gray-800 border-y-2 border-gray-600 py-1">
                                    <button @click="updateStat(stat, creation.stats[stat] + 1)" class="px-3 py-1 bg-gray-700 rounded-r-md">+</button>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
            <div class="text-center mt-8 space-x-4">
                <button @click="createCharacter()" class="btn btn-primary text-xl">創建我的哥布林王</button>
                <button x-show="hasSaveFile" @click="loadGame()" class="btn btn-secondary text-xl">讀取遊戲</button>
            </div>
        </div>
    </template>

    <template x-if="screen === 'birth_narrative'">
        <div id="birth-narrative-screen" x-cloak>
            <div class="max-w-3xl mx-auto game-container relative p-8 rounded-lg flex flex-col items-center pt-10">
                
                <h1 class="game-title font-medieval">王的誕生</h1>
                
                <div class="min-h-[300px] w-full flex items-center justify-center p-4 bg-black bg-opacity-20 rounded mb-4">
                    <div x-show="modals.narrative.isAwaitingConfirmation" class="text-center">
                        <p class="mb-4">是否要使用 AI 生成您的誕生故事？<br>這將根據您創建的角色資訊生成一段獨特的背景描述。</p>
                        <button @click="generateBirthNarrative()" class="btn btn-primary">使用 AI 生成誕生故事</button>
                    </div>
                    <div x-show="modals.narrative.isLoading" class="loader"></div>
                    <p x-show="!modals.narrative.isLoading && !modals.narrative.isAwaitingConfirmation" x-html="modals.narrative.content" class="text-lg leading-relaxed"></p>
                </div>
                
                <button @click="screen = 'tutorial_query'" class="btn btn-primary">繼續</button>

            </div> </div>
    </template>

    <template x-if="screen === 'rebirth'">
        <div id="rebirth-screen" x-cloak>
        <div class="max-w-4xl mx-auto game-container relative p-8 rounded-lg pt-10">
            <h1 class="game-title font-medieval">哥布林王之重生</h1>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div class="space-y-4">
                    <input type="text" x-model="rebirth.name" class="w-full bg-gray-900 border-2 border-gray-600 rounded px-3 py-2 text-gray-400" placeholder="哥布林名稱" disabled>
                    <input type="number" x-model.number="rebirth.height" class="w-full bg-gray-700 border-2 border-gray-600 rounded px-3 py-2" placeholder="身高">
                    <input type="number" x-model.number="rebirth.penisSize" class="w-full bg-gray-700 border-2 border-gray-600 rounded px-3 py-2" placeholder="王的雄風 (公分)">
                    <textarea x-model="rebirth.appearance" rows="4" class="w-full bg-gray-700 border-2 border-gray-600 rounded px-3 py-2" placeholder="外貌描述..."></textarea>
                </div>
                <div class="space-y-4">
                    <h2 class="text-xl font-bold text-center text-amber-200">重新分配能力</h2>
                    <p class="text-center mb-2">
                        剩餘點數: <span x-text="rebirth.pointsRemaining" :class="rebirth.pointsRemaining < 0 ? 'text-red-400' : 'text-green-400'"></span>
                        / 總點數: <span x-text="rebirth.totalPoints"></span>
                    </p>
                    <p class="text-center text-gray-400 h-6">（每項能力值至少需要 1 點）</p>
                    <template x-for="stat in Object.keys(rebirth.stats)" :key="stat">
                        <div class="space-y-2">
                            <div class="flex items-center justify-between">
                                <label class="font-bold capitalize" x-text="STAT_NAMES[stat]"></label>
                                <div class="flex items-center">
                                    <button @click="updateRebirthStat(stat, rebirth.stats[stat] - 1)" class="px-3 py-1 bg-gray-700 rounded-l-md">-</button>
                                    <input type="number" min="1" max="999" x-model.number="rebirth.stats[stat]" @input="updateRebirthStat(stat, $event.target.value)" class="stat-input w-16 text-center bg-gray-800 border-y-2 border-gray-600 py-1">
                                    <button @click="updateRebirthStat(stat, rebirth.stats[stat] + 1)" class="px-3 py-1 bg-gray-700 rounded-r-md">+</button>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
            <div class="text-center mt-8">
                <button @click="confirmRebirth()" class="btn btn-primary text-xl">確認重生</button>
            </div>
        </div>
    </template>

    <template x-if="screen === 'breeding_narrative'">
        <div id="breeding-narrative-screen" x-cloak>
            <div class="max-w-3xl mx-auto game-container relative p-8 rounded-lg flex flex-col items-center pt-10">
                <h1 class="game-title font-medieval">繁衍</h1>

                <div class="min-h-[300px] w-full flex items-center justify-center p-4 bg-black bg-opacity-20 rounded mb-4">
                    <div x-show="modals.narrative.isLoading" class="loader"></div>
                    <p x-show="!modals.narrative.isLoading" x-html="modals.narrative.content || '請選擇您的行動...'"></p>
                </div>

                <div class="w-full space-y-2">
                    <div class="grid grid-cols-3 gap-2">
                        <button @click="confirmAndStartBreedingNarrative()" class="btn btn-primary" :disabled="modals.narrative.hasBred || modals.narrative.isLoading">
                            使用 AI 敘事
                        </button>
                        <button @click="generateNarrativeSegment('繼續')" class="btn btn-secondary" :disabled="!modals.narrative.content || modals.narrative.hasBred || modals.narrative.isLoading">
                            繼續
                        </button>
                        <button @click="generateNarrativeSegment('將巨根挺入')" class="btn btn-secondary" :disabled="!modals.narrative.content || modals.narrative.hasBred || modals.narrative.isLoading">
                            將巨根挺入
                        </button>
                    </div>
                    
                    <div class="grid grid-cols-1 gap-2">
                        <button @click="confirmAndNarrateBreeding()" class="btn btn-info" :disabled="modals.narrative.hasBred || modals.narrative.isLoading">
                            繁衍 (觸發AI結局)
                        </button>
                        
                        <button x-show="modals.narrative.hasBred" @click="finalizeBreedingAndReturn()" class="btn btn-success">
                            返回部落畫面
                        </button>

                        <button x-show="!modals.narrative.hasBred" @click="executeQuickBreedingAndReturn()" class="btn btn-danger">
                            直接繁衍 (跳過敘事)
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </template>

    <!-- 教學詢問畫面 -->
    <template x-if="screen === 'tutorial_query'">
    <div id="tutorial-query-screen" x-cloak>
        <div class="max-w-xl mx-auto game-container relative p-8 rounded-lg pt-10 text-center">
            <h1 class="game-title font-medieval">引導</h1>
            <p class="text-lg mb-6">王，您已降臨於此。本遊戲與您所知的可能不盡相同，初期將充滿挑戰。您需要基本的引導嗎？</p>
            <div class="flex justify-center space-x-4">
                <button @click="startTutorial(true)" class="btn btn-primary">是，我需要引導</button>
                <button @click="startTutorial(false)" class="btn btn-secondary">否，祝我在這世界玩得愉快</button>
            </div>
        </div>
    </div>
    </template>

    <!-- 主遊戲畫面 (部落中心) -->
    <template x-if="screen === 'tribe'">
        <div id="tribe-screen" x-cloak x-init="initializeTribe()">
            <template x-if="player && screen === 'tribe'">
                <div class="max-w-7xl mx-auto">
                    <div class="space-y-6">
    
                        <div class="game-container relative p-4 rounded-lg pt-10">
                            <h2 class="game-title font-medieval">王之號令</h2>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                                <button @click="handleRaidButtonClick()" class="btn btn-primary" :class="{ 'glow-pulse': tutorial.active && tutorial.step === 5 }">出擊掠奪</button>
                                <button @click="handleConstructionClick()" class="btn btn-primary" :class="{ 'glow-pulse': tutorial.active && tutorial.step === 2 }">部落建設</button>
                                <button @click="openMerchant()" class="btn btn-primary" :disabled="!merchant.isPresent" title="旅行商人來訪時才能進入">
                                    商人營地 <span x-show="merchant.isPresent" class="text-yellow-300">(來訪中)</span>
                                </button>
                            </div>
                        </div>
    
                        <div class="game-container relative p-4 rounded-lg pt-10 h-full">
                            <h2 class="game-title font-medieval">王國總覽</h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6">
                                <div>
                                    <div class="flex gap-x-4">
                                        <div class="w-1/3 flex-shrink-0">
                                            <div class="w-full h-48 bg-gray-800 rounded flex items-center justify-center text-gray-500">
                                                <template x-if="player.avatarUrl">
                                                    <img :src="player.avatarUrl" class="w-full h-full object-cover rounded" alt="Player Avatar">
                                                </template>
                                                <template x-if="!player.avatarUrl">
                                                    <span>頭像</span>
                                                </template>
                                            </div>
                                        </div>
                                        <div class="w-2/3 space-y-2">
                                            <p><strong>名稱:</strong> <span class="font-accent" x-text="player.name"></span></p>
                                            <p class="font-bold text-amber-200" :class="{'text-red-400': isStarving}">總能力值
                                                <span x-show="isStarving">(飢餓中 -25%)</span>:
                                            </p>
                                            <p class="text-sm"><strong>生命值:</strong>
                                                <span x-text="player.currentHp"></span> / <span x-text="player.calculateMaxHp(isStarving)"></span>
                                            </p>
                                            <ul class="list-disc list-inside space-y-1 text-sm pt-1">
                                                <template x-for="stat in ['strength', 'agility', 'intelligence', 'luck']" :key="stat">
                                                    <li class="flex items-center justify-between">
                                                        <div>
                                                            <span class="capitalize" x-text="STAT_NAMES[stat]"></span>:
                                                            <span x-text="player.stats[stat]"></span>
                                                            <span class="text-yellow-400 font-bold" x-show="tempStatIncreases[stat] > 0" x-text="` (+${tempStatIncreases[stat]})`"></span>
                                                            <span class="text-green-400" x-show="player.getPartyBonus(stat) > 0" x-text="` (+${player.getPartyBonus(stat)})`"></span>
                                                            <span class="text-purple-400" x-show="player.getAffixEffect(stat).bonus > 0" x-text="` (+${player.getAffixEffect(stat).bonus})`"></span>
                                                            <span class="text-blue-400" x-show="player.getEffectiveEquipmentBonus(stat) > 0" x-text="` (+${player.getEffectiveEquipmentBonus(stat)})`"></span>
                                                            <span class="text-red-400" x-show="isStarving" x-text="` -> ${player.getTotalStat(stat, isStarving)}`"></span>
                                                        </div>
                                                        <button @click="addTempPoint(stat)" x-show="player.attributePoints > 0 && (player.attributePoints - Object.values(tempStatIncreases).reduce((a, b) => a + b, 0)) > 0" class="btn btn-sm btn-primary ml-2 w-8" :class="{'glow-pulse': tutorial.active && !tutorial.finishedAttributePoints && player.attributePoints > 0}">+</button>
                                                    </li>
                                                </template>
                                            </ul>
                                            <div x-show="Object.values(tempStatIncreases).reduce((a, b) => a + b, 0) > 0" class="mt-2 text-right space-x-2">
                                                <button @click="confirmAttributePoints()" class="btn btn-sm btn-success">確認分配</button>
                                                <button @click="cancelAttributePoints()" class="btn btn-sm btn-secondary">取消</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="grid grid-cols-3 text-sm text-center border-y border-gray-700 py-1 my-2">
                                        <div>
                                            <span class="text-gray-400 block text-xs">天數</span>
                                            <span x-text="day"></span>
                                        </div>
                                        <div>
                                            <span class="text-gray-400 block text-xs">能力點</span>
                                            <span x-text="player.attributePoints - Object.values(tempStatIncreases).reduce((a, b) => a + b, 0)"></span>
                                        </div>
                                        <div>
                                            <span class="text-gray-400 block text-xs">技能點</span>
                                            <span x-text="player.skillPoints"></span>
                                        </div>
                                    </div>
                                </div>
                                <div class="space-y-4 mt-4 md:mt-0">
                                    <div>
                                        <p class="mt-4 font-bold text-amber-200 flex justify-between items-center">
                                            <span>當前裝備:</span>
                                            <button @click="openPlayerEquipment()" class="btn btn-xs btn-secondary">管理裝備</button>
                                        </p>
                                        <div class="space-y-1 text-sm">
                                            <template x-for="slot in Object.keys(player.equipment)" :key="slot">
                                                <div class="flex justify-between items-center">
                                                    <span class="capitalize" x-text="EQUIPMENT_SLOTS[slot] || slot"></span>
                                                    <template x-if="player.equipment[slot]">
                                                        <div class="text-right">
                                                            <span :style="{ color: player.equipment[slot].quality.color }" x-text="player.equipment[slot].name"></span>
                                                            <button @click="unequipItem(slot, player)" class="btn btn-xs btn-secondary ml-2">卸下</button>
                                                        </div>
                                                    </template>
                                                    <template x-if="!player.equipment[slot]">
                                                        <span class="text-gray-500">-- 無 --</span>
                                                    </template>
                                                </div>
                                            </template>
                                        </div>
                                    </div>
                                    <div class="grid grid-cols-2 gap-x-4 pt-4 mt-4 border-t border-gray-700">
                                        <div>
                                            <p class="font-bold text-amber-200">部落資源:</p>
                                            <ul class="list-disc list-inside ml-4 text-sm">
                                                <li>食物: <span x-text="resources.food"></span> / <span x-text="foodCapacity"></span></li>
                                                <li>木材: <span x-text="resources.wood"></span> / <span x-text="woodCapacity"></span></li>
                                                <li>礦石: <span x-text="resources.stone"></span> / <span x-text="stoneCapacity"></span></li>
                                            </ul>
                                        </div>
                                        <div>
                                            <p class="font-bold text-amber-200">部落人口:</p>
                                            <ul class="list-disc list-inside ml-4 text-sm">
                                                <li>夥伴: <span x-text="partners.length"></span> /
                                                    <span x-text="partnerCapacity"></span>
                                                </li>
                                                <li>俘虜: <span x-text="dungeonCaptives.length"></span> /
                                                    <span x-text="captiveCapacity"></span>
                                                </li>
                                                <li>孕母: <span x-text="mothers.length"></span> /
                                                    <span x-text="maternityCapacity"></span>
                                                </li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
    
                        <div class="game-container relative p-4 rounded-lg pt-10">
                            <h2 class="game-title font-medieval">遊戲存檔</h2>
                            <div class="flex space-x-4">
                                <button @click="saveGame()" class="btn btn-primary">儲存進度</button>
                                <button x-show="hasSaveFile" @click="loadGame()" class="btn btn-secondary">讀取進度</button>
                            </div>
                        </div>
    
                        <div class="game-container relative p-4 rounded-lg pt-10">
                            <h2 class="game-title font-medieval">部落日誌</h2>
                            <div class="log-panel" id="tribe" x-init="$watch('logs.tribe', () => { $nextTick(() => { $el.scrollTop = $el.scrollHeight }) })">
                                <template x-for="entry in logs.tribe" :key="entry.id">
                                    <div :class="`log-entry ${entry.type}`" x-html="entry.message"></div>
                                </template>
                            </div>
                        </div>
    
                        <div class="game-container relative p-4 rounded-lg pt-10">
                            <h2 class="game-title font-medieval">音樂設定</h2>
                            <div class="flex items-center space-x-4">
                                <label class="btn btn-secondary cursor-pointer">
                                    <span>選擇檔案</span>
                                    <input type="file" @change="loadMusic($event)" accept="audio/*" class="hidden">
                                </label>
                                <button @click="toggleMusic()" class="btn btn-primary w-24" :disabled="!musicSettings.src">
                                    <span x-text="musicSettings.isPlaying ? '暫停' : '播放'"></span>
                                </button>
                                <div>
                                    <label for="play-scene" class="text-sm mr-2">播放場景:</label>
                                    <select x-model="musicSettings.playOnScreen" id="play-scene" class="bg-gray-700 border-2 border-gray-600 rounded px-3 py-2">
                                        <option value="tribe">部落</option>
                                        <option value="raid_selection">掠奪選擇</option>
                                        <option value="raid">掠奪地圖</option>
                                        <option value="combat">戰鬥</option>
                                        <option value="throne_room">王座之間</option>
                                    </select>
                                </div>
                            </div>
                        </div>
    
                    </div>
                </div>
            </template>
        </div>
    </template>
    
        <!-- 掠奪選擇畫面 -->
        <template x-if="screen === 'raid_selection'">
            <div id="raid-selection-screen" x-cloak>
            <div class="max-w-2xl mx-auto game-container relative p-8 rounded-lg pt-10">
                <h1 class="game-title font-medieval">選擇掠奪目標</h1>
                <div class="space-y-4">
                    <template x-for="raid in raidOptions">
                        <button @click="startRaid(raid.difficulty)" class="w-full text-left p-4 rounded-lg transition bg-gray-700 hover:bg-gray-600" :disabled="buildings.dungeon.level === 0" :class="{ 'glow-pulse': tutorial.active && tutorial.step === 5 && raid.difficulty === 'easy' }">
                            <div>
                                <h3 class="text-xl font-bold" x-text="raid.name"></h3>
                                <p x-text="raid.description"></p>
                            </div>
                            <p x-show="buildings.dungeon.level === 0" class="text-red-400 text-sm mt-1">需要先建造地牢才能出擊！</p>
                        </button>
                    </template>
                </div>
                <div class="text-center mt-6">
                    <button @click="screen = 'tribe'" class="btn btn-secondary">返回部落</button>
                </div>
            </div>
        </template>

    <!-- 掠奪畫面 -->
    <template x-if="screen === 'raid'">
    <div id="raid-screen" x-cloak>
    <template x-if="currentRaid">
        <div class="flex flex-col lg:flex-row gap-6">

            <div class="flex-shrink-0 lg:w-1/3 space-y-6">
                <div class="game-container relative p-4 rounded-lg pt-10">
                    <h2 class="game-title font-medieval">掠奪指令</h2>
                    <div class="grid grid-cols-2 gap-4">
                        <button @click="scoutEnvironment()" class="btn btn-primary" :disabled="currentRaid.currentZone.scouted.environment" :class="{'glow-pulse': tutorial.active && tutorial.step === 4.5}">偵查環境</button>
                        <button @click="modals.raidStatus.isOpen = true" class="btn btn-secondary">查看狀態</button>

                        <button @click="modals.raidCaptives.isOpen = true" class="btn btn-secondary">查看俘虜</button>

                        <button @click="sneakPastGuards()" class="btn btn-primary" x-show="currentRaid.currentZoneIndex === 0 && currentRaid.currentZone.buildings.find(b => b.type === '衛兵所' && b.occupants.length > 0)">潛行繞過守軍</button>
                        <button @click="advanceToNextZone()" class="btn btn-secondary" :disabled="!canAdvance()">深入內城</button>
                        <button @click="handleRetreatAction()" class="btn btn-danger col-span-full">
                            <span x-text="currentRaid && currentRaid.currentZoneIndex > 0 ? '撤退回上層' : '脫離城鎮'"></span>
                        </button>
                    </div>
                </div>
            </div>

            <div class="flex-grow flex flex-col gap-6">
                <div class="game-container relative p-4 rounded-lg pt-10 flex-grow">
                    <h2 class="game-title font-medieval" x-text="(currentRaid?.currentZone?.name || '') + ' 地圖'"></h2>
                    <div 
                        class="map-container-responsive"
                        x-ref="mapContainer"
                        x-init="() => {
                            const observer = new ResizeObserver(() => {
                                if ($refs.mapContainer) {
                                    mapScale = $refs.mapContainer.offsetWidth / MAP_WIDTH;
                                }
                            });
                            observer.observe($refs.mapContainer);
                        }"
                    >
                        <div class="map-canvas" :style="`transform: scale(${mapScale});`">
                            <div class="relative bg-gray-800" :style="`width: ${MAP_WIDTH}px; height: ${MAP_HEIGHT}px;`">
                                <div class="absolute top-0 left-0 right-0 p-2 bg-black bg-opacity-40 text-center text-white">
                                    <span class="font-bold text-lg" x-text="currentRaid?.locationName"></span> | 
                                    <span>剩餘時間: </span>
                                    <span class="font-bold" :class="currentRaid?.timeRemaining < 30 ? 'text-red-400' : 'text-yellow-300'" x-text="currentRaid?.timeRemaining ?? 0"></span>
                                    <span> 分鐘</span>
                                </div>

                                <div class="absolute bottom-0 left-0 p-2 bg-black bg-opacity-40 text-white text-sm">
                                    <span>區域: </span>
                                    <span class="font-bold" x-text="currentRaid?.currentZone?.name"></span>
                                </div>

                                <div x-show="currentRaid.currentZone.scouted.environment" 
                                    class="absolute bottom-0 left-1/2 -translate-x-1/2 p-2 bg-black bg-opacity-40 text-white text-sm whitespace-nowrap">
                                    <span>區域資源: </span>
                                    <span class="text-green-400">食 <span x-text="currentRaid.currentZone.resources.food"></span></span> | 
                                    <span class="text-yellow-500">木 <span x-text="currentRaid.currentZone.resources.wood"></span></span> | 
                                    <span class="text-gray-400">礦 <span x-text="currentRaid.currentZone.resources.stone"></span></span>
                                </div>

                                <div class="absolute bottom-0 right-0 p-2 bg-black bg-opacity-40 text-white text-sm">
                                    <span>攜帶俘虜: </span>
                                    <span class="font-bold" x-text="currentRaid?.carriedCaptives.length ?? 0"></span> /
                                    <span class="font-bold" x-text="carryCapacity"></span>
                                </div>

                                <div x-show="currentRaid.currentZone.scouted.environment">
                                    <template x-for="building in currentRaid.currentZone.buildings" :key="building.id">
                                        <div @click="handleMapClick(building, $event)" class="absolute border-2 border-gray-500 bg-gray-700/50 flex flex-col items-center justify-center text-center p-1 cursor-pointer hover:border-yellow-400" :style="`left:${building.x}px; top:${building.y}px; width:${building.width}px; height:${building.height}px;`" :class="{'border-yellow-400': selectedTarget && selectedTarget.id === building.id}">
                                            <span class="text-xs leading-tight" x-text="building.type + building.postScoutText"></span>
                                        </div>
                                    </template>
                                    <template x-for="enemyGroup in currentRaid.currentZone.enemies" :key="enemyGroup[0].id">
                                        <div @click="handleMapClick(enemyGroup, $event)" class="absolute w-4 h-4 rounded-full border-2 border-black cursor-pointer transform -translate-x-1/2 -translate-y-1/2 hover:scale-150 transition-transform" :class="[getUnitColor(enemyGroup), {'ring-2 ring-offset-2 ring-offset-gray-800 ring-yellow-400': selectedTarget && selectedTarget[0] && selectedTarget[0].id === enemyGroup[0].id}]" :style="`left:${enemyGroup[0].x}px; top:${enemyGroup[0].y}px;`"></div>
                                    </template>
                                </div>
                                <div class="absolute w-5 h-5 rounded-full border-2 border-black transition-all duration-300" :class="getUnitColor(player)" :style="`left:${playerMapPosition.x}px; top:${playerMapPosition.y}px;`"></div>

                                <template x-if="selectedTarget">
                                    <div class="absolute bg-gray-900/80 p-2 rounded-lg border border-gray-600 space-y-2 z-10" :style="getInteractionMenuPosition()">

                                        <template x-if="Array.isArray(selectedTarget)">
                                            <button @click="scoutTarget(selectedTarget)" class="btn btn-xs btn-secondary w-full">偵查</button>
                                            <template x-if="isTargetScouted(selectedTarget[0].id)">
                                                <button @click="startCombat(selectedTarget)" class="btn btn-xs btn-danger w-full">攻擊</button>
                                            </template>
                                            <template x-if="selectedTarget.some(e => e.visual)">
                                                <button @click="executeSneakKidnapFromMap()" class="btn btn-xs btn-secondary w-full">潛行擄走</button>
                                            </template>
                                        </template>

                                        <template x-if="!Array.isArray(selectedTarget)">
                                            <button @click="executeBuildingScout(selectedTarget)" class="btn btn-xs btn-secondary w-full">偵查</button>
                                        </template>

                                    </div>
                                </template>

                            </div>
                        </div>
                    </div>
                </div>
                <div class="game-container relative p-4 rounded-lg pt-10">
                    <h2 class="game-title font-medieval">掠奪日誌</h2>
                    <div class="log-panel" id="raidl" x-init="$watch('logs.raid', () => { $nextTick(() => { $el.scrollTop = $el.scrollHeight }) })">
                        <template x-for="entry in logs.raid" :key="entry.id">
                            <div :class="`log-entry ${entry.type}`" x-html="entry.message"></div>
                        </template>
                    </div>
                </div>
            </div>
        </div>
    </template>
    </div>
</template>

    <!-- 戰鬥畫面 -->
    <template x-if="screen === 'combat'">
        <div id="combat-screen" x-cloak>
        <div class="max-w-5xl mx-auto game-container relative p-6 rounded-lg pt-10">
            <h1 class="game-title font-medieval">戰鬥中</h1>
            <div class="grid grid-cols-2 gap-6">
                <div>
                    <h3 class="text-lg font-bold text-green-400">我方隊伍
                        (<span x-text="combat.allies.filter(u => u.isAlive()).length"></span>)</h3>
                    <div class="space-y-1 mt-2 text-sm">
                        <template x-for="unit in combat.allies">
                            <p :class="!unit.isAlive() ? 'text-gray-500 line-through' : ''">
                                <span x-text="unit.name"></span> - HP: <span x-text="unit.currentHp"></span> /
                                <span x-text="unit.maxHp"></span>
                            </p>
                        </template>
                    </div>
                </div>
                <div>
                    <h3 class="text-lg font-bold text-red-400">敵方隊伍
                        (<span x-text="combat.enemies.filter(u => u.isAlive()).length"></span>)</h3>
                    <div class="space-y-1 mt-2 text-sm">
                        <template x-for="unit in combat.enemies">
                            <p :class="!unit.isAlive() ? 'text-gray-500 line-through' : ''">
                                <span x-text="unit.name"></span> (<span x-text="unit.profession"></span>) - HP:
                                <span x-text="unit.currentHp"></span> / <span x-text="unit.maxHp"></span>
                            </p>
                        </template>
                    </div>
                </div>
            </div>
            <div class="mt-4">
                <h3 class="font-bold">戰鬥紀錄</h3>
                <div class="log-panel" id="combat" x-init="$watch('logs.combat', () => { $nextTick(() => { $el.scrollTop = $el.scrollHeight }) })">
                    <template x-for="entry in logs.combat" :key="entry.id">
                        <div :class="`log-entry ${entry.type}`" x-html="entry.message"></div>
                    </template>
                </div>
            </div>
            <div class="mt-4 text-center space-x-4">
                <button @click="executePlayerAction('attack')" class="btn btn-primary" :disabled="!player || !player.isAlive() || combat.isProcessing || combat.playerActionTaken">普通攻擊</button>
                <button @click="executePlayerAction('escape')" class="btn btn-secondary" :disabled="!player || !player.isAlive() || combat.isProcessing || combat.playerActionTaken || combat.isReinforcementBattle">潛行脫離</button>
            </div>
        </div>
    </template>

    <!-- MODALS -->
    <template x-if="player">

        <div class="modal" x-show="modals.construction.isOpen" x-cloak >
            <div class="modal-content game-container relative p-6 rounded-lg">
                <h2 class="game-title font-medieval">部落建設</h2>
                <div class="pt-10 max-h-[80vh] overflow-y-auto">
                    <div class="flex border-b border-gray-600 mb-4 overflow-x-auto">
                        <button @click="modals.construction.activeTab = 'dungeon'" :class="{ 'bg-gray-700 text-white': modals.construction.activeTab === 'dungeon', 'glow-pulse': tutorial.active && tutorial.step === 3 }" class="flex-shrink-0 py-2 px-4 rounded-t-lg">地牢</button>
                        <button @click="modals.construction.activeTab = 'barracks'" :class="{ 'bg-gray-700 text-white': modals.construction.activeTab === 'barracks' }" class="flex-shrink-0 py-2 px-4 rounded-t-lg">寢室</button>
                        <button @click="modals.construction.activeTab = 'warehouse'" :class="{ 'bg-gray-700 text-white': modals.construction.activeTab === 'warehouse' }" class="flex-shrink-0 py-2 px-4 rounded-t-lg">倉庫</button>
                        <button @click="modals.construction.activeTab = 'armory'" :class="{ 'bg-gray-700 text-white': modals.construction.activeTab === 'armory' }" class="flex-shrink-0 py-2 px-4 rounded-t-lg">兵工廠</button>
                        <button @click="modals.construction.activeTab = 'maternity'" :class="{ 'bg-gray-700 text-white': modals.construction.activeTab === 'maternity', 'glow-pulse': tutorial.active && tutorial.step === 4 }" class="flex-shrink-0 py-2 px-4 rounded-t-lg">產房</button>
                        <button @click="modals.construction.activeTab = 'trainingGround'" :class="{ 'bg-gray-700 text-white': modals.construction.activeTab === 'trainingGround' }" class="flex-shrink-0 py-2 px-4 rounded-t-lg">訓練場</button>
                        <button @click="modals.construction.activeTab = 'merchantCamp'" :class="{ 'bg-gray-700 text-white': modals.construction.activeTab === 'merchantCamp' }" class="flex-shrink-0 py-2 px-4 rounded-t-lg">商人營地</button>
                    </div>

                    <div x-show="modals.construction.activeTab === 'dungeon'">
                        <div class="flex border-b border-gray-600 mb-4">
                            <button @click="modals.dungeon.subTab = 'manage'" :class="{ 'bg-gray-700 text-white': modals.dungeon.subTab === 'manage' }" class="flex-1 py-2 px-4 rounded-t-lg text-sm">管理俘虜</button>
                            <button @click="modals.dungeon.subTab = 'breed'" :class="{ 'bg-gray-700 text-white': modals.dungeon.subTab === 'breed', 'glow-pulse': tutorial.active && tutorial.step === 5 }" class="flex-1 py-2 px-4 rounded-t-lg text-sm">繁衍後代</button>
                            <button @click="modals.dungeon.subTab = 'upgrade'" :class="{ 'bg-gray-700 text-white': modals.dungeon.subTab === 'upgrade', 'glow-pulse': tutorial.active && tutorial.step === 3 }" class="flex-1 py-2 px-4 rounded-t-lg text-sm">升級</button>
                        </div>
                        <div x-show="modals.dungeon.subTab === 'manage'">
                           <h3 class="text-xl font-bold mb-2">管理俘虜</h3>
                            <p class="mb-4">目前俘虜: <span x-text="dungeonCaptives.length"></span> / <span x-text="captiveCapacity"></span></p>
                            <div class="space-y-4">
                                <template x-for="captive in dungeonCaptives" :key="captive.id">
                                    <div class="p-3 border border-gray-600 rounded">
                                        <div class="flex justify-between items-start">
                                            <div><p class="text-lg font-bold text-amber-200"><span x-text="captive.name"></span> - <span x-text="captive.profession"></span></p></div>
                                            <div class="text-right text-sm"><p>魅力: <span class="font-bold" x-text="captive.stats.charisma"></span></p></div>
                                        </div>
                                        <div class="mt-2 pt-2 border-t border-gray-600 grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                                            <div><strong>力量:</strong> <span x-text="captive.stats.strength"></span></div>
                                            <div><strong>敏捷:</strong> <span x-text="captive.stats.agility"></span></div>
                                            <div><strong>智力:</strong> <span x-text="captive.stats.intelligence"></span></div>
                                            <div><strong>運氣:</strong> <span x-text="captive.stats.luck"></span></div>
                                        </div>
                                        <div class="text-right mt-2"><button @click="releaseCaptive(captive.id)" class="btn btn-danger btn-sm">拋棄</button></div>
                                    </div>
                                </template>
                                <p x-show="dungeonCaptives.length === 0" class="text-center text-gray-400">地牢中沒有任何俘虜。</p>
                            </div>
                        </div>
                        <div x-show="modals.dungeon.subTab === 'breed'">
                            <h3 class="text-xl font-bold mb-2">繁衍後代</h3>
                            <p class="mb-4">選擇要繁衍的對象。每日剩餘次數: <span x-text="breedingChargesLeft"></span> / <span x-text="totalBreedingCharges"></span></p>
                            <div class="space-y-2">
                                <template x-for="captive in dungeonCaptives" :key="captive.id">
                                    <label class="p-3 border border-gray-600 rounded block cursor-pointer hover:bg-gray-700 transition-colors">
                                        <div class="flex justify-between items-start">
                                            <div class="flex-grow">
                                                <p class="font-bold text-amber-200"><span x-text="captive.name"></span> (<span x-text="captive.profession"></span>)</p>
                                                <p class="text-sm text-pink-400">魅力: <span x-text="captive.stats.charisma"></span></p>
                                                
                                                <template x-if="captive.visual">
                                                    <div class="mt-2 pt-2 border-t border-gray-700 text-xs text-gray-400 grid grid-cols-2 gap-x-3 gap-y-1">
                                                        <span>身高: <span x-text="captive.visual.height + ' cm'"></span></span>
                                                        <span>胸圍: <span x-text="captive.visual.bust"></span></span>
                                                        <span>髮色: <span x-text="captive.visual.hairColor"></span></span>
                                                        <span>髮型: <span x-text="captive.visual.hairStyle"></span></span>
                                                        <span>個性: <span x-text="captive.visual.personality"></span></span>
                                                    </div>
                                                </template>
                                            </div>
                                            
                                            <div class="flex-shrink-0 ml-4">
                                                <input type="checkbox" :value="captive.id" x-model="modals.dungeon.selectedBreedIds" @click.stop class="form-checkbox h-5 w-5 bg-gray-800 border-gray-500 text-green-500 focus:ring-green-500">
                                            </div>
                                        </div>
                                    </label>
                                </template>
                                <p x-show="dungeonCaptives.length === 0" class="text-center text-gray-400">沒有可繁衍的對象。</p>
                            </div>
                            <div class="text-center mt-4">
                                <button @click="handleBreedingClick()"
                                        :disabled="modals.dungeon.selectedBreedIds.length === 0 || modals.dungeon.selectedBreedIds.length > breedingChargesLeft || (mothers.length + modals.dungeon.selectedBreedIds.length) > maternityCapacity || maternityCapacity === 0"
                                        class="btn btn-primary"
                                        :class="{'glow-pulse': tutorial.active && !tutorial.finishedIntro && dungeonCaptives.length > 0}">
                                    執行繁衍 (<span x-text="modals.dungeon.selectedBreedIds.length"></span>)
                                </button>
                                <p x-show="maternityCapacity === 0" class="text-red-400 text-sm mt-2">請先建造或升級產房！</p>
                                <p x-show="maternityCapacity > 0 && mothers.length >= maternityCapacity" class="text-red-400 text-sm mt-2">產房已滿！</p>
                            </div>
                        </div>
                        <div x-show="modals.dungeon.subTab === 'upgrade'">
                            <h3 class="text-xl font-bold mb-2">升級地牢 (等級 <span x-text="buildings.dungeon.level"></span>)</h3>
                            <p class="text-sm text-gray-400 mb-4">增加俘虜容量上限。</p>
                            <template x-if="buildings.dungeon.level < 6">
                                <div>
                                    <p class="text-sm">
                                        <span x-text="buildings.dungeon.level === 0 ? '建造花費:' : `升級至 ${buildings.dungeon.level + 1} 級花費:`"></span>
                                        <span x-text="getBuildingUpgradeCost('dungeon').wood"></span> 木材,
                                        <span x-text="getBuildingUpgradeCost('dungeon').stone"></span> 礦石
                                    </p>
                                    <button @click="upgradeBuilding('dungeon')" class="btn btn-primary mt-2" :disabled="!canAffordBuildingUpgrade('dungeon')" :class="{'glow-pulse': tutorial.active && tutorial.step === 2}">
                                        <span x-text="buildings.dungeon.level === 0 ? '建造' : '升級'"></span>
                                    </button>
                                </div>
                            </template>
                            <p x-show="buildings.dungeon.level >= 6" class="text-sm text-green-400 mt-2">地牢已達到最大等級！</p>
                        </div>
                    </div>
                    
                    <div x-show="modals.construction.activeTab === 'barracks'">
                        <div class="flex border-b border-gray-600 mb-4">
                            <button @click="modals.barracks.subTab = 'manage'" :class="{ 'bg-gray-700 text-white': modals.barracks.subTab === 'manage', 'glow-pulse': tutorial.active && !tutorial.finishedPartyMgmt && partners.length > 0 }" class="flex-1 py-2 px-4 rounded-t-lg text-sm">管理夥伴</button>
                            <button @click="modals.barracks.subTab = 'upgrade'" :class="{ 'bg-gray-700 text-white': modals.barracks.subTab === 'upgrade' }" class="flex-1 py-2 px-4 rounded-t-lg text-sm">升級</button>
                        </div>
                        <div x-show="modals.barracks.subTab === 'manage'">
                            <h3 class="text-xl font-bold mb-2">管理夥伴</h3>
                            <p class="mb-2">選擇最多 20 名夥伴加入你的出擊隊伍。</p>
                            <p class="mb-4">目前夥伴: <span x-text="partners.length"></span> / <span x-text="partnerCapacity"></span> | 當前隊伍: <span x-text="player?.party.length || 0"></span> / 20</p>
                            <div class="space-y-2">
                                <template x-for="p in partners" :key="p.id">
                                    <div class="p-2 border border-gray-600 rounded">
                                        <label class="flex justify-between items-center cursor-pointer hover:bg-gray-700 p-1 rounded-t">
                                            <div>
                                                <p class="font-bold text-amber-200" x-text="p.name"></p>
                                                <div class="text-xs text-gray-400 grid grid-cols-2 gap-x-4">
                                                    <span>力:<span x-text="p.stats.strength"></span><span class="text-blue-400" x-show="p.getEquipmentBonus('strength') > 0" x-text="` (+${p.getEquipmentBonus('strength')})`"></span></span>
                                                    <span>敏:<span x-text="p.stats.agility"></span><span class="text-blue-400" x-show="p.getEquipmentBonus('agility') > 0" x-text="` (+${p.getEquipmentBonus('agility')})`"></span></span>
                                                    <span>智:<span x-text="p.stats.intelligence"></span><span class="text-blue-400" x-show="p.getEquipmentBonus('intelligence') > 0" x-text="` (+${p.getEquipmentBonus('intelligence')})`"></span></span>
                                                    <span>運:<span x-text="p.stats.luck"></span><span class="text-blue-400" x-show="p.getEquipmentBonus('luck') > 0" x-text="` (+${p.getEquipmentBonus('luck')})`"></span></span>
                                                </div>
                                                <p class="text-xs text-gray-400 mt-1">
                                                    <span>HP:</span>
                                                    <span x-text="p.calculateMaxHp(isStarving)"></span>
                                                    <span class="text-blue-400" x-show="p.getEquipmentBonus('hp') > 0" x-text="` (基礎 ${p.calculateMaxHp(isStarving) - p.getEquipmentBonus('hp')} + 裝備 ${p.getEquipmentBonus('hp')})`"></span>
                                                </p>
                                            </div>
                                            <input type="checkbox" :value="p.id" x-model="modals.barracks.selectedPartyIds" class="form-checkbox h-5 w-5 bg-gray-800 border-gray-500 text-green-500 focus:ring-green-500" :disabled="!modals.barracks.selectedPartyIds.includes(p.id) && modals.barracks.selectedPartyIds.length >= 20">
                                        </label>
                                        <div class="text-right pt-2 border-t border-gray-700">
                                            <button @click="openPartnerEquipment(p.id)" class="btn btn-secondary btn-sm">裝備</button>
                                            <button @click="releasePartner(p.id)" class="btn btn-danger btn-sm">逐出部落</button>
                                        </div>
                                    </div>
                                </template>
                                <p x-show="partners.length === 0" class="text-center text-gray-400">沒有任何夥伴。</p>
                            </div>
                            <div class="text-center mt-4">
                                <button @click="confirmPartySelection()" class="btn btn-primary">確認隊伍</button>
                            </div>
                        </div>
                        <div x-show="modals.barracks.subTab === 'upgrade'">
                            <h3 class="text-xl font-bold mb-2">升級寢室 (等級 <span x-text="buildings.barracks.level"></span>)</h3>
                            <p class="text-sm text-gray-400 mb-4">增加哥布林夥伴數量上限。</p>
                            <template x-if="buildings.barracks.level < 5">
                                <div>
                                    <p class="text-sm">
                                        <span x-text="buildings.barracks.level === 0 ? '建造花費:' : `升級至 ${buildings.barracks.level + 1} 級花費:`"></span>
                                        
                                        <span x-show="getBuildingUpgradeCost('barracks').food > 0">
                                            <span x-text="getBuildingUpgradeCost('barracks').food"></span> 食物, 
                                        </span>
                                        
                                        <span x-text="getBuildingUpgradeCost('barracks').wood"></span> 木材,
                                        <span x-text="getBuildingUpgradeCost('barracks').stone"></span> 礦石
                                    </p>
                                    <button @click="upgradeBuilding('barracks')" class="btn btn-primary mt-2" :disabled="!canAffordBuildingUpgrade('barracks')">
                                        <span x-text="buildings.barracks.level === 0 ? '建造' : '升級'"></span>
                                    </button>
                                </div>
                            </template>
                            <p x-show="buildings.barracks.level >= 5" class="text-sm text-green-400 mt-2">寢室已達到最大等級！</p>
                        </div>
                    </div>

                    <div x-show="modals.construction.activeTab === 'warehouse'">
                        <div class="flex border-b border-gray-600 mb-4">
                            <button @click="modals.warehouse.subTab = 'manage'" :class="{ 'bg-gray-700 text-white': modals.warehouse.subTab === 'manage' }" class="flex-1 py-2 px-4 rounded-t-lg text-sm">裝備管理</button>
                            <button @click="modals.warehouse.subTab = 'upgrade'" :class="{ 'bg-gray-700 text-white': modals.warehouse.subTab === 'upgrade' }" class="flex-1 py-2 px-4 rounded-t-lg text-sm">升級</button>
                        </div>
                        <div x-show="modals.warehouse.subTab === 'manage'">
                            <div class="flex items-center space-x-2 mb-4 border-b border-gray-600 pb-3">
                                <span class="font-bold text-sm text-gray-400">篩選類型:</span>
                                <button @click="modals.warehouse.activeFilter = 'all'" class="btn btn-xs" :class="{ 'btn-primary': modals.warehouse.activeFilter === 'all', 'btn-secondary': modals.warehouse.activeFilter !== 'all' }">全部</button>
                                <button @click="modals.warehouse.activeFilter = 'weapon'" class="btn btn-xs" :class="{ 'btn-primary': modals.warehouse.activeFilter === 'weapon', 'btn-secondary': modals.warehouse.activeFilter !== 'weapon' }">武器</button>
                                <button @click="modals.warehouse.activeFilter = 'shield'" class="btn btn-xs" :class="{ 'btn-primary': modals.warehouse.activeFilter === 'shield', 'btn-secondary': modals.warehouse.activeFilter !== 'shield' }">盾牌</button>
                                <button @click="modals.warehouse.activeFilter = 'armor'" class="btn btn-xs" :class="{ 'btn-primary': modals.warehouse.activeFilter === 'armor', 'btn-secondary': modals.warehouse.activeFilter !== 'armor' }">鎧甲</button>
                            </div>
                            <div>
                                <h3 class="text-xl font-bold mb-2">部落倉庫 (<span x-text="filteredWarehouseInventory.length"></span> / <span x-text="warehouseCapacity"></span>)</h3>
                                <div class="space-y-2 max-h-48 overflow-y-auto p-1 border border-gray-700 rounded mb-4">
                                    <template x-for="item in filteredWarehouseInventory" :key="item.id">
                                        <div class="p-3 border border-gray-600 rounded flex flex-col">
                                            <div class="w-full mb-2">
                                                <p :style="{ color: item.quality.color }" x-text="item.name"></p>
                                                <p class="text-xs text-gray-400" x-html="getItemStatsString(item)"></p>
                                            </div>
                                            <div class="w-full flex space-x-2">
                                                <button @click="moveToBackpack(item.id)" class="btn btn-sm btn-secondary flex-grow">移至背包</button>
                                                <button @click="equipItem(item.id, player)" class="btn btn-sm btn-success flex-grow">裝備</button>
                                                <button @click="decomposeItem(item.id)" class="btn btn-sm btn-danger flex-grow" :disabled="buildings.armory.level === 0" title="需要先建造兵工廠">分解</button>
                                                <button @click="openDiscardConfirm(item.id)" class="btn btn-sm btn-secondary flex-grow">丟棄</button>
                                            </div>
                                        </div>
                                    </template>
                                    <p x-show="filteredWarehouseInventory.length === 0" class="text-center text-gray-400">你的倉庫是空的，或篩選結果為空。</p>
                                </div>
                            </div>
                            <div>
                                <h3 class="text-xl font-bold mb-2">玩家背包 (<span x-text="filteredPlayerInventory.length"></span> / <span x-text="backpackCapacity"></span>)</h3>
                                <div class="space-y-2 max-h-48 overflow-y-auto p-1 border border-gray-700 rounded">
                                    <template x-for="item in filteredPlayerInventory" :key="item.id">
                                        <div class="p-3 border border-gray-600 rounded flex flex-col">
                                            <div class="w-full mb-2">
                                                <p :style="{ color: item.quality.color }" x-text="item.name"></p>
                                                <p class="text-xs text-gray-400" x-html="getItemStatsString(item)"></p>
                                            </div>
                                            <div class="w-full flex space-x-2">
                                                <button @click="moveToWarehouse(item.id)" class="btn btn-sm btn-secondary flex-grow">移至倉庫</button>
                                                <button @click="equipItem(item.id, player)" class="btn btn-sm btn-success flex-grow">裝備</button>
                                                <button @click="decomposeItem(item.id)" class="btn btn-sm btn-danger flex-grow" :disabled="buildings.armory.level === 0" title="需要先建造兵工廠">分解</button>
                                                <button @click="openDiscardConfirm(item.id)" class="btn btn-sm btn-secondary flex-grow">丟棄</button>
                                            </div>
                                        </div>
                                    </template>
                                    <p x-show="filteredPlayerInventory.length === 0" class="text-center text-gray-400">你的背包是空的，或篩選結果為空。</p>
                                </div>
                            </div>
                        </div>
                        <div x-show="modals.warehouse.subTab === 'upgrade'">
                            <h3 class="text-xl font-bold mb-2">升級倉庫 (等級 <span x-text="buildings.warehouse.level"></span>)</h3>
                            <p class="text-sm text-gray-400 mb-4">增加倉庫和背包的儲存上限。</p>
                            <p class="mb-4">當前容量: 倉庫 <span x-text="warehouseCapacity"></span> / 背包 <span x-text="backpackCapacity"></span></p>
                            <template x-if="buildings.warehouse.level < 4">
                                <div>
                                    <p class="text-sm">
                                        <span x-text="buildings.warehouse.level === 0 ? '建造花費:' : `升級至 ${buildings.warehouse.level + 1} 級花費:`"></span>
                                        <span x-text="getBuildingUpgradeCost('warehouse').wood"></span> 木材,
                                        <span x-text="getBuildingUpgradeCost('warehouse').stone"></span> 礦石
                                    </p>
                                    <button @click="upgradeBuilding('warehouse')" class="btn btn-primary mt-2" :disabled="!canAffordBuildingUpgrade('warehouse')">
                                        <span x-text="buildings.warehouse.level === 0 ? '建造' : '升級'"></span>
                                    </button>
                                </div>
                            </template>
                            <p x-show="buildings.warehouse.level >= 4" class="text-sm text-green-400 mt-2">倉庫已達到最大等級！</p>
                        </div>
                    </div>

                    <div x-show="modals.construction.activeTab === 'armory'">
                        <div class="flex border-b border-gray-600 mb-4">
                            <button @click="modals.armory.subTab = 'craft'" :class="{ 'bg-gray-700 text-white': modals.armory.subTab === 'craft' }" class="flex-1 py-2 px-4 rounded-t-lg text-sm">製作</button>
                            <button @click="modals.armory.subTab = 'upgrade'" :class="{ 'bg-gray-700 text-white': modals.armory.subTab === 'upgrade' }" class="flex-1 py-2 px-4 rounded-t-lg text-sm">升級</button>
                        </div>
                        <div x-show="modals.armory.subTab === 'craft'">
                            <h3 class="text-xl font-bold mb-2">製作裝備</h3>
                            <div class="space-y-4">
                                <div>
                                    <label>類型:</label>
                                    <select x-model="modals.armory.craftingType" class="bg-gray-700 border-2 border-gray-600 rounded px-3 py-2 w-full">
                                        <template x-for="type in craftableTypes" :key="type.baseName">
                                            <option :value="type.baseName" x-text="type.baseName"></option>
                                        </template>
                                    </select>
                                </div>
                                <div>
                                    <label>材質:</label>
                                    <select x-model="modals.armory.craftingMaterial" class="bg-gray-700 border-2 border-gray-600 rounded px-3 py-2 w-full">
                                        <template x-for="mat in availableMaterials" :key="mat.key">
                                            <option :value="mat.key" x-text="mat.name"></option>
                                        </template>
                                    </select>
                                </div>
                                <div x-show="modals.armory.craftingMaterial">
                                    <p>花費: <span x-text="getCraftingCost().amount"></span> <span x-text="getCraftingCost().type"></span></p>
                                </div>
                                <button @click="craftItem()" class="btn btn-primary w-full" :disabled="!canAffordCraft">製作</button>
                            </div>
                        </div>
                        <div x-show="modals.armory.subTab === 'upgrade'">
                            <h3 class="text-xl font-bold mb-2">升級兵工廠 (等級 <span x-text="buildings.armory.level"></span>)</h3>
                            <p class="text-sm text-gray-400 mb-4">解鎖可製作的材質等級，並提升裝備分解的資源返還率。</p>
                            <template x-if="buildings.armory.level < 4">
                                <div>
                                    <p class="text-sm">
                                        <span x-text="buildings.armory.level === 0 ? '建造花費:' : `升級至 ${buildings.armory.level + 1} 級花費:`"></span>
                                        <span x-text="getBuildingUpgradeCost('armory').wood"></span> 木材,
                                        <span x-text="getBuildingUpgradeCost('armory').stone"></span> 礦石
                                    </p>
                                    <p class="text-sm mt-1">下一級分解返還率: <span x-text="['20%', '30%', '40%', '50%'][buildings.armory.level]"></span></p>
                                    <button @click="upgradeBuilding('armory')" class="btn btn-primary mt-2" :disabled="!canAffordBuildingUpgrade('armory')">
                                        <span x-text="buildings.armory.level === 0 ? '建造' : '升級'"></span>
                                    </button>
                                </div>
                            </template>
                            <p x-show="buildings.armory.level >= 4" class="text-sm text-green-400 mt-2">兵工廠已達到最大等級！</p>
                        </div>
                    </div>

                    <div x-show="modals.construction.activeTab === 'maternity'">
                        <div class="flex border-b border-gray-600 mb-4">
                            <button @click="modals.maternity.subTab = 'manage'" :class="{ 'bg-gray-700 text-white': modals.maternity.subTab === 'manage' }" class="flex-1 py-2 px-4 rounded-t-lg text-sm">管理孕母</button>
                            <button @click="modals.maternity.subTab = 'upgrade'" :class="{ 'bg-gray-700 text-white': modals.maternity.subTab === 'upgrade', 'glow-pulse': tutorial.active && tutorial.step === 4 }" class="flex-1 py-2 px-4 rounded-t-lg text-sm">升級</button>
                        </div>
                        <div x-show="modals.maternity.subTab === 'manage'">
                            <h3 class="text-xl font-bold mb-2">管理孕母</h3>
                            <p class="mb-4">目前孕母: <span x-text="mothers.length"></span> / <span x-text="maternityCapacity"></span></p>
                            <div class="space-y-4">
                                <template x-for="mother in mothers" :key="mother.id">
                                    <div class="p-3 border border-gray-600 rounded">
                                        <div class="flex justify-between items-start">
                                            <div>
                                                <p class="text-lg font-bold text-amber-200"><span x-text="mother.name"></span> - <span x-text="mother.profession"></span></p>
                                                <p class="text-sm" :class="mother.isPregnant ? 'text-pink-400' : 'text-gray-400'" x-text="mother.isPregnant ? `懷孕中 (剩餘 ${mother.pregnancyTimer} 天)` : '產奶中'"></p>
                                            </div>
                                            <div class="text-right text-sm">
                                                <p>魅力: <span class="font-bold" x-text="mother.stats.charisma"></span></p>
                                            </div>
                                        </div>
                                        <div class="mt-2 pt-2 border-t border-gray-600 grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                                            <div><strong>力量:</strong> <span x-text="mother.stats.strength"></span></div>
                                            <div><strong>敏捷:</strong> <span x-text="mother.stats.agility"></span></div>
                                            <div><strong>智力:</strong> <span x-text="mother.stats.intelligence"></span></div>
                                            <div><strong>運氣:</strong> <span x-text="mother.stats.luck"></span></div>
                                        </div>
                                        <div class="text-right mt-2 space-x-2">
                                            <button @click="moveMotherToDungeon(mother.id)" class="btn btn-secondary btn-sm">移回地牢</button>
                                            <button @click="releaseCaptive(mother.id)" class="btn btn-danger btn-sm">拋棄</button>
                                        </div>
                                    </div>
                                </template>
                                <p x-show="mothers.length === 0" class="text-center text-gray-400">產房中沒有任何孕母。</p>
                            </div>
                        </div>
                        <div x-show="modals.maternity.subTab === 'upgrade'">
                            <h3 class="text-xl font-bold mb-2">升級產房 (等級 <span x-text="buildings.maternity.level"></span>)</h3>
                            <p class="text-sm text-gray-400 mb-4">增加孕母容量上限。</p>
                            <template x-if="buildings.maternity.level < 6">
                                <div>
                                    <p class="text-sm">
                                        <span x-text="buildings.maternity.level === 0 ? '建造花費:' : `升級至 ${buildings.maternity.level + 1} 級花費:`"></span>
                                        <span x-text="getBuildingUpgradeCost('maternity').wood"></span> 木材,
                                        <span x-text="getBuildingUpgradeCost('maternity').stone"></span> 礦石
                                    </p>
                                    <button @click="upgradeBuilding('maternity')" class="btn btn-primary mt-2" :disabled="!canAffordBuildingUpgrade('maternity')" :class="{'glow-pulse': tutorial.active && tutorial.step === 4}">
                                        <span x-text="buildings.maternity.level === 0 ? '建造' : '升級'"></span>
                                    </button>
                                </div>
                            </template>
                            <p x-show="buildings.maternity.level >= 6" class="text-sm text-green-400 mt-2">產房已達到最大等級！</p>
                        </div>
                    </div>

                    <div x-show="modals.construction.activeTab === 'trainingGround'">
                        <template x-if="buildings.trainingGround.level === 0">
                            <div>  <h3 class="text-xl font-bold mb-2">建造訓練場</h3>
                                <p class="text-sm text-gray-400 mb-4">建造一個設施來訓練你的哥布林夥伴，讓他們變得更強。</p>
                                <div>
                                    <p class="text-sm">
                                        <span>建造成本:</span>
                                        <span x-text="getBuildingUpgradeCost('trainingGround').food"></span> 食物,
                                        <span x-text="getBuildingUpgradeCost('trainingGround').wood"></span> 木材,
                                        <span x-text="getBuildingUpgradeCost('trainingGround').stone"></span> 礦石
                                    </p>
                                    <button @click="upgradeBuilding('trainingGround')" class="btn btn-primary mt-2" :disabled="!canAffordBuildingUpgrade('trainingGround')">
                                        <span>建造</span>
                                    </button>
                                </div>
                            </div>
                        </template>
                        <template x-if="buildings.trainingGround.level > 0">
                            <div>
                                <h3 class="text-xl font-bold mb-2">夥伴訓練</h3>
                                <p class="mb-4 text-sm text-gray-400">選擇一名夥伴進行一對一訓練，將消耗一天時間。訓練將參考您<span class="text-yellow-400">自身原始能力</span>，為夥伴增加 <span class="font-bold text-green-400" x-text="potentialTrainingPoints"></span> 點隨機屬性。每位夥伴一生只能接受一次訓練。</p>
                                <div class="space-y-4">
                                    <template x-for="p in partners" :key="p.id">
                                        <div class="p-3 border border-gray-600 rounded flex justify-between items-center">
                                            <div>
                                                <p class="text-lg font-bold text-amber-200" x-text="p.name"></p>
                                                <p class="text-xs text-gray-400">力:<span x-text="p.stats.strength"></span> 敏:<span x-text="p.stats.agility"></span> 智:<span x-text="p.stats.intelligence"></span> 運:<span x-text="p.stats.luck"></span></p>
                                            </div>
                                            <button @click="executeTraining(p.id)" class="btn btn-sm btn-primary" :disabled="p.hasBeenTrained">
                                                <span x-text="p.hasBeenTrained ? '已訓練' : '訓練'"></span>
                                            </button>
                                        </div>
                                    </template>
                                    <p x-show="partners.length === 0" class="text-center text-gray-400">你沒有任何夥伴可以訓練。</p>
                                </div>
                            </div>
                        </template>
                    </div>

                    <div x-show="modals.construction.activeTab === 'merchantCamp'">
                        <h3 class="text-xl font-bold mb-2">升級商人營地 (等級 <span x-text="buildings.merchantCamp.level"></span>)</h3>
                        <p class="text-sm text-gray-400 mb-4">提升旅行商人販售的商品數量，並增加其停留時間。</p>
                        <template x-if="buildings.merchantCamp.level < 4">
                            <div>
                                <p class="text-sm">
                                    <span x-text="buildings.merchantCamp.level === 0 ? '建造花費:' : `升級至 ${buildings.merchantCamp.level + 1} 級花費:`"></span>
                                    <span x-text="getBuildingUpgradeCost('merchantCamp').wood"></span> 木材,
                                    <span x-text="getBuildingUpgradeCost('merchantCamp').stone"></span> 礦石
                                </p>
                                <p class="text-sm mt-1">下一級商品數量: <span x-text="[2, 4, 6, 8, 10][buildings.merchantCamp.level]"></span> -> <span class="text-green-400" x-text="[4, 6, 8, 10][buildings.merchantCamp.level]"></span></p>
                                <p class="text-sm mt-1">下一級停留時間: <span x-text="1 + buildings.merchantCamp.level"></span> 天 -> <span class="text-green-400" x-text="2 + buildings.merchantCamp.level"></span> 天</p>
                                <button @click="upgradeBuilding('merchantCamp')" class="btn btn-primary mt-2" :disabled="!canAffordBuildingUpgrade('merchantCamp')">
                                    <span x-text="buildings.merchantCamp.level === 0 ? '建造' : '升級'"></span>
                                </button>
                            </div>
                        </template>
                        <p x-show="buildings.merchantCamp.level >= 4" class="text-sm text-green-400 mt-2">商人營地已達到最大等級！</p>
                    </div>

                    <div class="text-right mt-6">
                        <button @click="modals.construction.isOpen = false" class="btn btn-secondary">關閉</button>
                    </div>
                </div>
            </div>
        </div>
    </template>


    <!-- 偵查目標 Modal -->
    <div class="modal" x-show="modals.scoutInfo.isOpen" x-cloak>
        <template x-if="currentRaid && modals.scoutInfo.target">
            <div class="modal-content game-container relative p-6 rounded-lg">
                <h2 class="game-title font-medieval">偵查情報</h2>

                <div class="pt-10 max-h-[70vh] overflow-y-auto">
                    <template x-if="modals.scoutInfo.target.length > 0">
                        <div class="space-y-4">
                            <template x-for="unit in modals.scoutInfo.target" :key="unit.id">
                                <div class="p-3 border border-gray-700 rounded">
                                    <p class="text-lg font-bold text-amber-200"><span x-text="unit.name"></span> - <span x-text="unit.profession"></span></p>
                                    <div class="mt-2 pt-2 border-t border-gray-600 grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                                        <div><strong>力量:</strong> <span x-text="unit.stats.strength"></span></div>
                                        <div><strong>敏捷:</strong> <span x-text="unit.stats.agility"></span></div>
                                        <div><strong>智力:</strong> <span x-text="unit.stats.intelligence"></span></div>
                                        <div><strong>運氣:</strong> <span x-text="unit.stats.luck"></span></div>
                                        <div class="col-span-2" x-show="unit.stats.charisma > 0"><strong>魅力:</strong> <span x-text="unit.stats.charisma"></span></div>
                                    </div>
                                    <div class="mt-2 pt-2 border-t border-gray-600 text-sm">
                                        <p class="font-bold text-amber-200">裝備:</p>
                                        <div class="space-y-1 pl-2">
                                            <template x-for="slot in Object.keys(unit.equipment || {})" :key="slot">
                                                <div>
                                                    <span class="capitalize" x-text="EQUIPMENT_SLOTS[slot] || slot"></span>:
                                                    <template x-if="unit.equipment[slot]">
                                                        <span :style="{ color: unit.equipment[slot].quality.color }" x-text="unit.equipment[slot].name"></span>
                                                    </template>
                                                    <template x-if="!unit.equipment[slot]">
                                                        <span class="text-gray-500">-- 無 --</span>
                                                    </template>
                                                </div>
                                            </template>
                                        </div>
                                    </div>
                                    <template x-if="unit.visual">
                                        <div class="mt-2 pt-2 border-t border-gray-600 grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                                            <div><strong>身高:</strong> <span x-text="unit.visual.height"></span> cm</div>
                                            <div><strong>年紀:</strong> <span x-text="unit.visual.age"></span></div>
                                            <div><strong>髮色:</strong> <span x-text="unit.visual.hairColor"></span></div>
                                            <div><strong>髮型:</strong> <span x-text="unit.visual.hairStyle"></span></div>
                                            <div><strong>胸圍:</strong> <span x-text="unit.visual.bust"></span></div>
                                            <div class="col-span-2"><strong>個性:</strong> <span x-text="unit.visual.personality"></span></div>
                                            <div class="col-span-2"><strong>服裝:</strong> <span x-text="unit.visual.clothing"></span></div>
                                        </div>
                                    </template>
                                </div>
                            </template>
                        </div>
                    </template>

                    <template x-if="modals.scoutInfo.target.length === 0">
                        <p class="text-center text-lg py-8" x-text="modals.scoutInfo.emptyBuildingMessage"></p>
                    </template>
                </div>

                <div class="text-right mt-6 pt-4 border-t border-gray-600 space-x-2">
                    <template x-if="modals.scoutInfo.target && modals.scoutInfo.target.length > 0">
                        <button @click="startCombatFromScout(modals.scoutInfo.target)" class="btn btn-danger">攻擊</button>
                        <template x-if="(Array.isArray(modals.scoutInfo.target) && modals.scoutInfo.target.some(e => e.visual)) || (!Array.isArray(modals.scoutInfo.target) && modals.scoutInfo.target.visual)">
                            <button @click="executeSneakKidnapFromModal()" class="btn btn-secondary">潛行擄走</button>
                        </template>
                    </template>
                    <template x-if="modals.scoutInfo.target && modals.scoutInfo.target.length === 0 && selectedTarget && !Array.isArray(selectedTarget) && !selectedTarget.looted">
                        <button @click="lootBuildingFromModal()" class="btn btn-primary">搜刮建築</button>
                    </template>
                    <button @click.stop="closeScoutModalAndClearTarget()" class="btn btn-secondary">關閉</button>
                </div>
            </div>
        </template>
    </div>

    <!-- 掠奪俘虜管理 Modal -->
    <div class="modal" x-show="modals.raidCaptives.isOpen" x-cloak>
        <div class="modal-content game-container relative p-6 rounded-lg">
            <h2 class="game-title font-medieval">管理本次俘虜</h2>
            <div class="pt-10 max-h-[80vh] overflow-y-auto">

                <p class="mb-4 text-center">
                    <span>攜帶俘虜: </span>
                    <span class="font-bold" x-text="currentRaid?.carriedCaptives.length ?? 0"></span> /
                    <span class="font-bold" x-text="carryCapacity"></span>
                </p>

                <div class="space-y-4">
                    <template x-for="captive in currentRaid?.carriedCaptives || []" :key="captive.id">
                        <div class="p-3 border border-gray-600 rounded">
                            <div class="flex justify-between items-start">
                                <div>
                                    <p class="text-lg font-bold text-amber-200">
                                        <span x-text="captive.name"></span> - <span x-text="captive.profession"></span>
                                    </p>
                                </div>
                                <div class="text-right text-sm">
                                    <p>魅力: <span class="font-bold" x-text="captive.stats.charisma"></span></p>
                                </div>
                            </div>
                            <div class="text-right mt-2">
                                <button @click="releaseCarriedCaptive(captive.id)" class="btn btn-danger btn-sm">釋放</button>
                            </div>
                        </div>
                    </template>
                    <p x-show="!currentRaid || currentRaid.carriedCaptives.length === 0" class="text-center text-gray-400">你尚未捕獲任何俘虜。</p>
                </div>
                <div class="text-right mt-6">
                    <button @click="modals.raidCaptives.isOpen = false" class="btn btn-secondary">關閉</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 統一俘虜管理 Modal -->
    <div class="modal" x-show="modals.captiveManagement.isOpen" x-cloak>
        <div class="modal-content game-container relative p-6 rounded-lg">
            <h2 class="game-title font-medieval" x-text="modals.captiveManagement.title"></h2>
            <div class="pt-10 max-h-[80vh] overflow-y-auto">
                <p class="mb-4">請選擇要保留的俘虜。上限: <span x-text="modals.captiveManagement.selectedIds.length"></span> /
                    <span x-text="modals.captiveManagement.limit"></span>
                </p>
                <div class="space-y-4">
                    <template x-for="captive in modals.captiveManagement.list" :key="captive.id">
                        <div class="p-3 border border-gray-600 rounded">
                            <div class="flex justify-between items-start">
                                <div>
                                    <p class="text-lg font-bold text-amber-200"><span x-text="captive.name"></span> -
                                        <span x-text="captive.profession"></span>
                                    </p>
                                    <p class="text-sm" :class="captive.isPregnant ? 'text-pink-400' : 'text-green-400'"
                                        x-text="captive.isPregnant ? `懷孕中 (剩餘 ${captive.pregnancyTimer} 天)` : '可繁衍'">
                                    </p>
                                </div>
                                <input type="checkbox" :value="captive.id" x-model="modals.captiveManagement.selectedIds"
                                           :disabled="!modals.captiveManagement.selectedIds.includes(captive.id) && modals.captiveManagement.selectedIds.length >= modals.captiveManagement.limit"
                                           class="form-checkbox h-5 w-5 bg-gray-800 border-gray-500 text-green-500 focus:ring-green-500">
                            </div>
                            <div class="mt-2 pt-2 border-t border-gray-600 grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                                <div><strong>力量:</strong> <span x-text="captive.stats.strength"></span></div>
                                <div><strong>敏捷:</strong> <span x-text="captive.stats.agility"></span></div>
                                <div><strong>智力:</strong> <span x-text="captive.stats.intelligence"></span></div>
                                <div><strong>運氣:</strong> <span x-text="captive.stats.luck"></span></div>
                                <div class="col-span-2"><strong>魅力:</strong>
                                    <span class="font-bold" x-text="captive.stats.charisma"></span>
                                </div>
                            </div>
                            <template x-if="captive.visual">
                                <div class="mt-2 pt-2 border-t border-gray-600 grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                                <div><strong>身高:</strong> <span x-text="captive.visual.height"></span> cm</div>
                                <div><strong>年紀:</strong> <span x-text="captive.visual.age"></span></div>
                                <div><strong>髮型:</strong> <span x-text="captive.visual.hair"></span></div>
                                    <div><strong>胸圍:</strong> <span x-text="captive.visual.bust"></span></div>
                                    <div class="col-span-2"><strong>個性:</strong>
                                        <span x-text="captive.visual.personality"></span>
                                    </div>
                                    <div class="col-span-2"><strong>服裝:</strong>
                                        <span x-text="captive.visual.clothing"></span>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>
                <div class="text-right mt-6">
                    <button @click="confirmCaptiveSelection()" class="btn btn-primary">
                        確認選擇 (<span x-text="modals.captiveManagement.selectedIds.length"></span>)
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" x-show="modals.partnerManagement.isOpen" x-cloak>
        <div class="modal-content game-container relative p-6 rounded-lg">
            <h2 class="game-title font-medieval">寢室空間不足</h2>
            <div class="pt-10 max-h-[80vh] overflow-y-auto">
                <p class="mb-4">新生兒已誕生，但寢室已滿！您必須選擇要保留的夥伴。上限: <span x-text="modals.partnerManagement.selectedIds.length"></span> /
                    <span x-text="modals.partnerManagement.limit"></span>
                </p>
                <div class="space-y-4">
                    <template x-for="partner in modals.partnerManagement.list" :key="partner.id">
                        <div class="p-3 border rounded" :class="partner.id === modals.partnerManagement.newbornId ? 'border-yellow-400 bg-gray-700/50' : 'border-gray-600'">
                            <div class="flex justify-between items-start">
                                <div>
                                    <p class="text-lg font-bold text-amber-200" x-text="partner.name"></p>
                                    <p class="text-sm text-yellow-400" x-show="partner.id === modals.partnerManagement.newbornId">（新生兒）</p>
                                </div>
                                <input type="checkbox" :value="partner.id" x-model="modals.partnerManagement.selectedIds"
                                           :disabled="!modals.partnerManagement.selectedIds.includes(partner.id) && modals.partnerManagement.selectedIds.length >= modals.partnerManagement.limit"
                                           class="form-checkbox h-5 w-5 bg-gray-800 border-gray-500 text-green-500 focus:ring-green-500">
                            </div>
                            <div class="mt-2 pt-2 border-t border-gray-700 grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                                <div><strong>力量:</strong> <span x-text="partner.stats.strength"></span></div>
                                <div><strong>敏捷:</strong> <span x-text="partner.stats.agility"></span></div>
                                <div><strong>智力:</strong> <span x-text="partner.stats.intelligence"></span></div>
                                <div><strong>運氣:</strong> <span x-text="partner.stats.luck"></span></div>
                            </div>
                        </div>
                    </template>
                </div>
                <div class="text-right mt-6">
                    <button @click="confirmPartnerSelectionDecision()" class="btn btn-primary">
                        確認選擇 (<span x-text="modals.partnerManagement.selectedIds.length"></span>)
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- 繁衍敘事 Modal -->
    <div class="modal" x-show="modals.narrative.isOpen" x-cloak>
        <div class="modal-content game-container relative p-6 rounded-lg flex flex-col">
            <h2 class="game-title font-medieval" x-text="modals.narrative.title"></h2>
            <div class="pt-10 flex-grow flex flex-col max-h-[80vh]">
                <div class="flex-grow overflow-y-auto p-4 bg-black bg-opacity-20 rounded mb-4 flex items-center justify-center">

                    <div x-show="modals.narrative.type !== 'tutorial'" class="w-full">
                        <div x-show="modals.narrative.isAwaitingConfirmation" class="text-center">
                            <p class="mb-4" x-text="modals.narrative.content"></p>
                            <button x-show="modals.narrative.type === 'birth'" @click="generateBirthNarrative()" class="btn btn-primary">使用 AI 生成誕生故事</button>
                            <button x-show="modals.narrative.type === 'breeding'" @click="confirmAndStartBreedingNarrative()" class="btn btn-primary">使用 AI 生成繁衍敘事</button>
                        </div>

                        <div x-show="modals.narrative.isLoading" class="loader mx-auto"></div>

                        <p x-show="!modals.narrative.isLoading && !modals.narrative.isAwaitingConfirmation" x-html="modals.narrative.content"
                            class="text-lg leading-relaxed whitespace-pre-wrap w-full"></p>
                    </div>

                    <div x-show="modals.narrative.type === 'tutorial'" class="flex items-start gap-4 w-full">
                        <img src="https://i.ibb.co/k2QBgcHP/century-avatar.png" alt="世紀的頭像" class="w-24 h-24 rounded-full border-2 border-pink-400 flex-shrink-0">
                        <div class="flex-grow text-left" x-html="modals.narrative.content">
                            </div>
                    </div>
                </div>

                <div class="text-center mt-4">
                    <button x-show="modals.narrative.type === 'tutorial'" @click="closeNarrativeModal()" class="btn btn-primary">了解</button>
                </div>
                
                </div>
        </div>
    </div>

    <!-- 自訂提示框 -->
    <div x-show="modals.customAlert.isOpen" class="modal" @click.self="confirmCustomAlert()">
        <div class="modal-content game-container relative p-6 rounded-lg max-w-sm pt-10">
            <p class="text-center" x-text="modals.customAlert.message"></p>
            <div class="text-center mt-4">
                <button @click="confirmCustomAlert()" class="btn btn-primary">確定</button>
            </div>
        </div>
    </div>

    <!-- 丟棄確認 Modal -->
    <div x-show="modals.discardConfirm.isOpen" class="modal" >
        <div class="modal-content game-container relative p-6 rounded-lg max-w-sm pt-10">
            <p class="text-center">確定要丟棄 <span class="font-bold" x-text="modals.discardConfirm.itemName"></span> 嗎？<br>此操作無法復原。
            </p>
            <div class="text-center mt-6 flex justify-center space-x-4">
                <button @click="executeDiscardItem()" class="btn btn-danger">確定</button>
                <button @click="modals.discardConfirm.isOpen = false" class="btn btn-secondary">取消</button>
            </div>
        </div>
    </div>

    <!-- Raid Status Modal -->
     <template x-if="currentlyEditingPartner">
        <div class="modal" x-show="modals.partnerEquipment.isOpen" x-cloak >
            <div class="modal-content !max-w-4xl game-container relative p-6 rounded-lg">
                <h2 class="game-title font-medieval" x-text="`管理裝備 - ${currentlyEditingPartner.name}`"></h2>
                <div class="pt-10 max-h-[80vh] overflow-y-auto">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div class="md:col-span-1 space-y-4">
                            <h3 class="text-xl font-bold text-amber-200">已裝備</h3>
                            <template x-for="slot in Object.keys(currentlyEditingPartner.equipment)" :key="slot">
                                <div class="p-2 border border-gray-700 rounded">
                                    <p class="font-bold capitalize" x-text="EQUIPMENT_SLOTS[slot] || slot"></p>
                                    <template x-if="currentlyEditingPartner.equipment[slot]">
                                        <div>
                                            <p :style="{ color: currentlyEditingPartner.equipment[slot].quality.color }" x-text="currentlyEditingPartner.equipment[slot].name"></p>
                                            <p class="text-xs text-gray-400" x-html="getItemStatsString(currentlyEditingPartner.equipment[slot])"></p>
                                            <button @click="unequipItem(slot, currentlyEditingPartner)" class="btn btn-sm btn-secondary mt-1">卸下</button>
                                        </div>
                                    </template>
                                    <template x-if="!currentlyEditingPartner.equipment[slot]">
                                        <p class="text-gray-500">-- 空 --</p>
                                    </template>
                                </div>
                            </template>
                        </div>

                        <div class="md:col-span-2 space-y-4">
                            <div class="flex items-center space-x-2 mb-4 border-b border-gray-600 pb-3">
                                <span class="font-bold text-sm text-gray-400">篩選類型:</span>
                                <button @click="modals.partnerEquipment.activeFilter = 'all'" class="btn btn-xs" :class="{ 'btn-primary': modals.partnerEquipment.activeFilter === 'all', 'btn-secondary': modals.partnerEquipment.activeFilter !== 'all' }">全部</button>
                                <button @click="modals.partnerEquipment.activeFilter = 'weapon'" class="btn btn-xs" :class="{ 'btn-primary': modals.partnerEquipment.activeFilter === 'weapon', 'btn-secondary': modals.partnerEquipment.activeFilter !== 'weapon' }">武器</button>
                                <button @click="modals.partnerEquipment.activeFilter = 'shield'" class="btn btn-xs" :class="{ 'btn-primary': modals.partnerEquipment.activeFilter === 'shield', 'btn-secondary': modals.partnerEquipment.activeFilter !== 'shield' }">盾牌</button>
                                <button @click="modals.partnerEquipment.activeFilter = 'armor'" class="btn btn-xs" :class="{ 'btn-primary': modals.partnerEquipment.activeFilter === 'armor', 'btn-secondary': modals.partnerEquipment.activeFilter !== 'armor' }">鎧甲</button>
                            </div>
                            <div>
                                <h3 class="text-xl font-bold mb-2 text-amber-200">部落倉庫 (<span x-text="filteredPartnerWarehouse.length"></span> / <span x-text="warehouseCapacity"></span>)</h3>
                                    <div class="space-y-2 max-h-60 overflow-y-auto pr-2 border border-gray-700 rounded p-2">
                                        <template x-for="item in filteredPartnerWarehouse" :key="item.id">
                                        <div class="p-3 border border-gray-600 rounded flex justify-between items-center">
                                            <div>
                                                <p :style="{ color: item.quality.color }" x-text="item.name"></p>
                                                <p class="text-xs text-gray-400" x-html="getItemStatsString(item)"></p>
                                            </div>
                                            <button @click="equipItem(item.id, currentlyEditingPartner)" class="btn btn-sm btn-success">裝備</button>
                                        </div>
                                    </template>
                                    <p x-show="filteredPartnerWarehouse.length === 0" class="text-center text-gray-400">倉庫是空的，或篩選結果為空。</p>
                                </div>
                            </div>
                            
                            <div>
                                <h3 class="text-xl font-bold mb-2 text-amber-200">玩家背包 (<span x-text="filteredPartnerBackpack.length"></span> / <span x-text="backpackCapacity"></span>)</h3>
                                <div class="space-y-2 max-h-60 overflow-y-auto pr-2 border border-gray-700 rounded p-2">
                                    <template x-for="item in filteredPartnerBackpack" :key="item.id">
                                        <div class="p-3 border border-gray-600 rounded flex justify-between items-center">
                                            <div>
                                                <p :style="{ color: item.quality.color }" x-text="item.name"></p>
                                                <p class="text-xs text-gray-400" x-html="getItemStatsString(item)"></p>
                                            </div>
                                            <button @click="equipItem(item.id, currentlyEditingPartner)" class="btn btn-sm btn-success">裝備</button>
                                        </div>
                                    </template>
                                    <p x-show="filteredPartnerBackpack.length === 0" class="text-center text-gray-400">你的背包是空的，或篩選結果為空。</p>
                                </div>
                            </div>
                            </div>
                    </div>
                     <div class="text-right mt-6">
                        <button @click="modals.partnerEquipment.isOpen = false" class="btn btn-secondary">關閉</button>
                    </div>
                </div>
            </div>
        </div>
    </template>
    <template x-if="player">
        <div class="modal" x-show="modals.raidStatus.isOpen" x-cloak >
            <div class="modal-content game-container relative p-6 rounded-lg">
                <h2 class="game-title font-medieval">玩家狀態</h2>
                <div class="pt-10 max-h-[80vh] overflow-y-auto">
                    <div class="flex border-b border-gray-600 mb-4">
                        <button @click="modals.raidStatus.activeTab = 'status'" :class="{ 'bg-gray-700 text-white': modals.raidStatus.activeTab === 'status' }" class="flex-1 py-2 px-4 rounded-t-lg">狀態</button>
                        <button @click="modals.raidStatus.activeTab = 'partners'" :class="{ 'bg-gray-700 text-white': modals.raidStatus.activeTab === 'partners' }" class="flex-1 py-2 px-4 rounded-t-lg">夥伴</button> <button @click="modals.raidStatus.activeTab = 'equipment'" :class="{ 'bg-gray-700 text-white': modals.raidStatus.activeTab === 'equipment' }" class="flex-1 py-2 px-4 rounded-t-lg">裝備</button>
                        <button @click="modals.raidStatus.activeTab = 'inventory'" :class="{ 'bg-gray-700 text-white': modals.raidStatus.activeTab === 'inventory' }" class="flex-1 py-2 px-4 rounded-t-lg">背包</button>
                    </div>
                    <!-- Status Tab -->
                    <div x-show="modals.raidStatus.activeTab === 'status'">
                        <p><strong>名稱:</strong> <span class="font-accent" x-text="player.name"></span></p>
                        <p class="mt-2 font-bold text-amber-200" :class="{'text-red-400': isStarving}">總能力值
                        <span x-show="isStarving">(飢餓中 -25%)</span>:
                    </p>
                    <ul class="list-disc list-inside space-y-1 text-sm">
                            <template x-for="stat in ['strength', 'agility', 'intelligence', 'luck']" :key="stat">
                                <li>
                                    <div>
                                        <span class="capitalize" x-text="STAT_NAMES[stat]"></span>:
                                        <span x-text="player.stats[stat]"></span>
                                        <span class="text-green-400" x-show="player.getPartyBonus(stat) > 0" x-text="` (+${player.getPartyBonus(stat)})`"></span>
                                        <span class="text-purple-400" x-show="player.getAffixEffect(stat).bonus > 0" x-text="` (+${player.getAffixEffect(stat).bonus})`"></span>
                                        <span class="text-blue-400" x-show="player.getEffectiveEquipmentBonus(stat) > 0" x-text="` (+${player.getEffectiveEquipmentBonus(stat)})`"></span>
                                        <span class="text-red-400" x-show="isStarving" x-text="` -> ${player.getTotalStat(stat, isStarving)}`"></span>
                                    </div>
                                </li>
                            </template>
                        </ul>
                        <div class="mt-2">
                            <p><strong>生命值:</strong>
                                <span x-text="player.currentHp"></span> / <span x-text="player.calculateMaxHp(isStarving)"></span>
                                <span class="text-green-400" x-show="player.getPartyHpBonus(isStarving) > 0" x-text="` (+${player.getPartyHpBonus(isStarving)})`"></span>
                                <span class="text-blue-400" x-show="player.getEquipmentHpBonus() > 0" x-text="` (+${player.getEquipmentHpBonus()})`"></span>
                            </p>
                        </div>
                    </div>
                    <!-- partners Tab -->
                    <div x-show="modals.raidStatus.activeTab === 'partners'" class="space-y-4">
                        <template x-for="partner in player.party" :key="partner.id">
                            <div class="p-3 border border-gray-700 rounded">
                                <p class="font-bold text-amber-200" x-text="partner.name"></p>
                                <p><strong>生命值:</strong> <span x-text="partner.currentHp"></span> / <span x-text="partner.calculateMaxHp(isStarving)"></span></p>
                                <div class="mt-2 pt-2 border-t border-gray-600 grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                                    <template x-for="stat in ['strength', 'agility', 'intelligence', 'luck']" :key="stat">
                                        <div>
                                            <span class="capitalize" x-text="STAT_NAMES[stat]"></span>:
                                            <span x-text="partner.getTotalStat(stat, isStarving)"></span>
                                        </div>
                                    </template>
                                </div>
                                <div class="mt-2 pt-2 border-t border-gray-600 space-y-1 text-sm">
                                    <p class="font-bold text-amber-200">裝備:</p>
                                    <template x-for="slot in Object.keys(partner.equipment)" :key="slot">
                                        <div>
                                            <span class="capitalize" x-text="EQUIPMENT_SLOTS[slot] || slot"></span>:
                                            <span x-show="partner.equipment[slot]" :style="{ color: partner.equipment[slot]?.quality.color }" x-text="partner.equipment[slot]?.name"></span>
                                            <span x-show="!partner.equipment[slot]" class="text-gray-500">-- 無 --</span>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </template>
                        <p x-show="!player.party || player.party.length === 0" class="text-center text-gray-400">你沒有帶任何夥伴同行。</p>
                    </div>    
                    <!-- equipment Tab -->    
                    <div x-show="modals.raidStatus.activeTab === 'equipment'">
                            <div class="grid grid-cols-2 gap-4">
                                <template x-for="slot in Object.keys(player.equipment)" :key="slot">
                                    <div class="p-2 border border-gray-700 rounded">
                                        <p class="font-bold capitalize" x-text="EQUIPMENT_SLOTS[slot] || slot"></p>
                                        <template x-if="player.equipment[slot]">
                                            <div>
                                                <p :style="{ color: player.equipment[slot].quality.color }"
                                                    x-text="player.equipment[slot].name"></p>
                                                <p class="text-xs text-gray-400"
                                                    x-html="getItemStatsString(player.equipment[slot])"></p>
                                                <button @click="unequipItem(slot, player)" class="btn btn-sm btn-secondary mt-1">卸下</button>
                                            </div>
                                        </template>
                                        <template x-if="!player.equipment[slot]">
                                            <p class="text-gray-500">-- 空 --</p>
                                        </template>
                                    </div>
                                </template>
                            </div>
                        </div>
                    <!-- Inventory Tab -->
                    <div x-show="modals.raidStatus.activeTab === 'inventory'">
                        <div class="space-y-2">
                            <template x-for="item in player.inventory" :key="item.id">
                                <div class="p-3 border border-gray-600 rounded flex justify-between items-center">
                                    <div>
                                        <p :style="{ color: item.quality.color }" x-text="item.name"></p>
                                        <p class="text-xs text-gray-400" x-html="getItemStatsString(item)"></p>
                                    </div>
                                    <div class="space-x-2">
                                        <button @click="equipItem(item.id, player)" class="btn btn-sm btn-success">裝備</button>
                                        <button @click="decomposeItem(item.id)" class="btn btn-sm btn-danger" :disabled="buildings.armory.level === 0" title="需要先建造兵工廠">分解</button>
                                        <button @click="openDiscardConfirm(item.id)" class="btn btn-sm btn-secondary">丟棄</button>
                                    </div>
                                </div>
                            </template>
                            <p x-show="player.inventory.length === 0" class="text-center text-gray-400">你的背包是空的。</p>
                        </div>
                    </div>
                    <div class="text-right mt-6">
                        <button @click="modals.raidStatus.isOpen = false" class="btn btn-secondary">關閉</button>
                    </div>
                </div>
            </div>
        </div>
    </template>

    </template> <div class="modal" x-show="modals.merchant.isOpen" x-cloak >
    <div class="modal-content !max-w-4xl game-container relative p-6 rounded-lg">
        <h2 class="game-title font-medieval">旅行商人：世紀</h2>
        <div class="pt-10 max-h-[80vh] overflow-y-auto">
            <div class="flex items-start p-4 mb-6 bg-black bg-opacity-20 rounded-lg border border-pink-500/30">
                <img src="https://i.ibb.co/k2QBgcHP/century-avatar.png" alt="世紀的頭像" class="w-24 h-24 rounded-full border-2 border-pink-400 mr-4 flex-shrink-0">
                <div class="flex-grow">
                    <h3 class="text-xl font-bold text-pink-300">旅行商人：世紀</h3>
                    <p class="mt-2 text-pink-200 italic" x-text="merchant.dialogue"></p>
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <h3 class="text-xl font-bold mb-2 text-amber-200">商品列表 (剩餘 <span x-text="merchant.goods.length"></span> 件)</h3>
                    <div class="space-y-2 h-96 overflow-y-auto pr-2">
                        <template x-for="item in merchant.goods" :key="item.id">
                            <label class="p-3 border rounded flex items-center justify-between cursor-pointer"
                                :class="merchant.selectedItemIds.includes(item.id) ? 'border-yellow-400 bg-gray-700' : 'border-gray-600 hover:bg-gray-600'">
                                <div>
                                    <p :style="{ color: item.quality.color }" x-text="item.name"></p>
                                    <p class="text-xs text-gray-400" x-html="getItemStatsString(item)"></p>
                                    <p class="text-sm font-bold text-yellow-400 mt-1">價值: <span x-text="calculateEquipmentValue(item)"></span></p>
                                </div>
                                <input type="checkbox" :value="item.id" x-model="merchant.selectedItemIds"
                                    class="form-checkbox h-5 w-5 bg-gray-800 border-gray-500 text-yellow-500 focus:ring-yellow-500">
                            </label>
                        </template>
                    </div>
                </div>

                <div>
                    <h3 class="text-xl font-bold mb-2 text-amber-200">你的貨幣 (俘虜)</h3>
                     <div class="space-y-2 h-96 overflow-y-auto pr-2">
                        <template x-for="captive in dungeonCaptives" :key="captive.id">
                            <label class="p-3 border rounded flex items-center justify-between cursor-pointer"
                                   :class="merchant.selectedCaptiveIds.includes(captive.id) ? 'border-green-400 bg-gray-700' : 'border-gray-600 hover:bg-gray-600'">
                                <div>
                                    <p x-text="captive.name"></p>
                                    <p class="text-xs text-gray-400">魅力: <span x-text="captive.stats.charisma"></span></p>
                                    <p class="text-sm font-bold text-green-400 mt-1">價值: <span x-text="calculateCaptiveValue(captive)"></span></p>
                                </div>
                                <input type="checkbox" :value="captive.id" x-model="merchant.selectedCaptiveIds"
                                       class="form-checkbox h-5 w-5 bg-gray-800 border-gray-500 text-green-500 focus:ring-green-500">
                            </label>
                        </template>
                         <p x-show="dungeonCaptives.length === 0" class="text-center text-gray-400">你沒有任何俘虜可以交易。</p>
                    </div>
                </div>
            </div>

            <div class="mt-6 pt-4 border-t border-gray-600 flex justify-between items-center">
                <div>
                    <p>商品價值: <span class="font-bold text-yellow-400" x-text="selectedItemsValue"></span></p>
                    <p>俘虜總價值: <span class="font-bold" :class="selectedCaptivesValue >= selectedItemsValue ? 'text-green-400' : 'text-red-400'" x-text="selectedCaptivesValue"></span></p>
                </div>
                <button @click="executeTrade()" class="btn btn-primary" :disabled="!canExecuteTrade">確認交易</button>
            </div>

            <div class="text-right mt-6">
                <button @click="modals.merchant.isOpen = false" class="btn btn-secondary">關閉</button>
            </div>
            </div>
    </div>
</div>
</template> 

<!-- 王座之間畫面 (2D場景版) -->
    <template x-if="screen === 'throne_room'">
        <div id="throne-room-screen-scene" x-cloak>
            <div class="w-full max-w-2xl game-container relative p-6 rounded-lg pt-10">
                <h1 class="game-title font-medieval">王座之間</h1>
                <div class="text-center mb-4">
                    <p class="text-lg text-amber-200">公主與她的守護騎士們擋在了你的面前。</p>
                </div>

                <!-- 場景容器 -->
                <div class="scene-container" x-init="
                    const scene = $el;
                    for (let i = 0; i < 30; i++) {
                        const particle = document.createElement('div');
                        particle.className = 'dust-particle';
                        const size = Math.random() * 3 + 1;
                        particle.style.width = `${size}px`;
                        particle.style.height = `${size}px`;
                        particle.style.top = `${Math.random() * 100}%`;
                        particle.style.left = `${Math.random() * 100}%`;
                        particle.style.setProperty('--tx', `${(Math.random() - 0.5) * 200}px`);
                        particle.style.setProperty('--ty', `${(Math.random() - 0.5) * 200}px`);
                        particle.style.animationDelay = `${Math.random() * 20}s`;
                        particle.style.animationDuration = `${Math.random() * 10 + 15}s`;
                        scene.appendChild(particle);
                    }
                ">
                    <!-- 周邊石柱 -->
                    <div class="pillar" style="top: 15%; left: 15%;"></div>
                    <div class="pillar" style="top: 15%; right: 15%;"></div>
                    <div class="pillar" style="bottom: 15%; left: 15%;"></div>
                    <div class="pillar" style="bottom: 15%; right: 15%;"></div>
                    <div class="pillar" style="top: 50%; left: 5%; transform: translateY(-50%);"></div>
                    <div class="pillar" style="top: 50%; right: 5%; transform: translateY(-50%);"></div>

                    <!-- 圓形場地 -->
                    <div class="arena-floor">
                        
                        <!-- 王座 -->
                        <div class="throne" style="top: 10%; left: 50%;"></div>

                        <!-- 動態生成公主 (黃點) -->
                        <template x-for="(unit, index) in throneRoomUnits.filter(u => u.profession === '公主')" :key="unit.id">
                            <div @click="scoutThroneUnit(unit)" class="unit princess" :style="`top: 20%; left: ${45 + (index * 10)}%;`"></div>
                        </template>

                        <!-- 動態生成騎士 (橘點) -->
                        <template x-for="(unit, index) in throneRoomUnits.filter(u => u.profession !== '公主')" :key="unit.id">
                            <div @click="scoutThroneUnit(unit)" class="unit knight" :style="`top: ${knightPositions[index].top}; left: ${knightPositions[index].left};`"></div>
                        </template>

                        <!-- 玩家 (綠點) -->
                        <div class="unit player" style="top: 90%; left: 50%;"></div>
                    </div>
                </div>

                <div class="mt-6 text-center">
                    <button @click="screen = 'raid'" class="btn btn-danger">撤退回王城</button>
                </div>
            </div>
        </div>
    </template>
    
    <div class="modal" x-show="modals.throneScout.isOpen" x-cloak>
        <template x-if="modals.throneScout.unit">
            <div class="modal-content game-container relative p-6 rounded-lg">
                <h2 class="game-title font-medieval" x-text="`偵查情報 - ${modals.throneScout.unit.name}`"></h2>
    
                <div class="pt-10 max-h-[70vh] overflow-y-auto">
                    <p class="italic text-center text-pink-300 mb-4" x-text="getThroneUnitDialogue(modals.throneScout.unit)"></p>
                    
                    <div class="p-3 border border-gray-700 rounded">
                        <p class="text-lg font-bold text-amber-200">
                            <span x-text="modals.throneScout.unit.name"></span> - <span x-text="modals.throneScout.unit.profession"></span>
                        </p>
                        <div class="mt-2 pt-2 border-t border-gray-600 grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                            <div><strong>力量:</strong> <span x-text="modals.throneScout.unit.stats.strength"></span></div>
                            <div><strong>敏捷:</strong> <span x-text="modals.throneScout.unit.stats.agility"></span></div>
                            <div><strong>智力:</strong> <span x-text="modals.throneScout.unit.stats.intelligence"></span></div>
                            <div><strong>運氣:</strong> <span x-text="modals.throneScout.unit.stats.luck"></span></div>
                            <div class="col-span-2" x-show="modals.throneScout.unit.stats.charisma > 0">
                                <strong>魅力:</strong> <span class="font-bold text-lg text-pink-400" x-text="modals.throneScout.unit.stats.charisma"></span>
                            </div>
                        </div>
                        <div class="mt-2 pt-2 border-t border-gray-600 text-sm">
                            <p class="font-bold text-amber-200">裝備:</p>
                            <div class="space-y-1 pl-2">
                                <template x-for="slot in Object.keys(modals.throneScout.unit.equipment || {})" :key="slot">
                                    <div>
                                        <span class="capitalize" x-text="EQUIPMENT_SLOTS[slot] || slot"></span>:
                                        <template x-if="modals.throneScout.unit.equipment[slot]">
                                            <span :style="{ color: modals.throneScout.unit.equipment[slot].quality.color }" x-text="modals.throneScout.unit.equipment[slot].name"></span>
                                        </template>
                                        <template x-if="!modals.throneScout.unit.equipment[slot]">
                                            <span class="text-gray-500">-- 無 --</span>
                                        </template>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </div>
                </div>
    
                <div class="text-right mt-6 pt-4 border-t border-gray-600 space-x-2">
                    <button @click="startFinalBattle()" class="btn btn-danger">發起決戰</button>
                    <button @click="modals.throneScout.isOpen = false" class="btn btn-secondary">關閉</button>
                </div>
            </div>
        </template>
    </div>
    
    <div class="modal" x-show="modals.itemManagement.isOpen" x-cloak>
        <div class="modal-content !max-w-3xl game-container relative p-6 rounded-lg">
            <h2 class="game-title font-medieval" x-text="modals.itemManagement.title"></h2>
            <div class="pt-10 max-h-[80vh] overflow-y-auto">
                <div class="p-4 mb-4 bg-gray-900/50 border border-yellow-500/30 rounded-lg text-center">
                    <p x-text="modals.itemManagement.message"></p>
                    <p class="mt-2">
                        <span>待處理裝備: </span>
                        <span class="font-bold text-lg" :class="modals.itemManagement.items.length > modals.itemManagement.capacity ? 'text-red-400' : 'text-green-400'" x-text="modals.itemManagement.items.length"></span>
                        <span> / </span>
                        <span class="font-bold text-lg text-green-400" x-text="modals.itemManagement.capacity"></span>
                    </p>
                </div>

                <div class="space-y-3">
                    <template x-for="item in modals.itemManagement.items" :key="item.id">
                        <div class="p-3 border border-gray-600 rounded flex flex-col md:flex-row justify-between items-center gap-4">
                            <div class="flex-grow">
                                <p :style="{ color: item.quality.color }" x-text="item.name"></p>
                                <p class="text-xs text-gray-400" x-html="getItemStatsString(item)"></p>
                            </div>
                            <div class="flex-shrink-0 flex items-center gap-2">
                                <button @click="executeItemManagementAction('decompose', item.id)" class="btn btn-sm btn-danger" :disabled="buildings.armory.level === 0" title="需要先建造兵工廠">分解</button>
                                <button @click="executeItemManagementAction('discard', item.id)" class="btn btn-sm btn-secondary">丟棄</button>
                            </div>
                        </div>
                    </template>
                </div>

                <div class="text-center mt-6 pt-4 border-t border-gray-700">
                    <button @click="confirmItemManagement()" class="btn btn-primary" :disabled="modals.itemManagement.items.length > modals.itemManagement.capacity">
                        確認處理
                    </button>
                </div>
            </div>
        </div>
    </div>
        <template x-if="modals.bailoutConfirm.isOpen">
            <div class="modal" @click.self="modals.bailoutConfirm.isOpen = false">
                <div class="modal-content game-container relative p-6 rounded-lg max-w-sm pt-10">
                    <p class="text-center text-lg" x-text="modals.bailoutConfirm.messages[modals.bailoutConfirm.currentMessageIndex]"></p>
                    <div class="text-center mt-6 flex justify-center space-x-4">
                        <button @click="confirmBailoutStep()" class="btn btn-danger">是</button>
                        <button @click="refuseBailout()" class="btn btn-secondary">否</button>
                    </div>
                </div>
            </div>
        </template>
        <script>
         // --- 地圖尺寸設定 ---
        const MAP_WIDTH = 480;  // 【修改】地圖畫布寬度 (單位: px)
        const MAP_HEIGHT = 700; // 【修改】地圖畫布高度 (單位: px)
        const GRID_SIZE = 120;   // 【修改】稍微增大網格，讓佈局更鬆散
        // --- 騎士團單位資料 ---
        const KNIGHT_ORDER_UNITS = {
            '士兵': { ratio: [2, 3, 2, 3], skill: { name: '衝鋒', cd: 9, type: 'aoe_str', multiplier: 0.5, description: '以自身力量0.5倍，對全體哥布林造成範圍傷害。' } },
            '盾兵': { ratio: [7, 1, 1, 1], skill: { name: '盾牆', cd: 6, type: 'taunt', duration: 3, description: '嘲諷全體哥布林，吸引所有傷害。' } },
            '槍兵': { ratio: [3, 3, 3, 1], skill: { name: '槍陣', cd: 5, type: 'reflect_buff', duration: 99, damagePercent: 2, description: '任何攻擊騎士團的哥布林，都會受到自身最大生命值2%的反噬傷害。' } },
            '弓兵': { ratio: [1, 4, 1, 4], skill: { name: '箭雨', cd: 3, type: 'aoe_agi', multiplier: 1, description: '以自身敏捷1倍，對全體哥布林造成範圍傷害。' } },
            '騎士': { ratio: [3, 3, 1, 3], skill: { name: '騎士道', cd: 7, type: 'king_nuke', description: '無視哥布林夥伴加成，對哥布林王本體造成巨大傷害。' } },
            '法師': { ratio: [1, 1, 7, 1], skill: { name: '破滅法陣', cd: 8, type: 'charge_nuke', multiplier: 2, chargeTime: 8, description: '詠唱8回合，結束後造成毀滅性範圍傷害。' } },
            '祭司': { ratio: [1, 1, 4, 4], skill: { name: '聖光', cd: 10, type: 'team_heal', triggerHp: 0.8, description: '當騎士團隊伍總血量低於80%時施放，恢復所有團員生命。' } },
        };

        // --- 工具 & 常數 ---
        const $ = (selector) => document.querySelector(selector);
        const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        // 【新增】定義復仇事件的難度係數
        const REVENGE_DIFFICULTY_COEFFICIENT = {
            easy: 0.5,
            normal: 1,
            hard: 1.5,
            hell: 2
        };
        const roll = (percentage) => randomInt(1, 100) <= Math.max(5, Math.min(95, percentage));
        const STAT_NAMES = { strength: '力量', agility: '敏捷', intelligence: '智力', luck: '運氣', hp: '生命', damage: '傷害', blockChance: '格擋率' };
        const EQUIPMENT_SLOTS = { mainHand: '主手', offHand: '副手', chest: '身體' };
        const TWO_HANDED_WEAPONS = ['雙手劍', '弓'];
        const STAT_DESCRIPTIONS = {
            strength: '力量：影響物理傷害和資源採集效率。',
            agility: '敏捷：影響命中率、迴避率和潛行成功率。',
            intelligence: '智力：影響魔法傷害、偵查能力和夥伴訓練成果。',
            luck: '運氣：影響幸運觸發率和每日可繁衍次數。'
        };
        const CITY_NAMES = {
            easy: { prefixes: ['溪木', '野豬', '微風', '月光'], suffix: '村' },
            normal: { prefixes: ['邊境', '白楊', '河灣', '峭壁'], suffix: '鎮' },
            hard: { prefixes: ['鐵壁', '白石', '榮光', '烈陽'], suffix: '都' },
            hell: { prefixes: ['風暴', '永恆', '聖光', '龍臨'], suffix: '王城' },
        };
        const BUILDING_TYPES = ['民房', '麵包坊', '農場', '教堂', '鐵匠鋪', '裁縫店', '衛兵所', '妓院', '豪宅', '伐木場', '礦坑'];
        const FEMALE_NAMES = ['愛麗絲', '伊麗莎白', '凱瑟琳', '安妮', '瑪格麗特', '艾格尼絲', '瑪麗亞', '貝拉', '克洛伊', '黛西', '艾瑪', '菲歐娜', '吉賽兒', '海倫', '艾琳', '奧黛麗'];
        const MALE_NAMES = ['亞瑟', '班', '查理', '丹尼爾', '伊森', '芬恩', '蓋文', '亨利', '丹尼', '傑克', '杰瑞', '傑森'];
        const PROFESSIONS = ['居民', '女僕', '修女', '農婦', '商人', '妓女', '麵包師', '廚師', '裁縫師' ,'吟遊詩人', '藝術家' ];
        const ENEMY_STAT_RANGES = {
            easy:    { resident: [20, 20], guard: [20, 40] },
            normal: { resident: [20, 40], guard: [40, 80] },
            hard:    { resident: [40, 80], guard: [80, 160] },
            hell:    { resident: [80, 160], guard: [160, 320] },
        };
        const VISUAL_OPTIONS = {
            hairColor: ['金色', '黑色', '棕色', '紅色', '銀色', '灰色', '白色', '藍色', '綠色', '焦糖色', '紅棕色', '藍黑色', '薰衣草灰', '薄荷綠', '蜂蜜色', '冷棕色', '霧感灰', '藍灰色'],
            hairStyle: ['長髮', '男孩風短髮', '馬尾', '大波浪捲髮', '雙馬尾', '狼尾剪短髮', '精靈短髮', '鮑伯頭', '齊瀏海短髮', '長瀏海短髮', '中長捲髮', '及肩髮', '公主切', '水波捲', '羊毛捲', '木馬捲', '蘋果頭', '水母頭'],
            bust: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'],
            personality: ['溫順', '倔強', '開朗', '害羞', '傲慢', '傲嬌', '男子氣', '大小姐', '古風', '坦率', '天真', '樂觀', '勇敢', '急躁', '熱情', '性感', '陰沉', '文靜', '冷靜', '自卑', '親切', '刻薄', '糊塗', '清挑', '病嬌', '中二病', '天然呆', '腹黑'],
            clothing: ['亞麻布衣', '精緻長裙', '皮甲', '絲綢禮服', '女僕裝', '收腰連衣裙', '寬袖長裙', '斗篷', '性感內衣']
        };

        // --- 裝備系統常數 ---
        const EQUIPMENT_QUALITIES = {
            worn:      { name: '破舊', color: '#9ca3af', multiplier: 0.4, affixes: [0, 1] },
            common:    { name: '普通', color: '#ffffff', multiplier: 0.8, affixes: [1, 1] },
            uncommon:  { name: '精良', color: '#4ade80', multiplier: 1.2, affixes: [1, 2] },
            rare:      { name: '稀有', color: '#60a5fa', multiplier: 1.6, affixes: [2, 2] },
            epic:      { name: '史詩', color: '#a78bfa', multiplier: 2.0, affixes: [2, 3] },
            legendary: { name: '傳說', color: '#f97316', multiplier: 2.4, affixes: [3, 3] },
        };

        const EQUIPMENT_MATERIALS = {
            iron:   { name: '鐵', tier: 1, type: 'metal', cost: 10 },
            copper: { name: '銅', tier: 2, type: 'metal', cost: 20 },
            steel:  { name: '鋼', tier: 3, type: 'metal', cost: 40 },
            silver: { name: '銀', tier: 4, type: 'metal', cost: 80 },
            gold:   { name: '黃金', tier: 5, type: 'metal', cost: 160 },
            mithril:{ name: '秘銀', tier: 6, type: 'metal', cost: 320 },
            orichalcum: { name: '殞鐵', tier: 7, type: 'metal', cost: 640 },
            pine:   { name: '松木', tier: 1, type: 'wood', cost: 10 },
            ash:    { name: '白蠟木', tier: 2, type: 'wood', cost: 20 },
            mahogany:{ name: '桃花心木', tier: 3, type: 'wood', cost: 40 },
            rosewood:{ name: '紫檀木', tier: 4, type: 'wood', cost: 80 },
            ebony:  { name: '烏木', tier: 5, type: 'wood', cost: 160 },
            ironwood:{ name: '鐵木', tier: 6, type: 'wood', cost: 320 },
            godwood: { name: '神木', tier: 7, type: 'wood', cost: 640 },
        };

        // --- 詞綴系統 ---
        const STANDARD_AFFIXES = {
            // Stat Prefixes
            strong: { name: '強壯的', type: 'stat', effects: [{ stat: 'strength', value: 1.1, type: 'multiplier' }], conflicts: ['savage', 'assassin'] },
            agile: { name: '靈巧的', type: 'stat', effects: [{ stat: 'agility', value: 1.1, type: 'multiplier' }], conflicts: ['troll'] },
            wise: { name: '智慧的', type: 'stat', effects: [{ stat: 'intelligence', value: 1.1, type: 'multiplier' }], conflicts: ['savage'] },
            lucky: { name: '幸運的', type: 'stat', effects: [{ stat: 'luck', value: 1.1, type: 'multiplier' }], conflicts: [] },
            sturdy: { name: '堅固的', type: 'stat', effects: [{ stat: 'hp', value: 1.1, type: 'multiplier' }], conflicts: ['troll'] },
            savage: { name: '野蠻的', type: 'stat', effects: [{ stat: 'strength', value: 1.25, type: 'multiplier' }, { stat: 'intelligence', value: 0.8, type: 'multiplier' }], conflicts: ['strong', 'wise', 'assassin'] },
            assassin: { name: '刺客的', type: 'stat', effects: [{ stat: 'agility', value: 1.25, type: 'multiplier' }, { stat: 'strength', value: 0.8, type: 'multiplier' }], conflicts: ['strong', 'savage'] },
            troll: { name: '巨魔的', type: 'stat', effects: [{ stat: 'hp', value: 1.25, type: 'multiplier' }, { stat: 'agility', value: 0.8, type: 'multiplier' }], conflicts: ['agile', 'sturdy'] },
            kings: { name: '哥布林王的', type: 'stat', effects: [{ stat: 'all', value: 1.05, type: 'multiplier' }], conflicts: [] },
            // Proc Prefixes
            vampiric: { name: '吸血的', type: 'proc', procInfo: { baseRate: 10, type: 'vampiric', value: 0.5 } }, // 吸取造成傷害的50%
            spiky: { name: '尖刺的', type: 'proc', procInfo: { baseRate: 10, type: 'thorns', value: 0.1 } }, // 反彈自身最大生命值10%的傷害
            multi_hit: { name: '連擊的', type: 'proc', procInfo: { baseRate: 5, type: 'multi_hit' } },
            devastating: { name: '毀滅的', type: 'proc', procInfo: { type: 'devastating', value: 1.5 } }, // 爆擊傷害變為1.5倍(基礎)
            regenerating: { name: '再生的', type: 'proc', procInfo: { type: 'regenerating', value: 0.05 } }, // 每回合恢復5%最大生命值
            blocking: { name: '格擋的', type: 'proc', procInfo: { baseRate: 5, type: 'blocking' } },
            penetrating: { name: '穿透的', type: 'proc', procInfo: { baseRate: 10, type: 'penetrating', value: 0.05 } }, // 造成目標最大生命值5%的額外傷害
        };
        
        const BASE_EQUIPMENT_STATS = {
            metal: {
                '劍':   { 1: { damage: 6 }, 2: { damage: 11 }, 3: { damage: 20 }, 4: { damage: 36 }, 5: { damage: 65 }, 6: { damage: 117 }, 7: { damage: 210 } },
                '雙手劍': { 1: { damage: 10 }, 2: { damage: 18 }, 3: { damage: 32 }, 4: { damage: 58 }, 5: { damage: 104 }, 6: { damage: 187 }, 7: { damage: 337 } },
                '長槍': { 1: { damage: 8 }, 2: { damage: 14 }, 3: { damage: 25 }, 4: { damage: 45 }, 5: { damage: 81 }, 6: { damage: 146 }, 7: { damage: 263 } },
                '弓':   { 1: { damage: 8 }, 2: { damage: 14 }, 3: { damage: 25 }, 4: { damage: 45 }, 5: { damage: 81 }, 6: { damage: 146 }, 7: { damage: 263 } },
                '法杖': { 1: { damage: 8 }, 2: { damage: 14 }, 3: { damage: 25 }, 4: { damage: 45 }, 5: { damage: 81 }, 6: { damage: 146 }, 7: { damage: 263 } },
                '盾':   { 1: { hp: 30, damage: 1, blockChance: 5 }, 2: { hp: 54, damage: 2, blockChance: 6 }, 3: { hp: 96, damage: 3, blockChance: 8 }, 4: { hp: 174, damage: 5, blockChance: 10 }, 5: { hp: 312, damage: 8, blockChance: 12 }, 6: { hp: 562, damage: 13, blockChance: 15 }, 7: { hp: 1011, damage: 21, blockChance: 20 } },
                '鎧甲': { 1: { hp: 40, damage: 2 }, 2: { hp: 72, damage: 3 }, 3: { hp: 128, damage: 5 }, 4: { hp: 230, damage: 8 }, 5: { hp: 414, damage: 13 }, 6: { hp: 745, damage: 21 }, 7: { hp: 1341, damage: 34 } }
            },
            wood: {
                '劍':   { 1: { damage: 5, hp: 6 }, 2: { damage: 9, hp: 12 }, 3: { damage: 16, hp: 24 }, 4: { damage: 29, hp: 42 }, 5: { damage: 52, hp: 78 }, 6: { damage: 94, hp: 138 }, 7: { damage: 169, hp: 246 } },
                '雙手劍': { 1: { damage: 8, hp: 12 }, 2: { damage: 14, hp: 24 }, 3: { damage: 26, hp: 36 }, 4: { damage: 46, hp: 72 }, 5: { damage: 83, hp: 126 }, 6: { damage: 150, hp: 222 }, 7: { damage: 270, hp: 402 } },
                '長槍': { 1: { damage: 6, hp: 12 }, 2: { damage: 11, hp: 18 }, 3: { damage: 20, hp: 30 }, 4: { damage: 37, hp: 48 }, 5: { damage: 66, hp: 90 }, 6: { damage: 119, hp: 162 }, 7: { damage: 214, hp: 294 } },
                '弓':   { 1: { damage: 6, hp: 12 }, 2: { damage: 11, hp: 18 }, 3: { damage: 20, hp: 30 }, 4: { damage: 37, hp: 48 }, 5: { damage: 66, hp: 90 }, 6: { damage: 119, hp: 162 }, 7: { damage: 214, hp: 294 } },
                '法杖': { 1: { damage: 6, hp: 12 }, 2: { damage: 11, hp: 18 }, 3: { damage: 20, hp: 30 }, 4: { damage: 37, hp: 48 }, 5: { damage: 66, hp: 90 }, 6: { damage: 119, hp: 162 }, 7: { damage: 214, hp: 294 } },
                '盾':   { 1: { hp: 36, blockChance: 3 }, 2: { hp: 66, blockChance: 4 }, 3: { hp: 114, blockChance: 5 }, 4: { hp: 204, blockChance: 6 }, 5: { hp: 366, blockChance: 7 }, 6: { hp: 660, blockChance: 8 }, 7: { hp: 1188, blockChance: 10 } },
                '鎧甲': { 1: { hp: 52 }, 2: { hp: 90 }, 3: { hp: 158 }, 4: { hp: 278 }, 5: { hp: 492 }, 6: { hp: 882 }, 7: { hp: 1584 } }
            }
        };

        // --- 輔助函式 ---
        function distributeStatsWithRatio(totalPoints, ratio) {
            const stats = { strength: 0, agility: 0, intelligence: 0, luck: 0 };
            const statKeys = ['strength', 'agility', 'intelligence', 'luck'];
            const totalRatio = ratio.reduce((a, b) => a + b, 0);
            let pointsRemaining = totalPoints;

            if (totalRatio === 0) return distributeStats(totalPoints);

            for (let i = 0; i < ratio.length; i++) {
                const pointsForStat = Math.floor(totalPoints * (ratio[i] / totalRatio));
                stats[statKeys[i]] = pointsForStat;
                pointsRemaining -= pointsForStat;
            }

            while (pointsRemaining > 0) {
                stats[statKeys[randomInt(0, 3)]]++;
                pointsRemaining--;
            }
            return stats;
        }
        // 【新增此函數】
        function distributeStatsWithFemaleKnightRatio(totalPoints, baseRatio) {
            const stats = { strength: 0, agility: 0, intelligence: 0, luck: 0, charisma: 0 };
            const statKeys = ['strength', 'agility', 'intelligence', 'luck', 'charisma'];
            
            // 將基礎的4項比值與新的魅力比值:3結合
            const finalRatio = [...baseRatio, 3];
            const totalRatio = finalRatio.reduce((a, b) => a + b, 0);
            let pointsRemaining = totalPoints;

            if (totalRatio === 0) {
                // 如果基礎比值有問題，則退回平均分配
                return distributeStats(totalPoints, statKeys);
            }

            for (let i = 0; i < finalRatio.length; i++) {
                const pointsForStat = Math.floor(totalPoints * (finalRatio[i] / totalRatio));
                stats[statKeys[i]] = pointsForStat;
                pointsRemaining -= pointsForStat;
            }

            // 將分配後剩餘的點數隨機加到5項能力值上
            while (pointsRemaining > 0) {
                stats[statKeys[randomInt(0, 4)]]++;
                pointsRemaining--;
            }
            return stats;
        }

        function distributeStats(totalPoints, statKeys = ['strength', 'agility', 'intelligence', 'luck']) {
            let stats = {};
            let pointsRemaining = totalPoints;
            statKeys.forEach(key => {
                stats[key] = 1;
                pointsRemaining--;
            });

            for (let i = 0; i < pointsRemaining; i++) {
                const randomStat = statKeys[randomInt(0, statKeys.length - 1)];
                stats[randomStat]++;
            }
            return stats;
        }

        function generateVisuals() {
            return {
                // 【修改】分別生成髮色與髮型，並移除舊的hair屬性
                hairColor: VISUAL_OPTIONS.hairColor[randomInt(0, VISUAL_OPTIONS.hairColor.length - 1)],
                hairStyle: VISUAL_OPTIONS.hairStyle[randomInt(0, VISUAL_OPTIONS.hairStyle.length - 1)],
                height: randomInt(130, 170),
                age: randomInt(18, 30),
                bust: VISUAL_OPTIONS.bust[randomInt(0, VISUAL_OPTIONS.bust.length - 1)],
                personality: VISUAL_OPTIONS.personality[randomInt(0, VISUAL_OPTIONS.personality.length - 1)],
                clothing: VISUAL_OPTIONS.clothing[randomInt(0, VISUAL_OPTIONS.clothing.length - 1)],
            };
        }

        // --- 遊戲類別 ---
        class Equipment {
            constructor(baseName, type, slot, material, quality, affix = null) {
                this.id = crypto.randomUUID();
                this.baseName = baseName;
                this.type = type;
                this.slot = slot;
                this.material = material;
                this.quality = quality;
                this.stats = {};
                this.specialAffix = affix; // 原本錯誤地寫成了 specialAffix
                this.affixes = [];
                this.name = this.generateName();
            }

           generateName() {
                let prefix = '';

                // 第一步：優先檢查是不是「特殊彩蛋裝備」
                if (this.specialAffix) { // <--- 我們將 'this.affix' 改名為 'this.specialAffix'
                    // 如果是，就執行跟舊版完全一樣的邏輯，來獲得"脫力的"、"肛蛋的"等名稱
                    prefix = {
                        'strength_curse': '脫力的 ',
                        'agility_curse': '遲鈍的 ',
                        'intelligence_curse': '愚鈍的 ',
                        'luck_curse': '不幸的 ',
                        'gundam_curse': '肛蛋的 ',
                        'henshin_curse': '變身的 ',
                    }[this.specialAffix] || '';
                    // 找到彩蛋詞綴後，這個函數的詞綴處理部分就結束了，直接跳到最後回傳名稱。
                } 
                
                // 第二步：如果不是彩蛋裝備，才檢查它有沒有「標準詞綴」
                else if (this.affixes.length > 0) {
                    // 這裡 'this.affixes' 是我們新增的陣列，例如可能包含 ['強壯的', '吸血的']
                    // .map(affix => affix.name) 會取出每個詞綴的名字
                    // .join('') 會將它們串在一起
                    prefix = this.affixes.map(affix => affix.name).join('') + ' ';
                }
                
                // 最後，組合名稱並回傳
                return `${prefix}${this.quality.name}的${this.material.name}${this.baseName}`;
            }
        }

        class Unit {
            constructor(name, stats, profession) {
                this.id = crypto.randomUUID();
                this.name = name;
                this.stats = { strength: 0, agility: 0, intelligence: 0, luck: 0, charisma: 0, ...stats };
                this.profession = profession;
                this.maxHp = 0;
                this.currentHp = 0;
                this.skills = [];
                this.statusEffects = [];
            }
            isAlive() { return this.currentHp > 0; }
            calculateMaxHp() { return 0; }
            
            getTotalStat(stat, isStarving = false) {
                if (stat === 'hp') return this.calculateMaxHp(isStarving);
                if (!this.stats.hasOwnProperty(stat)) return 0;
                let total = this.stats[stat] || 0;
                return total;
            }

            tickCooldowns() {
                if (this.skills && this.skills.length > 0) {
                    this.skills.forEach(skill => {
                        if (skill.currentCooldown > 0) {
                            skill.currentCooldown--;
                        }
                    });
                }
            }

            calculateDamage(isStarving = false) {
                // 對於非玩家單位，傷害預設為其總力量值
                return this.getTotalStat('strength', isStarving);
            }
        }

        class Goblin extends Unit {
            constructor(name, stats) {
                super(name, stats, '哥布林');
                this.hasBeenTrained = false;
                this.equipment = {
                    mainHand: null,
                    offHand: null,
                    chest: null,
                };
            }
            getEquipmentBonus(stat) {
                if (!this.equipment) return 0;
                return Object.values(this.equipment).reduce((sum, item) => {
                    return sum + (item && item.stats && item.stats[stat] ? item.stats[stat] : 0);
                }, 0);
            }
            getTotalStat(stat, isStarving = false) {
                if (!this.stats.hasOwnProperty(stat)) return 0;
                let baseValue = this.stats[stat];
                let flatBonus = this.getEquipmentBonus(stat);
                
                let multiplier = 1.0;
                Object.values(this.equipment).forEach(item => {
                    if (!item) return;
                    item.affixes.forEach(affix => {
                        if (affix.type !== 'stat') return;
                        affix.effects.forEach(effect => {
                            if (effect.stat === stat || effect.stat === 'all') {
                                if (effect.type === 'multiplier') {
                                    multiplier *= effect.value;
                                }
                            }
                        });
                    });
                });
                
                let total = Math.floor((baseValue + flatBonus) * multiplier);
                return isStarving ? Math.floor(total * 0.75) : total;
            }
            calculateMaxHp(isStarving = false) {
                const totalStr = this.getTotalStat('strength', isStarving);
                const totalAgi = this.getTotalStat('agility', isStarving);
                const totalInt = this.getTotalStat('intelligence', isStarving);
                const totalLuc = this.getTotalStat('luck', isStarving);
                let maxHp = (totalStr + totalAgi + totalInt + totalLuc) * 6 + this.getEquipmentBonus('hp');
                 if (this.equipment && this.equipment.mainHand && this.equipment.mainHand.baseName === '雙手劍') {
                    maxHp = Math.floor(maxHp * 0.85);
                }
                return Math.max(1, maxHp);
            }
            calculateDamage(isStarving = false) {
                const mainHand = this.equipment.mainHand;
                let weaponDamage = 0;
                if (mainHand) {
                    const baseDamage = mainHand.stats.damage || 0;
                    const weaponType = mainHand.baseName;
                    let mainStatValue = 0;
                    
                    const hasShield = this.equipment.offHand?.baseName === '盾';

                    switch (weaponType) {
                        case '劍':
                        case '雙手劍':
                            mainStatValue = this.getTotalStat('strength', isStarving);
                            weaponDamage = mainStatValue + baseDamage;
                            if (weaponType === '雙手劍') weaponDamage = Math.floor(weaponDamage * 1.5);
                            break;
                        case '長槍':
                            mainStatValue = this.getTotalStat('luck', isStarving);
                            weaponDamage = mainStatValue + baseDamage;
                            break;
                        case '弓':
                            mainStatValue = this.getTotalStat('agility', isStarving);
                            weaponDamage = mainStatValue + baseDamage;
                            break;
                        case '法杖':
                            mainStatValue = this.getTotalStat('intelligence', isStarving);
                            weaponDamage = mainStatValue + baseDamage;
                            break;
                        default:
                            mainStatValue = this.getTotalStat('strength', isStarving);
                            weaponDamage = mainStatValue;
                    }

                    // 【新增】單手持有懲罰邏輯
                    if (hasShield && (weaponType === '長槍' || weaponType === '法杖')) {
                        // 這就是您可以隨時調整的平衡係數
                        const oneHandedPenalty = 0.7; // 傷害變為 70%
                        weaponDamage = Math.floor(weaponDamage * oneHandedPenalty);
                    }

                } else {
                    weaponDamage = this.getTotalStat('strength', isStarving);
                }
                const shieldBonus = this.equipment.offHand?.stats?.damage || 0;
                const armorBonus = this.equipment.chest?.stats?.damage || 0;
                return weaponDamage + shieldBonus + armorBonus;
            }
            updateHp(isStarving = false) {
                const oldMaxHp = this.maxHp;
                this.maxHp = this.calculateMaxHp(isStarving);
                const hpPercentage = oldMaxHp > 0 ? this.currentHp / oldMaxHp : 1;
                this.currentHp = Math.round(this.maxHp * hpPercentage);
                if (this.currentHp > this.maxHp) this.currentHp = this.maxHp;
                this.currentHp = Math.max(0, this.currentHp);
            }
        }

       class Player extends Goblin {
            constructor(name, stats, appearance, height, penisSize) {
                super(name, stats);
                this.appearance = appearance;
                this.height = height;
                this.penisSize = penisSize;
                this.skillPoints = 0;
                this.attributePoints = 0;
                this.party = [];
                this.avatarUrl = null;
                this.inventory = [];
                this.equipment = {
                    mainHand: null,
                    offHand: null,
                    chest: null,
                };
                this.maxHp = this.calculateMaxHp();
                this.currentHp = this.maxHp;
            }
            getPartyBonus(stat) {
                if (!this.party || !stat || stat === 'hp' || stat === 'damage') return 0;
                const totalBonus = this.party.reduce((sum, p) => sum + (p.stats[stat] || 0), 0);
                return Math.floor(totalBonus * 0.5);
            }
            getEquipmentBonus(stat) {
                if (!this.equipment || !stat) return 0;
                let flatBonus = 0;
                Object.values(this.equipment).forEach(item => {
                    if (!item || !item.stats) return;
                    // 只加總來自裝備基礎屬性的加值 (白字)
                    if (item.stats[stat]) {
                        flatBonus += item.stats[stat];
                    }
                });
                return flatBonus;
            }
            // 【新增此函數】
            getEffectiveEquipmentBonus(stat) {
                if (!this.equipment) return 0;
                
                const totalStat = this.getTotalStat(stat, this.isStarving);
                
                // 計算出所有非裝備來源的屬性總和
                let baseValue = this.stats[stat] + this.getPartyBonus(stat);
                baseValue += this.getAffixEffect(stat).bonus;
                baseValue -= this.getAffixPenalty();
                
                // 從最終總屬性中減去非裝備屬性，得出的就是裝備提供的等效加成值
                const effectiveBonus = totalStat - baseValue;

                return Math.round(effectiveBonus);
            }
            // 【新增此方法】
            getAffixEffect(stat) {
                const bonus = { bonus: 0 };
                if (!this.equipment) return bonus;
                const zeroStats = Object.keys(this.stats).filter(s => ['strength', 'agility', 'intelligence', 'luck'].includes(s) && this.stats[s] === 0);

                const checkAffix = (item, affixName, requiredStat, bonusValue) => {
                    if (item && item.specialAffix === affixName && this.stats[requiredStat] === 0) {
                        if (stat === requiredStat) {
                            bonus.bonus += bonusValue;
                        }
                    }
                };
                
                checkAffix(this.equipment.mainHand, 'strength_curse', 'strength', 10);
                checkAffix(this.equipment.mainHand, 'agility_curse', 'agility', 10);
                checkAffix(this.equipment.mainHand, 'intelligence_curse', 'intelligence', 10);
                checkAffix(this.equipment.mainHand, 'luck_curse', 'luck', 10);

                if (this.equipment.offHand && this.equipment.offHand.specialAffix === 'gundam_curse' && zeroStats.length === 2) {
                    if (zeroStats.includes(stat)) {
                        bonus.bonus += 8;
                    }
                }

                if (this.equipment.chest && this.equipment.chest.specialAffix === 'henshin_curse' && zeroStats.length === 3) {
                     if (zeroStats.includes(stat)) {
                        bonus.bonus += 5;
                    }
                }
                return bonus;
            }
            // 【新增此方法】
            getAffixPenalty() {
                let penalty = 0;
                if (!this.equipment) return penalty;
                const zeroStats = Object.keys(this.stats).filter(s => ['strength', 'agility', 'intelligence', 'luck'].includes(s) && this.stats[s] === 0);

                const checkPenalty = (item, affixName, requiredStat, penaltyValue) => {
                    if (item && item.specialAffix === affixName && this.stats[requiredStat] !== 0) {
                        penalty += penaltyValue;
                    }
                };

                checkPenalty(this.equipment.mainHand, 'strength_curse', 'strength', 10);
                checkPenalty(this.equipment.mainHand, 'agility_curse', 'agility', 10);
                checkPenalty(this.equipment.mainHand, 'intelligence_curse', 'intelligence', 10);
                checkPenalty(this.equipment.mainHand, 'luck_curse', 'luck', 10);
                
                if (this.equipment.offHand && this.equipment.offHand.specialAffix === 'gundam_curse' && zeroStats.length !== 2) {
                    penalty += 8;
                }
                if (this.equipment.chest && this.equipment.chest.specialAffix === 'henshin_curse' && zeroStats.length !== 3) {
                    penalty += 5;
                }
                
                return penalty;
            }
            getTotalStat(stat, isStarving = false) {
                if (stat === 'hp') return this.calculateMaxHp(isStarving);
                if (!this.stats.hasOwnProperty(stat) || !['strength', 'agility', 'intelligence', 'luck'].includes(stat)) {
                    return 0;
                }

                // 1. 基礎值 = 自身原始值 + 夥伴加成
                let baseValue = this.stats[stat] + this.getPartyBonus(stat);

                // 2. 固定加成值 = 裝備基礎屬性 + 特殊詛咒裝備效果
                let flatBonus = this.getEquipmentBonus(stat); // 此處只應獲取裝備白字
                flatBonus += this.getAffixEffect(stat).bonus;
                flatBonus -= this.getAffixPenalty();

                // 3. 百分比乘積 = 所有標準詞綴的乘法效果疊乘
                let multiplier = 1.0;
                Object.values(this.equipment).forEach(item => {
                    if (!item) return;
                    item.affixes.forEach(affix => {
                        if (affix.type !== 'stat') return;
                        affix.effects.forEach(effect => {
                            if (effect.stat === stat || effect.stat === 'all') {
                                if (effect.type === 'multiplier') {
                                    multiplier *= effect.value;
                                }
                            }
                        });
                    });
                });
                
                // 4. 計算最終總值
                let total = Math.floor((baseValue + flatBonus) * multiplier);
                
                total = Math.max(0, total);
                
                // 5. 最後套用飢餓懲罰
                return isStarving ? Math.floor(total * 0.75) : total;
            }
            getBaseMaxHp(isStarving = false) {
                let total = (this.stats.strength || 0) + (this.stats.agility || 0) + (this.stats.intelligence || 0) + (this.stats.luck || 0);
                if(isStarving) total = Math.floor(total * 0.75);
                return total * 6;
            }
            getPartyHpBonus(isStarving = false) {
                if (!this.party || this.party.length === 0) return 0;
                let total = this.party.reduce((sum, p) => {
                    const partnerStatSum = p.stats.strength + p.stats.agility + p.stats.intelligence + p.stats.luck;
                    return sum + partnerStatSum;
                }, 0);
                const partyBonus = Math.floor(total * 0.5);
                return (isStarving ? Math.floor(partyBonus * 0.75) : partyBonus) * 6;
            }
            getEquipmentHpBonus() {
                return this.getEquipmentBonus('hp');
            }
            calculateMaxHp(isStarving = false) {
                // 【修正】使用 getTotalStat 來獲取包含所有加成的最終能力值
                const totalStr = this.getTotalStat('strength', isStarving);
                const totalAgi = this.getTotalStat('agility', isStarving);
                const totalInt = this.getTotalStat('intelligence', isStarving);
                const totalLuc = this.getTotalStat('luck', isStarving);

                // 【修正】生命值公式改為：(所有最終能力值總和 * 6) + 裝備直接提供的HP
                let maxHp = (totalStr + totalAgi + totalInt + totalLuc) * 6 + this.getEquipmentHpBonus();
                
                // 雙手劍懲罰
                if (this.equipment && this.equipment.mainHand && this.equipment.mainHand.baseName === '雙手劍') {
                    maxHp = Math.floor(maxHp * 0.85);
                }
                return Math.max(1, maxHp);
            }
            updateHp(isStarving = false) {
                const oldMaxHp = this.maxHp;
                const oldHpPercentage = oldMaxHp > 0 ? this.currentHp / oldMaxHp : 1;
                
                // 先計算出新的最大生命值
                this.maxHp = this.calculateMaxHp(isStarving);

                // 【核心修正】如果最大生命值是增加的，且之前是滿血狀態，則直接補滿當前生命值
                if (this.maxHp > oldMaxHp && oldHpPercentage >= 1) {
                    this.currentHp = this.maxHp;
                } else {
                    // 否則，維持現有的血量百分比
                    this.currentHp = Math.round(this.maxHp * oldHpPercentage);
                }

                // 確保當前生命值不會超過上限或低於0
                this.currentHp = Math.min(this.currentHp, this.maxHp);
                this.currentHp = Math.max(0, this.currentHp);
            }
            calculateDamage(isStarving = false) {
                const mainHand = this.equipment.mainHand;
                let weaponDamage = 0;
                if (mainHand) {
                    const baseDamage = mainHand.stats.damage || 0;
                    const weaponType = mainHand.baseName;
                    let mainStatValue = 0;
                    
                    const hasShield = this.equipment.offHand?.baseName === '盾';

                    switch (weaponType) {
                        case '劍':
                        case '雙手劍':
                            mainStatValue = this.getTotalStat('strength', isStarving);
                            weaponDamage = mainStatValue + baseDamage;
                            if (weaponType === '雙手劍') weaponDamage = Math.floor(weaponDamage * 1.5);
                            break;
                        case '長槍':
                            mainStatValue = this.getTotalStat('luck', isStarving);
                            weaponDamage = mainStatValue + baseDamage;
                            break;
                        case '弓':
                            mainStatValue = this.getTotalStat('agility', isStarving);
                            weaponDamage = mainStatValue + baseDamage;
                            break;
                        case '法杖':
                            mainStatValue = this.getTotalStat('intelligence', isStarving);
                            weaponDamage = mainStatValue + baseDamage;
                            break;
                        default:
                            mainStatValue = this.getTotalStat('strength', isStarving);
                            weaponDamage = mainStatValue;
                    }

                    // 【新增】單手持有懲罰邏輯
                    if (hasShield && (weaponType === '長槍' || weaponType === '法杖')) {
                        // 這就是您可以隨時調整的平衡係數
                        const oneHandedPenalty = 0.7; // 傷害變為 70%
                        weaponDamage = Math.floor(weaponDamage * oneHandedPenalty);
                    }

                } else {
                    weaponDamage = this.getTotalStat('strength', isStarving);
                }
                const shieldBonus = this.equipment.offHand?.stats?.damage || 0;
                const armorBonus = this.equipment.chest?.stats?.damage || 0;
                return weaponDamage + shieldBonus + armorBonus;
            }
        }
        
        class Human extends Unit {
            constructor(name, stats, profession) {
                super(name, stats, profession);
                // 【新增】初始化裝備欄位
                this.equipment = {
                    mainHand: null,
                    offHand: null,
                    chest: null,
                };
            }

            // 【新增】從 Goblin 類別複製過來的函式
            getEquipmentBonus(stat) {
                if (!this.equipment) return 0;
                return Object.values(this.equipment).reduce((sum, item) => {
                    return sum + (item && item.stats && item.stats[stat] ? item.stats[stat] : 0);
                }, 0);
            }

            // 【新增】從 Goblin 類別複製過來的函式
            getTotalStat(stat, isStarving = false) {
                if (!this.stats.hasOwnProperty(stat)) return 0;
                let baseValue = this.stats[stat];
                let flatBonus = this.getEquipmentBonus(stat);
                
                let multiplier = 1.0; // 敵人暫不處理複雜的詞綴乘法
                
                let total = Math.floor((baseValue + flatBonus) * multiplier);
                return isStarving ? Math.floor(total * 0.75) : total;
            }

            // 【新增】從 Goblin 類別複製過來的函式
            calculateDamage(isStarving = false) {
                const mainHand = this.equipment.mainHand;
                let weaponDamage = 0;
                if (mainHand) {
                    const baseDamage = mainHand.stats.damage || 0;
                    const weaponType = mainHand.baseName;
                    let mainStatValue = 0;
                    const hasShield = this.equipment.offHand?.baseName === '盾';

                    switch (weaponType) {
                        case '劍': case '雙手劍':
                            mainStatValue = this.getTotalStat('strength', isStarving);
                            weaponDamage = mainStatValue + baseDamage;
                            if (weaponType === '雙手劍') weaponDamage = Math.floor(weaponDamage * 1.5);
                            break;
                        case '長槍':
                            mainStatValue = this.getTotalStat('luck', isStarving);
                            weaponDamage = mainStatValue + baseDamage;
                            break;
                        case '弓':
                            mainStatValue = this.getTotalStat('agility', isStarving);
                            weaponDamage = mainStatValue + baseDamage;
                            break;
                        case '法杖':
                            mainStatValue = this.getTotalStat('intelligence', isStarving);
                            weaponDamage = mainStatValue + baseDamage;
                            break;
                        default:
                            mainStatValue = this.getTotalStat('strength', isStarving);
                            weaponDamage = mainStatValue;
                    }
                    if (hasShield && (weaponType === '長槍' || weaponType === '法杖')) {
                        const oneHandedPenalty = 0.7;
                        weaponDamage = Math.floor(weaponDamage * oneHandedPenalty);
                    }
                } else {
                    weaponDamage = this.getTotalStat('strength', isStarving);
                }
                const shieldBonus = this.equipment.offHand?.stats?.damage || 0;
                const armorBonus = this.equipment.chest?.stats?.damage || 0;
                return weaponDamage + shieldBonus + armorBonus;
            }

            // 【新增】一個簡易版的 updateHp
            updateHp(isStarving = false) {
                const oldMaxHp = this.maxHp;
                this.maxHp = this.calculateMaxHp(isStarving);
                const hpPercentage = oldMaxHp > 0 ? this.currentHp / oldMaxHp : 1;
                this.currentHp = Math.round(this.maxHp * hpPercentage);
            }
        }
        
        class FemaleHuman extends Human {
             // 【修改】確保 constructor 的參數列表包含了 originDifficulty
            constructor(name, stats, profession, visual, originDifficulty = 'easy') { 
                super(name, stats, profession);
                this.visual = visual;
                this.isPregnant = false;
                this.pregnancyTimer = 0;
                this.isMother = false;
                // 【修改】這一行現在可以正確地從參數接收 originDifficulty
                this.originDifficulty = originDifficulty; 
                this.maxHp = this.calculateMaxHp();
                this.currentHp = this.maxHp;
            }
            calculateMaxHp() {
                const { strength, agility, intelligence, luck, charisma } = this.stats;
                return (strength + agility + intelligence + luck + charisma) * 5;
            }
        }

        class MaleHuman extends Human {
            constructor(name, stats, profession, originDifficulty = 'easy') { // 新增參數
                super(name, stats, profession);
                this.originDifficulty = originDifficulty; // 新增屬性
                this.maxHp = this.calculateMaxHp();
                this.currentHp = this.maxHp;
            }
            calculateMaxHp() {
                const { strength, agility, intelligence, luck } = this.stats;
                return (strength + agility + intelligence + luck) * 5;
            }
        }

        class KnightOrderUnit extends MaleHuman {
            constructor(unitType, totalStatPoints, originDifficulty = 'easy') { // 新增參數
                const unitDetails = KNIGHT_ORDER_UNITS[unitType];
                const stats = distributeStatsWithRatio(totalStatPoints, unitDetails.ratio);
                super(unitType, stats, unitType, originDifficulty); // 將參數傳遞給父類別
                this.skills = [];
                if (unitDetails.skill) {
                    this.skills.push({
                        ...unitDetails.skill,
                        currentCooldown: 0,
                    });
                }
            }
        }
        // 生成女性騎士團成員
        class FemaleKnightOrderUnit extends FemaleHuman {
            // 【修改】確保 constructor 接收 difficulty 參數
            constructor(unitType, totalStatPoints, difficulty = 'easy') { 
                const unitDetails = KNIGHT_ORDER_UNITS[unitType];
                const stats = distributeStatsWithFemaleKnightRatio(totalStatPoints, unitDetails.ratio);
                const visual = generateVisuals();
                const name = FEMALE_NAMES[randomInt(0, FEMALE_NAMES.length - 1)];

                // 【修改】確保 super() 將 difficulty 參數傳遞給父類別 FemaleHuman
                super(name, stats, unitType, visual, difficulty); 
                
                this.skills = [];
                if (unitDetails.skill) {
                    this.skills.push({
                        ...unitDetails.skill,
                        currentCooldown: 0,
                    });
                }
            }
        }

        function game() {
            return {
                pendingDecisions: [],
                bailoutCounter: 0, // 【新增此行】用來計算玩家求助的次數
                bailoutOfferedButRefused: false, // 【新增此行】記錄玩家是否拒絕過求助
                screen: 'api_key_input', // 【修改】將初始畫面改為 API 輸入介面
                userApiKey: '',          // 【新增】用來儲存玩家輸入的金鑰
                musicSettings: {
                    src: null,
                    isPlaying: false,
                    playOnScreen: 'tribe', // 預設在部落畫面播放
                },
                //用於重生畫面的資料物件
                rebirth: {
                    name: '',
                    height: 0,
                    penisSize: 0,
                    appearance: '',
                    stats: { strength: 1, agility: 1, intelligence: 1, luck: 1 },
                    totalPoints: 0, // 總點數將在觸發重生時計算
                    get pointsRemaining() { 
                        return this.totalPoints - Object.values(this.stats).reduce((a, b) => a + b, 0); 
                    }
                },
                //觸發重生的函式
                initiateRebirth() {
                    this.logMessage('tribe', `${this.player.name} 在戰鬥中倒下了... 但哥布林的生命力讓你從死亡邊緣歸來！`, 'system');
                    
                    // 1. 計算總能力點數
                    const total = Object.values(this.player.stats).reduce((a, b) => a + b, 0);
                    this.rebirth.totalPoints = total;

                    // 2. 載入當前外觀設定
                    this.rebirth.name = this.player.name;
                    this.rebirth.height = this.player.height;
                    this.rebirth.penisSize = this.player.penisSize;
                    this.rebirth.appearance = this.player.appearance;

                    // 3. 預設將點數設為最低值 1，其餘為待分配
                    this.rebirth.stats = { strength: 1, agility: 1, intelligence: 1, luck: 1 };
                    
                    // 4. 切換至重生畫面
                    this.screen = 'rebirth';
                    this.showCustomAlert('你獲得了重塑自身的機會！');
                },

                //處理重生畫面點數分配的函式
                updateRebirthStat(stat, value) {
                    const intValue = parseInt(value);
                    if (!isNaN(intValue) && intValue >= 1) { // 確保點數至少為 1
                        this.rebirth.stats[stat] = intValue;
                    } else {
                        this.rebirth.stats[stat] = 1; // 如果輸入無效，則重設為 1
                    }
                },

                //確認重生設定的函式
                confirmRebirth() {
                    if (this.rebirth.pointsRemaining !== 0) {
                        this.showCustomAlert(`你還有 ${this.rebirth.pointsRemaining} 點能力點尚未分配！`);
                        return;
                    }

                    // 更新玩家資料
                    this.player.height = this.rebirth.height;
                    this.player.penisSize = this.rebirth.penisSize;
                    this.player.appearance = this.rebirth.appearance;
                    this.player.stats = this.rebirth.stats;

                    // 恢復狀態並返回部落
                    this.player.updateHp(this.isStarving);
                    this.player.currentHp = this.player.maxHp;
                    this.screen = 'tribe';
                    this.logMessage('tribe', '你重塑了肉體與靈魂，以全新的姿態重生！', 'success');
                },

                executeQuickBreeding() {
                    // --- 包含了所有繁衍的後台遊戲機制 ---
                    const selectedIds = this.modals.dungeon.selectedBreedIds;
                    const selectedCount = selectedIds.length;

                    selectedIds.forEach(id => {
                        const captive = this.captives.find(c => c.id === id);
                        if (captive && !captive.isPregnant) {
                            captive.isPregnant = true;
                            captive.pregnancyTimer = 3;
                            this.player.attributePoints++;
                        }
                    });

                    this.breedingChargesLeft -= selectedCount;
                    this.logMessage('tribe', `你與 ${selectedCount} 名女性快速進行了繁衍，獲得了 ${selectedCount} 點能力點。`, 'success');
                    
                    // 重置並關閉視窗
                    this.modals.dungeon.selectedBreedIds = [];
                    this.modals.construction.isOpen = false;
                    
                    // 繁衍會消耗一天
                    this.nextDay();
                },

                returnToBreedingModal(message) {
                    this.screen = 'tribe';
                    this.modals.construction.isOpen = true;
                    this.modals.construction.activeTab = 'dungeon';
                    this.modals.dungeon.subTab = 'breed';
                    this.showCustomAlert(message);
                },

                handleBreedingClick() {
                    // --- 這是按鈕點擊後的總控制器 ---

                    // 1. 先執行所有前置檢查
                    const selectedIds = this.modals.dungeon.selectedBreedIds;
                    const selectedCount = selectedIds.length;
                    if (selectedCount === 0) {
                        this.showCustomAlert('請至少選擇一名繁衍對象。');
                        return;
                    }
                    if (selectedCount > this.breedingChargesLeft) {
                        this.showCustomAlert(`繁衍次數不足！你只能選擇最多 ${this.breedingChargesLeft} 位。`);
                        return;
                    }
                    if (this.mothers.length + selectedCount > this.maternityCapacity) {
                        this.showCustomAlert(`產房空間不足！剩餘空間：${this.maternityCapacity - this.mothers.length}`);
                        return;
                    }

                    // 2. 智慧判斷：根據有無 API Key 決定流程
                    if (this.userApiKey && this.userApiKey.trim() !== '') {
                        // 如果有 Key，執行AI敘事流程
                        this.startBreedingNarrative();
                    } else {
                        // 如果沒有 Key，執行快速繁衍
                        this.executeQuickBreeding();
                    }
                },

                loadMusic(event) {
                    const file = event.target.files[0];
                    if (file) {
                        // 釋放舊的 URL 避免內存洩漏
                        if (this.musicSettings.src) {
                            URL.revokeObjectURL(this.musicSettings.src);
                        }
                        // 建立新的檔案 URL
                        this.musicSettings.src = URL.createObjectURL(file);
                        this.$refs.audioPlayer.src = this.musicSettings.src;
                        // 載入後，我們假設使用者想要播放，所以設定 isPlaying 為 true
                        this.musicSettings.isPlaying = true;
                        // 嘗試播放，並處理可能因瀏覽器限制而導致的自動播放失敗
                        this.$refs.audioPlayer.play().catch(e => {
                            console.warn("自動播放失敗，需要使用者手動互動。");
                            // 如果播放失敗，將狀態同步為 false
                            this.musicSettings.isPlaying = false;
                        });
                    }
                },

                toggleMusic() {
                    // 如果沒有音樂檔案，則不執行任何操作
                    if (!this.musicSettings.src) return;

                    // 根據 audio 元素的實際暫停狀態來切換
                    if (this.$refs.audioPlayer.paused) {
                        this.$refs.audioPlayer.currentTime = 0; // 【新增此行】將音樂拉回開頭
                        this.$refs.audioPlayer.play();
                        this.musicSettings.isPlaying = true;
                    } else {
                        this.$refs.audioPlayer.pause();
                        this.musicSettings.isPlaying = false;
                    }
                },
                musicSettings: {
                    src: null,
                    isPlaying: false,
                    playOnScreen: 'tribe', // 預設在部落畫面播放
                },
                day: 1,
                player: null,
                partners: [],
                captives: [],
                resources: { food: 200, wood: 200, stone: 200 },
                warehouseInventory: [], 
                buildings: {
                    dungeon: { level: 0, name: "地牢" },
                    warehouse: { level: 0, name: "倉庫" },
                    barracks: { level: 0, name: "寢室" },
                    armory: { level: 0, name: "兵工廠" },
                    maternity: { level: 0, name: "產房" },
                    trainingGround: { level: 0, name: "訓練場" }, 
                    merchantCamp: { level: 0, name: "商人營地" },
                },
                modals: {
                    construction: { isOpen: false, activeTab: 'dungeon' },
                    dungeon: { subTab: 'manage', selectedBreedIds: [] },
                    barracks: { subTab: 'manage', selectedPartyIds: [] },
                    partnerEquipment: { isOpen: false, partnerId: null, activeFilter: 'all' },
                    warehouse: { subTab: 'manage', activeFilter: 'all' },
                    armory: { subTab: 'craft', craftingType: '劍', craftingMaterial: 'iron' },
                    maternity: { subTab: 'manage' },
                    merchant: { isOpen: false },
                    scoutInfo: { isOpen: false, target: null, emptyBuildingMessage: '' },
                    captiveManagement: { isOpen: false, title: '', list: [], limit: 0, selectedIds: [], type: '', context: null },
                    narrative: { isOpen: false, title: '', content: '', isLoading: false, hasBred: false, context: [], currentCaptives: [], type: '', isAwaitingConfirmation: false },
                    customAlert: { isOpen: false, message: '', onConfirm: null },
                    discardConfirm: { isOpen: false, itemId: null, itemName: '' },
                    raidStatus: { isOpen: false, activeTab: 'status' },
                    throneScout: { isOpen: false, unit: null },
                    itemManagement: { isOpen: false, title: '', message: '', items: [], capacity: 0, onConfirm: null },
                    raidCaptives: { isOpen: false },
                    partnerManagement: { isOpen: false, list: [], limit: 0, selectedIds: [], newbornId: null, context: null },
                    bailoutConfirm: {
                        isOpen: false,
                        messages: [], // 要問的問題列表
                        currentMessageIndex: 0, // 當前問題的索引
                        onConfirm: null // 確認到底後要執行的動作
                    },
                },
                
                merchant: { 
                    dialogue: '', // 【新增此行】用來存放當前對話
                    throneRoomUnits: [],
                    isPresent: false,
                    goods: [],
                    stayDuration: 0,
                    purchases: 0, // 用於追蹤彩蛋
                    selectedItemIds: [], // 【修改】改為陣列以支援複選
                    selectedCaptiveIds: [],
                },

                isStarving: false,
                narrativeMemory: '',
                tutorial: {
                    active: false, // 總開關，判斷玩家是否需要教學
                    pendingTutorial: null, // 【新增】用於存放待處理的教學事件
                    // --- 以下為各教學模組的完成狀態旗標 ---
                    finishedIntro: false,         // 完成初級教學 (建築->掠奪->繁衍)
                    finishedPartyMgmt: false,     // 完成夥伴管理教學
                    finishedEquipping: false,     // 完成裝備教學
                    finishedDecomposing: false,   // 完成分解教學
                    finishedAttributePoints: false, // 完成屬性點教學
                    // 保留商人旗標
                    merchantMet: false
                },
                triggerTutorial(eventName) {
                    if (!this.tutorial.active) return;

                    // 【核心修改】如果玩家不在部落，則將教學事件暫存起來
                    if (this.screen !== 'tribe') {
                        this.tutorial.pendingTutorial = eventName;
                        return; // 暫不執行，等待玩家返回部落
                    }

                    // 如果玩家在部落，則正常執行教學
                    switch (eventName) {
                        case 'firstAttributePoint':
                            if (!this.tutorial.finishedAttributePoints) {
                                this.showCustomAlert('王，您因繁衍而變得更強，獲得了「能力點」！請在您的狀態欄中，點擊能力值旁邊發光的「+」按鈕來分配它，提升您的實力。');
                                this.tutorial.finishedAttributePoints = true;
                            }
                            break;
                        case 'firstBirth':
                            if (!this.tutorial.finishedPartyMgmt) {
                                this.showCustomAlert('恭喜！您的第一個孩子誕生了。請前往「部落建設」->「寢室」->「管理夥伴」，將他加入您的出擊隊伍，他將為您提供戰力加成！');
                                this.tutorial.finishedPartyMgmt = true;
                            }
                            break;
                        case 'firstLoot':
                            if (!this.tutorial.finishedEquipping) {
                                this.showCustomAlert('您獲得了第一件裝備！它被存放在「部落建設」->「倉庫」->「玩家背包」中。您可以將它裝備在自己或夥伴身上以增強戰力。');
                                this.tutorial.finishedEquipping = true;
                            }
                            break;
                        case 'armoryBuilt':
                            if (!this.tutorial.finishedDecomposing) {
                                this.showCustomAlert('兵工廠已建成！現在您可以將多餘或老舊的裝備「分解」成資源了。這在「倉庫」管理介面中進行操作。');
                                this.tutorial.finishedDecomposing = true;
                            }
                            break;
                    }
                    // 觸發後清除暫存
                    this.tutorial.pendingTutorial = null;
                },
                hasSaveFile: false,
                isGeneratingAvatar: false,
                tempStatIncreases: { strength: 0, agility: 0, intelligence: 0, luck: 0 },
                isNewGame: true, 
                postBattleBirths: [], 
                logs: {
                    tribe: [],
                    raid: [],
                    combat: []
                },
                playerMapPosition: { x: -100, y: -100 }, // 玩家在地圖上的位置，預設在畫面外
                selectedTarget: null, // 當前選中的目標 (建築或敵人)
                isCombatLocked: false, // 是否被巡邏隊鎖定，無法移動
                mapScale: 1, // 【新增此行】用於地圖縮放

                knightPositions: [ // <--- 請將這個陣列新增於此
                    { top: '40%', left: '50%' }, // V字頂點
                    { top: '50%', left: '40%' }, // 第二排左
                    { top: '50%', left: '60%' }, // 第二排右
                    { top: '60%', left: '30%' }, // 第三排左
                    { top: '60%', left: '70%' }, // 第三排右
                    { top: '70%', left: '20%' }, // 第四排左
                    { top: '70%', left: '80%' }, // 第四排右
                ],
                
                get warehouseCapacity() { 
                    const levels = [10, 20, 40, 80, 160];
                    // 修正：確保等級 0 時也有對應的值
                    return levels[this.buildings.warehouse.level] || 10;
                },
                get backpackCapacity() {
                    const levels = [10, 20, 40, 80, 160];
                    // 讓背包和倉庫容量同步增長
                    return levels[this.buildings.warehouse.level] || 10;
                },
                get captiveCapacity() { 
                    const levels = [0, 5, 10, 15, 20, 25, 30];
                    return this.buildings.dungeon.level < levels.length ? levels[this.buildings.dungeon.level] : 0;
                },
                get maternityCapacity() {
                    const levels = [0, 5, 10, 15, 20, 25, 30];
                    return this.buildings.maternity.level < levels.length ? levels[this.buildings.maternity.level] : 0;
                },
                get partnerCapacity() { 
                    const levels = [5, 10, 15, 20, 25, 30];
                    return this.buildings.barracks.level < levels.length ? levels[this.buildings.barracks.level] : 5;
                },
                get foodCapacity() { 
                    const levels = [200, 500, 1000, 2000, 4000];
                    return this.buildings.warehouse.level < levels.length ? levels[this.buildings.warehouse.level] : 200;
                },
                get woodCapacity() { return this.foodCapacity; },
                get stoneCapacity() { return this.foodCapacity; },
                get dailyFoodConsumption() {
                    if (!this.player) return 0;
                    const allMembers = [this.player, ...this.partners, ...this.captives];
                    return allMembers.reduce((total, member) => {
                        let statSum = member.stats.strength + member.stats.agility + member.stats.intelligence + member.stats.luck;
                        if (member.stats.charisma) {
                            statSum += member.stats.charisma;
                        }
                        return total + Math.floor(statSum / 10);
                    }, 0);
                },
                get totalBreedingCharges() {
                    if (!this.player) return 1;
                    // 【修改】將 getTotalStat('luck') 改為 stats.luck，只計算玩家本體原始點數
                    return 1 + Math.floor(this.player.stats.luck * 0.1);
                },
                get carryCapacity() {
                    if (!this.player) return 0;
                    return (this.player.party.length + 1) * 2;
                },
                get dungeonCaptives() {
                    return this.captives.filter(c => !c.isPregnant && !c.isMother);
                },
                get mothers() {
                    return this.captives.filter(c => c.isPregnant || c.isMother);
                },
                get potentialTrainingPoints() {
                    if (!this.player) return 0;
                    const rawStatSum = this.player.stats.strength + this.player.stats.agility + this.player.stats.intelligence + this.player.stats.luck;
                    return Math.floor(rawStatSum / 4);
                },
                get currentlyEditingPartner() {
                    if (!this.modals.partnerEquipment.partnerId) return null;
                    
                    // 【新增】判斷目標是否為玩家本人
                    if (this.modals.partnerEquipment.partnerId === 'player') {
                        return this.player;
                    }
                    
                    // 維持原有邏輯，尋找夥伴
                    return this.partners.find(p => p.id === this.modals.partnerEquipment.partnerId);
                },
                get filteredWarehouseInventory() {
                    const filter = this.modals.warehouse.activeFilter;
                    if (filter === 'all') return this.warehouseInventory;
                    return this.warehouseInventory.filter(item => {
                        if (filter === 'weapon') return item.slot === 'mainHand';
                        if (filter === 'shield') return item.baseName === '盾';
                        if (filter === 'armor') return item.slot === 'chest';
                        return true;
                    });
                },
                get filteredPlayerInventory() {
                    if (!this.player) {
                        return [];
                    }
                    const filter = this.modals.warehouse.activeFilter;
                    if (filter === 'all') return this.player.inventory;
                    return this.player.inventory.filter(item => {
                        if (filter === 'weapon') return item.slot === 'mainHand';
                        if (filter === 'shield') return item.baseName === '盾';
                        if (filter === 'armor') return item.slot === 'chest';
                        return true;
                    });
                },
                get filteredPartnerWarehouse() {
                    const filter = this.modals.partnerEquipment.activeFilter;
                    if (filter === 'all') return this.warehouseInventory;
                    return this.warehouseInventory.filter(item => {
                        if (filter === 'weapon') return item.slot === 'mainHand';
                        if (filter === 'shield') return item.baseName === '盾';
                        if (filter === 'armor') return item.slot === 'chest';
                        return true;
                    });
                },
                get filteredPartnerBackpack() {
                    if (!this.player) return [];
                    const filter = this.modals.partnerEquipment.activeFilter;
                    if (filter === 'all') return this.player.inventory;
                    return this.player.inventory.filter(item => {
                        if (filter === 'weapon') return item.slot === 'mainHand';
                        if (filter === 'shield') return item.baseName === '盾';
                        if (filter === 'armor') return item.slot === 'chest';
                        return true;
                    });
                },
                openPartnerEquipment(partnerId) {
                    this.modals.partnerEquipment.partnerId = partnerId;
                    this.modals.partnerEquipment.isOpen = true;
                },
                openPlayerEquipment() {
                    this.modals.partnerEquipment.partnerId = 'player'; // 將目標設為 'player'
                    this.modals.partnerEquipment.isOpen = true;
                },
                getUnitColor(unitOrGroup) {
                    const unit = Array.isArray(unitOrGroup) ? unitOrGroup[0] : unitOrGroup;
                    if (!unit) return 'bg-gray-500'; // 安全備用
                    if (unit.id === this.player.id) return 'bg-green-500';
                    if (unit.profession === '公主') return 'bg-yellow-400';
                    if (Object.keys(KNIGHT_ORDER_UNITS).includes(unit.profession)) return 'bg-orange-500';
                    if (unit.profession === '城市守軍') return 'bg-red-500';
                    return 'bg-white'; // 居民
                },
                handleMapClick(target, event) {
                    if (this.isCombatLocked) {
                        this.showCustomAlert('你被巡邏隊攔截了，必須先擊敗他們！');
                        return;
                    }
                    event.stopPropagation();

                    this.selectedTarget = target;

                    this.$nextTick(() => {
                        if (!this.selectedTarget) return; // 如果目標已清除，則不移動
                        
                        let anchorX, anchorY;
                        if (Array.isArray(this.selectedTarget)) {
                            anchorX = this.selectedTarget[0].x - 10; // 微調位置
                            anchorY = this.selectedTarget[0].y + 10; // 微調位置
                        } else {
                            anchorX = this.selectedTarget.x + (this.selectedTarget.width / 2) - 10;
                            anchorY = this.selectedTarget.y + this.selectedTarget.height;
                        }
                        this.playerMapPosition.x = anchorX;
                        this.playerMapPosition.y = anchorY;
                    });
                },

                getInteractionMenuPosition() {
                    if (!this.selectedTarget) return 'left: -999px; top: -999px;'; // 如果沒有目標，則移出畫面外

                    const menuWidth = 100;
                    const menuHeight = 80;
                    const offsetX = 10;
                    const offsetY = 10;

                    let anchorX, anchorY;
                    if (Array.isArray(this.selectedTarget)) {
                        anchorX = this.selectedTarget[0].x;
                        anchorY = this.selectedTarget[0].y;
                    } else {
                        anchorX = this.selectedTarget.x + (this.selectedTarget.width / 2);
                        anchorY = this.selectedTarget.y + this.selectedTarget.height;
                    }

                    let targetX = anchorX + offsetX;
                    let targetY = anchorY - offsetY - menuHeight;

                    if (targetX + menuWidth > MAP_WIDTH) {
                        targetX = anchorX - offsetX - menuWidth;
                    }
                    if (targetY < 0) {
                        targetY = anchorY + offsetY;
                    }

                    return `left:${targetX}px; top:${targetY}px;`;
                },

                executeBuildingScout(building) {
                    if (building.isFinalChallenge) {
                        if (building.scouted) {
                            this.showCustomAlert('城堡深處的氣息令人不寒而慄，你已準備好深入王座之間。');
                            return;
                        }
                        this.logMessage('raid', '你開始偵查宏偉的城堡...', 'player');
                        this.currentRaid.timeRemaining -= 3;
                        building.scouted = true;
                        this.logMessage('raid', '偵查成功！一股強大且混雜的氣息從城堡深處傳來...你現在可以「深入內城」前往「王座之間」了。', 'success');
                        this.checkRaidTime();
                        return;
                    }
                    if (building.scouted) {
                        if (building.occupants.length > 0) {
                            this.modals.scoutInfo.target = building.occupants;
                        } else {
                            this.modals.scoutInfo.target = [];
                            this.modals.scoutInfo.emptyBuildingMessage = building.looted 
                                ? '這棟建築是空的，你已搜刮過。' 
                                : '這棟建築是空的，看來可以搜刮一番。';
                        }
                        this.modals.scoutInfo.isOpen = true;
                        return;
                    }

                    this.logMessage('raid', `你開始偵查 ${building.type}...`, 'player');
                    const playerIntel = this.player.getTotalStat('intelligence', this.isStarving);
                    const successChance = 80 + playerIntel * 0.5;

                    if (roll(successChance)) {
                        this.currentRaid.timeRemaining -= 3;
                        building.scouted = true;
                        this.logMessage('raid', `偵查成功！`, 'success');

                        if (building.occupants.length > 0) {
                            building.postScoutText = ` (${building.occupants.length}人)`;
                            this.modals.scoutInfo.target = building.occupants;
                        } else {
                            building.postScoutText = building.looted ? ' (空)' : ' (可搜刮)';
                            this.modals.scoutInfo.target = [];
                            this.modals.scoutInfo.emptyBuildingMessage = building.looted 
                                ? '這棟建築是空的，你已搜刮過。' 
                                : '這棟建築是空的，看來可以搜刮一番。';
                        }
                        this.modals.scoutInfo.isOpen = true;
                    } else {
                        this.currentRaid.timeRemaining -= 6;
                        this.logMessage('raid', `偵查 ${building.type} 失敗，你一無所獲。`, 'enemy');
                    }
                    this.checkRaidTime();
                },
                
                closeScoutModalAndClearTarget() {
                    this.modals.scoutInfo.isOpen = false;
                    this.selectedTarget = null;
                },

                startCombatFromScout(enemyGroup) {
                    if (enemyGroup && enemyGroup.length > 0) {
                        this.startCombat(enemyGroup);
                        this.modals.scoutInfo.isOpen = false;
                        this.selectedTarget = null;
                    }
                },

                startCombatFromModal() {
                    if (this.selectedTarget && !Array.isArray(this.selectedTarget) && this.selectedTarget.occupants) {
                        this.startCombat(this.selectedTarget.occupants);
                        this.modals.scoutInfo.isOpen = false;
                        this.selectedTarget = null;
                    }
                },

                lootBuildingFromModal() {
                    if (this.selectedTarget && !Array.isArray(this.selectedTarget)) {
                        this.lootBuilding(this.selectedTarget);
                        this.modals.scoutInfo.isOpen = false;
                        this.selectedTarget = null;
                    }
                },

                executeTraining(partnerId) {
                    const partner = this.partners.find(p => p.id === partnerId);
                    if (!partner || partner.hasBeenTrained) {
                        this.showCustomAlert("此夥伴無法被訓練。");
                        return;
                    }

                    const pointsGained = this.potentialTrainingPoints;
                    if (pointsGained <= 0) {
                        this.showCustomAlert("以王您現在的狀態，無法為夥伴帶來任何提升。");
                        return;
                    }

                    const statKeys = ['strength', 'agility', 'intelligence', 'luck'];
                    let pointDistributionLog = { strength: 0, agility: 0, intelligence: 0, luck: 0 };

                    for (let i = 0; i < pointsGained; i++) {
                        const randomStat = statKeys[randomInt(0, 3)];
                        partner.stats[randomStat]++;
                        pointDistributionLog[randomStat]++;
                    }

                    partner.hasBeenTrained = true;

                    // 【新增】在屬性增加後，立刻更新夥伴的生命值
                    partner.updateHp(this.isStarving);

                    this.logMessage('tribe', `你花費了一整天時間，對 ${partner.name} 進行了嚴格的訓練！`, 'player');
                    const logDetails = Object.entries(pointDistributionLog)
                        .filter(([stat, value]) => value > 0)
                        .map(([stat, value]) => `${STAT_NAMES[stat]} +${value}`)
                        .join(', ');
                    this.logMessage('tribe', `${partner.name} 的潛力被激發了：${logDetails}。`, 'success');
                    
                    // 【新增】顯示一個包含詳細結果的提示框
                    this.showCustomAlert(`${partner.name} 的訓練完成了！\n獲得的能力提升：\n${logDetails}`);

                    this.nextDay(); // 訓練消耗一天
                },

                calculateEquipmentValue(item) {
                    if (!item) return 0;
                    const damage = item.stats.damage || 0;
                    const hp = item.stats.hp || 0;
                    // 根據GDD: 裝備價值 = (裝備總傷害 × 6) + 裝備總生命值
                    return (damage * 6) + hp;
                },
                calculateCaptiveValue(captive) {
                    if (!captive) return 0;
                    const hp = captive.calculateMaxHp();
                    // 根據GDD: 俘虜價值 = 該俘虜當前總生命值 × 1.5
                    return Math.floor(hp * 1.5);
                },
                // 【修改】重新命名並修改邏輯以處理陣列
                get selectedItems() {
                    if (!this.merchant.selectedItemIds || this.merchant.selectedItemIds.length === 0) return [];
                    const selectedSet = new Set(this.merchant.selectedItemIds);
                    return this.merchant.goods.filter(g => selectedSet.has(g.id));
                },
                // 【修改】重新命名並修改邏輯以計算總和
                get selectedItemsValue() {
                    return this.selectedItems.reduce((total, item) => total + this.calculateEquipmentValue(item), 0);
                },
                get selectedCaptivesValue() {
                    return this.merchant.selectedCaptiveIds.reduce((total, id) => {
                        const captive = this.dungeonCaptives.find(c => c.id === id);
                        return total + (captive ? this.calculateCaptiveValue(captive) : 0);
                    }, 0);
                },
                get canExecuteTrade() {
                    // 【修改】更新判斷條件以適應複選
                    return this.merchant.selectedItemIds.length > 0 && this.merchant.selectedCaptiveIds.length > 0 && this.selectedCaptivesValue >= this.selectedItemsValue;
                },
                // 【新增】根據商店狀態更新商人對話的函式
                updateMerchantDialogue() {
                    if (this.merchant.goods.length === 0) {
                        this.merchant.dialogue = "「哎呀...這麼想我嗎？會有下次的」";
                    } else {
                        this.merchant.dialogue = "「嘿嘿嘿...哥布林王...今天有什麼「好貨」？買點好東西嗎？」";
                    }
                },

                // 【新增】打開商人介面的準備函式
                openMerchant() {
                    this.updateMerchantDialogue(); // 先設定好初始對話
                    this.modals.merchant.isOpen = true; // 再打開介面
                },
                executeTrade() {
                    if (!this.canExecuteTrade) {
                        this.showCustomAlert("交易條件不滿足！");
                        return;
                    }

                    const tradedItems = this.selectedItems;
                    const tradedItemIds = new Set(this.merchant.selectedItemIds);
                    const tradedCaptiveIds = new Set(this.merchant.selectedCaptiveIds);

                    // 【修正】使用深拷貝複製物品，而不是直接轉移物件參照
                    const newItemsForPlayer = JSON.parse(JSON.stringify(tradedItems));
                    this.player.inventory.push(...newItemsForPlayer);
                    this.logMessage('tribe', `你用俘虜換來了 ${tradedItems.length} 件裝備！`, 'success');

                    const tradedCaptives = this.captives.filter(c => tradedCaptiveIds.has(c.id));
                    this.captives = this.captives.filter(c => !tradedCaptiveIds.has(c.id));
                    this.logMessage('tribe', `你失去了 ${tradedCaptives.map(c => c.name).join(', ')} 這 ${tradedCaptives.length} 名俘虜。`, 'info');

                    this.merchant.goods = this.merchant.goods.filter(g => !tradedItemIds.has(g.id));
                    this.merchant.selectedItemIds = [];
                    this.merchant.selectedCaptiveIds = [];

                    // 【核心修改】根據交易後的狀態更新對話
                    if (this.merchant.goods.length === 0) {
                        // 如果商品被買完了
                        this.merchant.dialogue = "「真是大手筆，歡迎下次再來」";
                    } else {
                        // 如果還有商品
                        this.merchant.dialogue = "「眼光不錯，這裝備肯定能成為助力」";
                        // 讓這句「反應式對話」停留 4 秒後，再恢復成預設對話
                        setTimeout(() => {
                            this.updateMerchantDialogue();
                        }, 4000);
                    }

                    // 5. 處理彩蛋計數
                    this.merchant.purchases++;
                    if (this.merchant.purchases === 47) {
                        const shijiClone = new FemaleHuman(
                            '世紀的分身', 
                            { strength: 47, agility: 47, intelligence: 47, luck: 47, charisma: 201 },
                            '魅魔',
                            { hairColor: '深棕色', hairStyle: '波波頭', height: 168, age: '未知', bust: 'E', personality: '悶騷', clothing: '魅魔裝' }
                        );
                        this.captives.push(shijiClone);
                        this.showCustomAlert("「呵...你很懂『交易』嘛...。這個福利就送給你，哥布林王...」你發現一名特殊的魅魔出現在了你的地牢中！");
                        this.logMessage('tribe', `你達成了與「世紀」的第47次交易，獲得了特殊俘虜 [世紀的分身]！`, 'system');
                    }
                },

                breedingChargesLeft: 0,
                
                currentRaid: null,
                combat: { allies: [], enemies: [], turn: 0, log: [], isProcessing: false, currentEnemyGroup: [], playerActionTaken: false, isReinforcementBattle: false },
                
                submitApiKey() {
                    if (this.userApiKey && this.userApiKey.trim() !== '') {
                        localStorage.setItem('goblinKingApiKey', this.userApiKey);
                        this.showCustomAlert('API 金鑰已儲存！');
                    }
                    this.proceedToGame();
                },
                loadApiKey() {
                    const savedKey = localStorage.getItem('goblinKingApiKey');
                    if (savedKey) {
                        this.userApiKey = savedKey;
                    }
                },
                prepareIntroNarrative() {
                    const modal = this.modals.narrative;
                    modal.isAwaitingConfirmation = true;
                    modal.isLoading = false;
                    modal.content = '';
                    this.screen = 'intro';
                },
                proceedToGame() {
                    this.screen = 'creation'; // 直接跳到創角
                    // 如果玩家是第一次玩（沒有存檔），則準備序章故事
                    if (!this.player) {
                        this.prepareIntroNarrative();
                    }
                },

                init() {
                    this.loadApiKey();
                    this.logMessage('tribe', "哥布林王國v5.00 初始化...");
                    this.checkForSaveFile();
                    if (!this.player) {
                        this.generateIntroNarrative();
                    }
                    this.$watch('screen', (newScreen) => {
                        // 當玩家回到部落畫面，且有待辦事項時
                        if (newScreen === 'tribe' && this.pendingDecisions.length > 0) {
                            // 使用 setTimeout 確保畫面已完全切換，避免彈窗閃爍
                            setTimeout(() => this.processNextDecision(), 100);
                        }
                    });
                    this.$watch('modals.construction.isOpen', (isOpen) => {
                        // 當建築介面被關閉 (isOpen 變為 false)
                        // 且玩家剛好處於「拒絕過幫助」的狀態
                        if (!isOpen && this.bailoutOfferedButRefused) {
                            // 重置旗標
                            this.bailoutOfferedButRefused = false; 
                            // 延遲一小段時間再觸發，避免視窗閃爍
                            setTimeout(() => {
                                this.handleBailoutRequest();
                            }, 200);
                        }
                    });
                    this.$watch('modals.construction.isOpen', (isOpen) => {
                        if (isOpen && this.player && this.modals.construction.activeTab === 'barracks') {
                            this.modals.barracks.selectedPartyIds = this.player.party.map(p => p.id);
                        }
                    });
                    this.$watch('modals.construction.activeTab', (newTab) => {
                        if (newTab === 'barracks' && this.player) {
                            this.modals.barracks.selectedPartyIds = this.player.party.map(p => p.id);
                        }
                    });

                    // 【智慧播放監聽器】
                    this.$watch('screen', (newScreen) => {
                        // 當前畫面符合設定時，且音樂是播放狀態，就播放
                        if (newScreen === this.musicSettings.playOnScreen && this.musicSettings.isPlaying) {
                            if (this.$refs.audioPlayer.paused) {
                                this.$refs.audioPlayer.currentTime = 0; // 【新增此行】將音樂拉回開頭
                                this.$refs.audioPlayer.play().catch(e => {});
                            }
                        } else { // 否則就暫停
                            if (!this.$refs.audioPlayer.paused) {
                                this.$refs.audioPlayer.pause();
                            }
                        }
                    });
                },

                creation: {
                    name: '哥布林王', height: 130, penisSize: 10,
                    appearance: '有著一對尖耳朵、狡猾的眼神、戴著骨頭項鍊的綠皮膚哥布林',
                    stats: { strength: 10, agility: 10, intelligence: 10, luck: 10 },
                    statWarningMessage: '',
                    lowStatWarnings: {},
                    get pointsRemaining() { return 40 - Object.values(this.stats).reduce((a, b) => a + b, 0); }
                },
                
                updateStat(stat, value) {
                    const intValue = parseInt(value);
                    if (!isNaN(intValue)) {
                        this.creation.stats[stat] = intValue;
                        this.checkStatValue(stat, intValue);
                    }
                },
                checkStatValue(stat, value) {
                    const intValue = parseInt(value);

                    if (isNaN(intValue)) {
                        this.creation.stats[stat] = 0;
                    } else {
                        this.creation.stats[stat] = intValue;
                    }

                    const zeroStatCount = Object.values(this.creation.stats).filter(v => v <= 0).length;

                    if (zeroStatCount >= 3) {
                        this.creation.statWarningMessage = "只是路過的蒙面哥布林..."; // GDD 4.1
                    } else if (zeroStatCount === 2) {
                        this.creation.statWarningMessage = "Trans-Goblin..."; // GDD 4.1
                    } else if (zeroStatCount === 1) {
                        const zeroStatKey = Object.keys(this.creation.stats).find(key => this.creation.stats[key] <= 0);
                        switch(zeroStatKey) {
                            case 'strength': this.creation.statWarningMessage = "一武洋ㄎ...都能O死你，我不確定你還能站著..."; break;
                            case 'agility': this.creation.statWarningMessage = "希望你跟霍ㄐ...一樣有輪椅（這邊好像不該出現這個詞..."; break;
                            case 'intelligence': this.creation.statWarningMessage = "我不清楚哥布林能不能理解你，但我肯定不行..."; break;
                            case 'luck': this.creation.statWarningMessage = "自古槍兵幸運E，你沒自殺是奇蹟..."; break;
                        }
                    } else {
                        const hasLowStat = Object.values(this.creation.stats).some(v => v > 0 && v <= 4);
                        if (hasLowStat) {
                            this.creation.statWarningMessage = "我建議你不要，如果你仍執意...";
                        } else {
                            this.creation.statWarningMessage = '';
                        }
                    }
                },
                async createCharacter() {
                    this.player = new Player(this.creation.name, this.creation.stats, this.creation.appearance, this.creation.height, this.creation.penisSize);
                    const encodedName = encodeURIComponent(this.player.name);
                    this.player.avatarUrl = `https://placehold.co/400x400/2d3748/cbd5e0?text=哥布林王\\n${encodedName}`;

                    // 【核心修改】先切換畫面
                    this.screen = 'birth_narrative';

                    // 【核心修改】然後使用 $nextTick 確保新畫面渲染完成後，再設定其內部狀態
                    this.$nextTick(() => {
                        const modal = this.modals.narrative;
                        modal.isAwaitingConfirmation = true;
                        modal.isLoading = false;
                        modal.content = '';
                    });
                },
                
                initializeTribe() {
                    if (!this.isNewGame) return;
                    this.isNewGame = false;

                    const starterSword = this.createEquipment('iron', 'worn', '劍');
                    const starterArmor = this.createEquipment('iron', 'worn', '鎧甲');
                    this.player.inventory.push(starterSword);
                    this.player.inventory.push(starterArmor);
                    
                    this.logMessage('tribe', `你在空無一人的破舊部落中醒來，在一個腐朽的箱子裡發現了[${starterSword.name}]和[${starterArmor.name}]。`, 'system');

                    const zeroStats = Object.keys(this.player.stats).filter(stat => ['strength', 'agility', 'intelligence', 'luck'].includes(stat) && this.player.stats[stat] === 0);
                    const zeroStatCount = zeroStats.length;
                    let itemToGenerate = null;

                    if (zeroStatCount >= 3) {
                        itemToGenerate = {
                            slot: 'chest',
                            baseName: '鎧甲',
                            affix: 'henshin_curse',
                            alert: '你感覺自己彷彿能變身成什麼，身上憑空出現了一件鎧甲...'
                        };
                    } else if (zeroStatCount === 2) {
                        itemToGenerate = {
                            slot: 'offHand',
                            baseName: '盾',
                            affix: 'gundam_curse',
                            alert: '你感覺自己內心深處的某種東西覺醒了，手中憑空出現了一面盾...'
                        };
                    } else if (zeroStatCount === 1) {
                        const stat = zeroStats[0];
                        const itemMap = {
                            strength: { baseName: '劍', affix: 'strength_curse', alert: '你感覺身體格外虛弱，但手中憑空出現了一把劍...' },
                            agility: { baseName: '弓', affix: 'agility_curse', alert: '你感覺身體格外遲鈍，但手中憑空出現了一把弓...' },
                            intelligence: { baseName: '法杖', affix: 'intelligence_curse', alert: '你感覺思緒一片混沌，但手中憑空出現了一把法杖...' },
                            luck: { baseName: '長槍', affix: 'luck_curse', alert: '你感覺厄運纏身，但手中憑空出現了一把長槍...' },
                        };
                        if (itemMap[stat]) {
                            itemToGenerate = { slot: 'mainHand', ...itemMap[stat] };
                        }
                    }

                    const startTribeActions = () => {
                        if (itemToGenerate) {
                            const cursedItem = this.createEquipment('iron', 'worn', itemToGenerate.baseName, itemToGenerate.affix);
                            this.player.equipment[itemToGenerate.slot] = cursedItem;
                            this.logMessage('tribe', `你獲得了受詛咒的裝備：[${cursedItem.name}]！`, 'system');
                            this.player.updateHp();
                        }

                        if (this.tutorial.active) {
                            this.advanceTutorial(1);
                        } else {
                            this.logMessage('tribe', `第 ${this.day} 天：偉大的哥布林王 ${this.player.name} 的傳奇開始了！`, 'system');
                        }
                    };

                    if (itemToGenerate) {
                        this.showCustomAlert(itemToGenerate.alert, startTribeActions);
                    } else {
                        startTribeActions();
                    }
                    this.breedingChargesLeft = this.totalBreedingCharges;

                    if (this.tutorial.pendingTutorial) {
                        this.triggerTutorial(this.tutorial.pendingTutorial);
                    }
                },
                startTutorial(choice) {
                this.tutorial.active = choice;
                this.screen = 'tribe'; // 只切換畫面，初始化交給 x-init
                },
                advanceTutorial(step) {
                    this.tutorial.step = step;
                    switch(step) {
                        // 【修改】步驟1: 僅作為一次性的裝備提示，確認後直接推進到步驟2
                        case 1:
                            this.showCustomAlert(
                                '你在部落中發現了一些基礎裝備！你可以隨時在「部落建設」->「倉庫」->「玩家背包」中找到並穿上它們。',
                                () => { this.advanceTutorial(2); } // 點擊確認後，立即執行下一步教學
                            );
                            break;
                        // 【修改】步驟2: 引導點擊「部落建設」
                        case 2:
                            this.showCustomAlert('一個強大的部落需要穩固的根基。讓我們點擊發光的『部落建設』按鈕，來規劃您的部落。');
                            break;
                        // 【修改】步驟3: 引導建造「地牢」
                        case 3:
                            this.modals.construction.isOpen = true;
                            this.modals.construction.activeTab = 'dungeon';
                            this.modals.dungeon.subTab = 'upgrade';
                            this.showCustomAlert('做得好！現在請點擊發光的『升級』分頁，並為您的部落打下第一個根基。');
                            break;
                        // 【修改】步驟4: 引導建造「產房」
                        case 4:
                            this.modals.construction.activeTab = 'maternity';
                            this.modals.maternity.subTab = 'upgrade';
                            break;
                        // 【修改】步驟5: 引導「出擊掠奪」
                        case 5:
                            this.modals.construction.isOpen = false;
                            setTimeout(() => {
                                this.showCustomAlert('太棒了！所有基礎設施都已就緒。關閉此視窗，點擊發光的『出擊掠奪』為部落帶來第一批女性吧！');
                            }, 100);
                            break;
                        // ... 後續步驟 5.5, 6, 7 維持不變 ...
                        case 5.5: 
                            this.showCustomAlert('王，知己知彼，百戰不殆。在未知的土地上，首先使用『偵查環境』來探查周遭的危險與機遇吧。');
                            break;
                        case 6:
                            this.showCustomAlert('恭喜王！您帶回了部落的第一批戰利品。現在，再次進入「部落建設」，找到「地牢」中的「繁衍後代」功能。您可以根據剩餘次數，選擇一位或多位對象，為您的部落產下更強大的哥布林戰士吧！');
                            break;
                        case 7:
                            const modal = this.modals.narrative;
                            modal.isOpen = true;
                            modal.title = "與神秘商人的相遇";
                            modal.type = "tutorial"; 
                            modal.isLoading = false;
                            modal.isAwaitingConfirmation = false;
                            modal.content = `
                                <p>呵呵...哥布林王...我有很多好東西...。</p>
                                <p>叫我『世紀』就好，一個四處遊蕩，尋找『有趣』事物的旅行商人，絕對不是什麼可疑的人，嘿...。</p>
                                <br>
                                <p>把那些抓來的妹子...嘿嘿...給ㄨㄛ...咳!我是說交易，會給你一些收藏的寶貝作為回報。</p>
                                <br>
                                <p><b>左邊是我的商品，右邊是你的『貨幣』(你懂的...)。選好商品，再湊齊足夠素質的俘虜，就能完成交易了。</b></p>
                                <br>
                                <p>很簡單吧？我很期待...嘿嘿嘿...(口水)</p>
                            `;
                            break;
                    }
                },
                executeBailout() {
                    this.resources.food = 200;
                    this.resources.wood = 200;
                    this.resources.stone = 200;
                    this.modals.bailoutConfirm.isOpen = false;
                    // 使用 setTimeout 確保提示框在對話框關閉後再弹出
                    setTimeout(() => {
                        this.showCustomAlert('世紀「真是拿你沒辦法…資源已經恢復了。快去「部落建設」裡，優先建造「地牢」和「產房」吧！」');
                    }, 100);
                },
                // 處理拒絕求助的函式
                refuseBailout() {
                    this.bailoutOfferedButRefused = true;
                    this.modals.bailoutConfirm.isOpen = false;
                },
                // 處理求助對話框的確認步驟
                confirmBailoutStep() {
                    const modal = this.modals.bailoutConfirm;
                    modal.currentMessageIndex++;
                    // 如果還有下一個問題，就繼續問
                    if (modal.currentMessageIndex < modal.messages.length) {
                        // 這部分會讓 modal 的內容更新為下一個問題
                    } else {
                        // 所有問題都回答「是」了，執行最終的確認動作
                        if (typeof modal.onConfirm === 'function') {
                            modal.onConfirm();
                        }
                    }
                },

                // 【新增】啟動求助流程的主函式
                handleBailoutRequest() {
                    this.bailoutCounter++; // 求助次數+1
                    const modal = this.modals.bailoutConfirm;
                    
                    let questions = ["世紀「你是否承認自己跳過新手教學很呆?」"];
                    const extraQuestions = ["世紀「真的嗎?」", "世紀「你確定?」", "世紀「沒有一點遲疑?」", "世紀「好吧，既然你都說到這個份上了...」", "世紀「最後一次機會囉?」", "世紀「我是誰?先回答你是不是呆瓜比較重要」", "世紀「我是誰?你之後就知道了。所以你是呆瓜嗎?」", "世紀「嘿...你不是第一次對吧?」", "世紀「嘿...騙我的話，我會知道的。你是呆瓜嗎?」"];
                    
                    // 根據求助次數，決定要問幾次問題
                    for (let i = 0; i < this.bailoutCounter; i++) {
                        questions.push(extraQuestions[i % extraQuestions.length]); // 循環使用額外問題
                    }

                    modal.messages = questions;
                    modal.currentMessageIndex = 0;
                    modal.onConfirm = () => this.executeBailout();
                    modal.isOpen = true;
                },

                handleConstructionClick() {
                    this.modals.construction.isOpen = true;

                    // 【修改】對應新的步驟編號，現在檢查步驟2
                    if (this.tutorial.active && this.tutorial.step === 2) {
                        setTimeout(() => {
                            this.advanceTutorial(3); // 推進到步驟3
                        }, 100);
                    }
                },
                
                handleRaidButtonClick() {
                    const canRaid = this.buildings.dungeon.level > 0 && this.buildings.maternity.level > 0;

                    if (canRaid) {
                        this.screen = 'raid_selection';
                        return;
                    }
                    
                    // 【核心修改】無論如何，先彈出正常的提示
                    this.showCustomAlert('必須先建造「地牢」與「產房」，為掠奪來的俘虜和新生兒做好準備，才能出擊！', () => {
                        // 這個函式會在玩家按下提示框的「確定」後執行
                        const isStuck = (this.buildings.dungeon.level === 0 || this.buildings.maternity.level === 0) &&
                                      (this.resources.food < 200 || this.resources.wood < 200 || this.resources.stone < 200);

                        if (isStuck) {
                            this.handleBailoutRequest();
                        }
                    });
                },
                // 請在您的程式碼中新增這個函式
                continueNextDay() {
                    // --- 商人來訪邏輯 ---
                    if (this.merchant.isPresent) {
                        this.merchant.stayDuration--;
                        if (this.merchant.stayDuration <= 0) {
                            this.logMessage('tribe', '旅行商人「世紀」已經收拾行囊，離開了你的部落。', 'info');
                            this.merchant = {
                                dialogue: '',
                                isPresent: false,
                                goods: [],
                                stayDuration: 0,
                                purchases: this.merchant.purchases,
                                selectedItemIds: [],
                                selectedCaptiveIds: [],
                            };
                        }
                    } else {
                        if (this.day === 9 && !this.tutorial.merchantMet) {
                            this.merchant.isPresent = true;
                            this.merchant.stayDuration = 1 + (this.buildings.merchantCamp.level || 0);
                            this.generateMerchantGoods();
                            this.logMessage('tribe', `一位名叫「世紀」的魅魔商人來到了你的營地！她將停留 ${this.merchant.stayDuration} 天。`, 'success');
                            this.advanceTutorial(7); // 這裡的教學步驟是7，不是6
                            this.tutorial.merchantMet = true;
                        } else if (this.day > 9) {
                            const arrivalChance = [10, 15, 20, 25, 30][this.buildings.merchantCamp.level || 0] || 10;
                            if (roll(arrivalChance)) {
                                this.merchant.isPresent = true;
                                this.merchant.stayDuration = 1 + (this.buildings.merchantCamp.level || 0);
                                this.generateMerchantGoods();
                                this.logMessage('tribe', `一位名叫「世紀」的魅魔商人來到了你的營地！她將停留 ${this.merchant.stayDuration} 天。`, 'success');
                            }
                        }
                    }

                    // --- 日常事件 ---
                    this.day++;
                    this.logMessage('tribe', `--- 第 ${this.day} 天 ---`, 'system');
                    
                    this.captives.forEach(c => {
                        if (c.isPregnant) {
                            c.pregnancyTimer--;
                            if (c.pregnancyTimer <= 0) {
                                this.giveBirth(c);
                            }
                        }
                    });

                    const milkProduced = this.mothers.filter(m => !m.isPregnant).reduce((total, mother) => {
                        return total + Math.floor((mother.stats.charisma || 0) * 1);
                    }, 0);
                    if (milkProduced > 0) {
                        this.resources.food += milkProduced;
                        this.logMessage('tribe', `產房的孕母們生產了 ${milkProduced} 單位食物。`, 'success');
                    }
                    
                    this.resources.food -= this.dailyFoodConsumption;
                    if (this.resources.food < 0) {
                        if (!this.isStarving) {
                            this.logMessage('tribe', `食物不足！部落成員陷入飢餓狀態，所有能力下降25%！`, 'enemy');
                            this.isStarving = true;
                        }
                        this.resources.food = 0;
                    } else {
                        if (this.isStarving) {
                            this.logMessage('tribe', `食物充足，飢餓狀態解除了。`, 'success');
                            this.isStarving = false;
                        }
                    }
                    
                    this.player.updateHp(this.isStarving);
                    this.partners.forEach(p => {
                        p.maxHp = p.calculateMaxHp(this.isStarving);
                        p.currentHp = Math.min(p.currentHp, p.maxHp);
                    });

                    this.breedingChargesLeft = this.totalBreedingCharges;
                },

                // 請用以下程式碼替換您原本的 nextDay 函式
                nextDay() {
                    // --- 事件偵測階段 ---
                    let pendingRevengeInfo = null;
                    let pendingBirths = [];

                    // 1. 偵測復仇小隊
                    const captivesByDifficulty = {};
                    this.captives.forEach(c => {
                        if (!captivesByDifficulty[c.originDifficulty]) {
                            captivesByDifficulty[c.originDifficulty] = 0;
                        }
                        captivesByDifficulty[c.originDifficulty]++;
                    });

                    for (const difficulty in captivesByDifficulty) {
                        if (pendingRevengeInfo) break;
                        const count = captivesByDifficulty[difficulty];
                        const coefficient = REVENGE_DIFFICULTY_COEFFICIENT[difficulty] || 0;
                        const triggerChance = count * coefficient;

                        if (roll(triggerChance)) {
                            pendingRevengeInfo = { difficulty: difficulty };
                        }
                    }

                    // 2. 偵測新生兒 (僅用於傳遞)
                    this.captives.forEach(c => {
                        if (c.isPregnant) {
                            c.pregnancyTimer--;
                            if (c.pregnancyTimer <= 0) {
                                pendingBirths.push(c);
                            } else {
                                // 將還沒到時間的 timer 加回去，避免重複計算
                                c.pregnancyTimer++; 
                            }
                        }
                    });

                    if (pendingRevengeInfo) {
                        this.logMessage('tribe', `你從 ${pendingRevengeInfo.difficulty} 城鎮掠來的俘虜似乎引來了追兵...`, 'enemy');
                        this.triggerRevengeSquadBattle(pendingRevengeInfo.difficulty, pendingBirths);
                        return; // 中斷後續所有普通事件，交由戰鬥結束後處理
                    }

                    // 如果沒有復仇事件，則執行正常的日常流程
                    this.continueNextDay();
                },
                
                getBuildingUpgradeCost(type) {
                    const building = this.buildings[type];
                    if (!building) return { food: 0, wood: 0, stone: 0};
                    const level = building.level;
                    const multiplier = Math.pow(2, level); // GDD註：地牢、倉庫、寢室、產房升級費用為前一級的兩倍

                    switch(type) {
                        case 'dungeon':
                            if (level >= 6) return { food: Infinity, wood: Infinity, stone: Infinity };
                            return { food: 50 * multiplier, wood: 100 * multiplier, stone: 100 * multiplier };
                        case 'maternity':
                            if (level >= 6) return { food: Infinity, wood: Infinity, stone: Infinity };
                            return { food: 50 * multiplier, wood: 100 * multiplier, stone: 100 * multiplier };
                        case 'warehouse':
                            if (level >= 4) return { food: Infinity, wood: Infinity, stone: Infinity };
                            return { food: 0, wood: 100 * multiplier, stone: 100 * multiplier }; // 初始花費 100木, 100礦
                        case 'barracks':
                            if (level >= 5) return { food: Infinity, wood: Infinity, stone: Infinity };
                            if (level === 0) return { food: 100, wood: 150, stone: 150 }; // 初始花費
                             return { food: 100 * multiplier, wood: 150 * multiplier, stone: 150 * multiplier }; // 升級花費
                        case 'armory':
                            if (level >= 4) return { food: Infinity, wood: Infinity, stone: Infinity };
                            if (level === 0) return { food: 0, wood: 150, stone: 150 };
                            return { food: 0, wood: 150 * multiplier, stone: 150 * multiplier }; // 兵工廠升級費用沒有明確規則，暫定為兩倍
                        case 'trainingGround':
                            if (level === 0) return { food: 200, wood: 150, stone: 150 };
                            return { food: Infinity, wood: Infinity, stone: Infinity }; // 訓練場無法升級
                        case 'merchantCamp':
                             if (level >= 4) return { food: Infinity, wood: Infinity, stone: Infinity };
                            if (level === 0) return { food: 200, wood: 200, stone: 200 };
                            return { food: 200 * multiplier, wood: 200 * multiplier, stone: 200 * multiplier }; // 商人營地升級費用沒有明確規則，暫定為兩倍
                        default:
                            return {food: 0, wood: 0, stone: 0};
                    }
                },
                canAffordBuildingUpgrade(type) {
                    const cost = this.getBuildingUpgradeCost(type);
                    const foodCost = cost.food || 0;
                    return this.resources.food >= foodCost && this.resources.wood >= cost.wood && this.resources.stone >= cost.stone;
                },
                upgradeBuilding(type) {
                    const building = this.buildings[type];
                    const maxLevels = { dungeon: 6, warehouse: 4, barracks: 5, armory: 4, maternity: 6, merchantCamp: 4 };
                    if (building.level >= maxLevels[type]) { this.showCustomAlert(`${building.name}已達到最大等級！`); return; }
                    if (!this.canAffordBuildingUpgrade(type)) { this.showCustomAlert("資源不足！"); return; }
                    
                    const cost = this.getBuildingUpgradeCost(type);
                    this.resources.food -= (cost.food || 0);
                    this.resources.wood -= cost.wood;
                    this.resources.stone -= cost.stone;
                    building.level++;
                    this.logMessage('tribe', `${building.name}${building.level === 1 ? '建造完成' : `升級至 ${building.level} 級`}！`, 'success');

                    if (this.tutorial.active && type === 'armory' && building.level === 1 && !this.tutorial.finishedDecomposing) {
                        this.triggerTutorial('armoryBuilt');
                    }

                    if (this.tutorial.active) {
                        setTimeout(() => {
                            // 【修改】對應新的步驟編號
                            if (type === 'dungeon' && this.tutorial.step === 3 && building.level === 1) {
                                this.advanceTutorial(4);
                            } 
                            else if (type === 'maternity' && this.tutorial.step === 4 && building.level === 1) {
                                this.advanceTutorial(5);
                            }
                        }, 50);
                    }
                },
                
                startBreedingNarrative() {
                    // --- 準備並打開 AI 敘事視窗 (前置檢查已由 handleBreedingClick 完成) ---
                    const modal = this.modals.narrative;
                    const selectedIds = this.modals.dungeon.selectedBreedIds;
                    const selectedCaptives = this.captives.filter(c => selectedIds.includes(c.id));

                    // 【核心修改】準備好狀態
                    modal.title = "繁衍";
                    modal.type = "breeding";
                    modal.isAwaitingConfirmation = true; // 預設為等待確認狀態
                    modal.isLoading = false;
                    modal.context = [];
                    modal.currentCaptives = selectedCaptives;
                    modal.hasBred = false;
                    
                    // 【核心修改】關閉當前視窗，並切換到新的專屬敘事畫面
                    this.modals.construction.isOpen = false;
                    this.screen = 'breeding_narrative'; 
                },
                confirmAndStartBreedingNarrative() {
                    const modal = this.modals.narrative;
                    modal.isAwaitingConfirmation = false; // 直接進入敘事階段
                    modal.isLoading = true;
                    this.generateNarrativeSegment('開始'); // 觸發第一段與繁衍相關的AI敘事
                },
                closeNarrativeModal() {
                    if (this.modals.narrative.type === 'breeding' && this.modals.narrative.hasBred) {
                        this.modals.dungeon.selectedBreedIds = [];
                        this.nextDay();
                    }
                    
                    if (this.modals.narrative.type === 'birth') {
                        this.screen = 'tutorial_query';
                    }

                    // 【新增】對 tutorial 類型的處理
                    if (this.modals.narrative.type === 'tutorial') {
                        // 教學彈窗關閉後，不需要做任何特殊操作，直接關閉即可
                    }

                    this.modals.narrative.isOpen = false;
                    // 可以在此處重置 modal 狀態以策安全
                    this.modals.narrative.type = '';
                    this.modals.narrative.content = '';
                },
                finalizeBreedingAndReturn() {
                    if (this.modals.narrative.hasBred) {
                        this.modals.dungeon.selectedBreedIds = [];
                        this.nextDay();
                    }
                    // 呼叫新的共用函式
                    this.returnToBreedingModal('繁衍已完成！');
                },
                executeQuickBreedingAndReturn() {
                    const selectedIds = this.modals.dungeon.selectedBreedIds;
                    const selectedCount = selectedIds.length;

                    // 執行繁衍的核心遊戲機制
                    selectedIds.forEach(id => {
                        const captive = this.captives.find(c => c.id === id);
                        if (captive && !captive.isPregnant) {
                            captive.isPregnant = true;
                            captive.pregnancyTimer = 3;
                            this.player.attributePoints++;
                        }
                    });

                    this.breedingChargesLeft -= selectedCount;
                    this.logMessage('tribe', `你與 ${selectedCount} 名女性進行了繁衍，獲得了 ${selectedCount} 點能力點。`, 'success');
                    
                    // 清理並觸發下一天
                    this.modals.dungeon.selectedBreedIds = [];
                    this.nextDay();

                    // 【修改】返回部落畫面的同時，重新打開「部落建設」視窗
                    this.screen = 'tribe';
                    this.modals.construction.isOpen = true;

                    // 【新增】為了更好的體驗，直接定位回繁衍分頁
                    this.modals.construction.activeTab = 'dungeon';
                    this.modals.dungeon.subTab = 'breed';

                    // 【新增】顯示操作成功的提示框
                    this.showCustomAlert('繁衍已完成！');
                    
                },
                async confirmAndNarrateBreeding() {
                    // 防止重複觸發
                    if (this.modals.narrative.hasBred) return;

                    // 【核心修改】在此處加入繁衍的遊戲機制
                    const selectedIds = this.modals.dungeon.selectedBreedIds;
                    const selectedCount = selectedIds.length;
                    selectedIds.forEach(id => {
                        const captive = this.captives.find(c => c.id === id);
                        if (captive && !captive.isPregnant) {
                            captive.isPregnant = true;
                            captive.pregnancyTimer = 3;
                            this.player.attributePoints++;
                        }
                    });
                    this.breedingChargesLeft -= selectedCount;
                    this.logMessage('tribe', `你與 ${selectedCount} 名女性進行了繁衍，獲得了 ${selectedCount} 點能力點。`, 'success');

                    // 標記繁衍已完成
                    this.modals.narrative.hasBred = true;

                    // 命令 AI 生成對應的敘事文本
                    await this.generateNarrativeSegment('繁衍');
                },
                async generateIntroNarrative() {
                    const modal = this.modals.narrative;
                    modal.isAwaitingConfirmation = false; // <<< 新增：關閉確認狀態
                    modal.isLoading = true;
                    modal.content = '';
                    modal.title = "序幕";
                    modal.type = "intro";
                    const prompt = "來玩角色扮演遊戲。玩家於現實世界中抑鬱而終，當再次睜開雙眼，發現自己來到了一個劍與魔法的異世界。然而，並未成為勇者或魔王，而是轉生成了一隻最弱小的生物——哥布林。更奇怪的是，孤身一人，身邊沒有任何同伴。在這個對哥布林充滿敵意的世界，必須依靠自己，從零開始，建立只屬於自己的部落，向世界宣告哥布林王的崛起。請生成一段約150字的遊戲開場白，描述玩家是一位在現代社會中感到抑鬱與不滿的人，人生忽然迎來終點，張著眼，世界逐漸融化且意識逐漸模糊，漸漸感到冰冷，忽然就發現自己倒在另一個地方。風格請帶有黑暗奇幻的色彩。";
                    
                    try {
                        const text = await this.callGeminiAPI(prompt, 0.5);
                        modal.content = text.replace(/\n/g, '<br>');
                    } catch (error) {
                        modal.content = error.message;
                    } finally {
                        modal.isLoading = false;
                    }
                },
                async generateBirthNarrative() {
                    const modal = this.modals.narrative;
                    modal.isAwaitingConfirmation = false; // <<< 新增
                    modal.isLoading = true;
                    modal.content = ''; // 清空提示文字

                    const prompt = `玩家發現自己變成了哥布林。請根據以下新誕生的哥布林王資訊，生成一段約150字，黑暗奇幻風格的誕生故事。描述如何在一個陌生的世界甦醒，感受自己全新的、醜陋、非人而強大的哥布林身體，且需要繁衍以壯大自己的部落。\n\n**哥布林王資訊:**\n- 名稱: ${this.player.name}\n- 外貌: ${this.player.appearance}\n- 身高: ${this.player.height} cm\n- 雄風: ${this.player.penisSize} cm`;

                    try {
                        const text = await this.callGeminiAPI(prompt, 0.5);
                        modal.content = text.replace(/\n/g, '<br>');
                        this.narrativeMemory = text;
                    } catch (error) {
                        modal.content = error.message;
                    } finally {
                        modal.isLoading = false;
                    }
                },
                async generateNarrativeSegment(action) {
                    const modal = this.modals.narrative;
                    modal.isLoading = true;
                    modal.title = "繁衍";
                    modal.type = "breeding";
                    
                    const captives = modal.currentCaptives;
                    const isSoloScene = captives.length === 1 && this.player.party.length === 0;
                    let prompt = '';
                    
                    const baseInstruction = "以哥布林王的視角，描寫一段與地牢俘虜的繁衍過程。";

                    if (isSoloScene) {
                        const captive = captives[0];
                        const captiveDetails = `- 名稱: ${captive.name}, 職業: ${captive.profession}, 個性: ${captive.visual.personality}, 髮色: ${captive.visual.hairColor}, 髮型: ${captive.visual.hairStyle}, ${captive.visual.bust}罩杯, 身高 ${captive.visual.height}cm, 年紀 ${captive.visual.age}歲, 服裝: ${captive.visual.clothing}`;
                        if (modal.context.length === 0) {
                            prompt = `${baseInstruction}\n\n**哥布林王資訊:**\n- 名稱: ${this.player.name}\n- 外貌: ${this.player.appearance}\n- 身高: ${this.player.height} cm\n- 雄風: ${this.player.penisSize} cm\n\n**女性俘虜資訊:**\n${captiveDetails}\n\n故事從哥布林王決定 "${action}" 開始。請詳細描寫地牢環境，以及哥布林王打牢房，進入到內。\n請撰寫一段約200-250字，充滿氣氛和細節的開場故事，以及女性的外貌、反應。\n對話請嚴格遵循格式：職業 + 名字「說話內容...等」(動作、感受...等)。\敘事描述每一個動作、行為、生理反應及雙方感受。`;
                        } else {
                            const storySoFar = modal.context.map(turn => `哥布林王：${turn.user}\n${turn.model}`).join('\n\n');
                            prompt = `接續以下的故事，哥布林王想 "${action}"。請根據這個新動作，繼續撰寫故事的下一段落（約100-200字），保持風格一致，並描寫女性的外貌、反應。\n對話請嚴格遵循格式：職業 + 名字「說話內容...等」(動作、感受...等)。\n\n**故事至此:**\n${storySoFar}`;
                        }
                    } else { // Group scene
                        let captivesDetails = captives.map(c => `- 名稱: ${c.name}, 職業: ${c.profession}, 個性: ${c.visual.personality}, 髮色: ${c.visual.hairColor}, 髮型: ${c.visual.hairStyle}, ${c.visual.bust}罩杯, 身高 ${c.visual.height}cm, 年紀 ${c.visual.age}歲, 服裝: ${c.visual.clothing}`).join('\n');
                        let partnersDetails = this.player.party.length > 0 ? `你的哥布林夥伴們 (${this.player.party.map(p => p.name).join(', ')}) 也一同參與。` : '';
                        if (modal.context.length === 0) {
                            prompt = `${baseInstruction}\n\n**哥布林王資訊:**\n- 名稱: ${this.player.name}\n- 外貌: ${this.player.appearance}\n- 身高: ${this.player.height} cm\n- 雄風: ${this.player.penisSize} cm\n${partnersDetails}\n\n**女性俘虜資訊:**\n${captivesDetails}\n\n故事從哥布林王決定 "${action}" 開始。請詳細描寫地牢環境，以及哥布林王打牢房，進入到內。\n請撰寫一段約200-250字，充滿氣氛和細節的開場故事。哥布林王以及女性們的外貌、反應。\n對話請嚴格遵循格式：職業 + 名字「說話內容...等」(動作、感受...等)。\敘事將描述每一個動作、行為、生理反應及雙方感受。`;
                        } else {
                            const storySoFar = modal.context.map(turn => `哥布林王：${turn.user}\n${turn.model}`).join('\n\n');
                            prompt = `接續以下的故事，哥布林王想 "${action}"。請根據這個新動作，繼續撰寫故事的下一段落（約100-200字），保持風格一致，並描寫女性們的外貌、反應。\n對話請嚴格遵循格式：職業 + 名字「說話內容...等」(動作、感受...等)。\n\n**故事至此:**\n${storySoFar}`;
                        }
                    }

                    modal.context.push({ user: action });

                    try {
                        const text = await this.callGeminiAPI(prompt, 0.5);
                        modal.content = text.replace(/\n/g, '<br>');
                        modal.context[modal.context.length - 1].model = text;
                    } catch (error) {
                        modal.content = error.message;
                        modal.context.pop();
                    } finally {
                        modal.isLoading = false;
                    }
                },
                async callGeminiAPI(prompt, temperature = 0.7) {
                    // 【修改】如果沒有金鑰，則直接回傳提示訊息，不發出請求
                    if (!this.userApiKey || this.userApiKey.trim() === '') {
                        return "（AI 敘事功能需要 API 金鑰。請刷新頁面，在初始畫面中輸入您的金鑰。）";
                    }

                    let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = { 
                        contents: chatHistory,
                        generationConfig: {
                            temperature: temperature
                        }
                    };
                    // 【修改】使用玩家輸入的金鑰
                    const apiKey = this.userApiKey; 
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        // 如果 API 金鑰無效或出錯，也給予明確提示
                        if (response.status === 400) {
                            return "（您的 API 金鑰無效或已過期，請刷新頁面重新輸入。）";
                        }
                        // 【新增】處理請求頻率過高的錯誤
                        if (response.status === 429) {
                            return "（對AI的請求過於頻繁，已觸發流量限制，請稍後再試。）";
                        }
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    const result = await response.json();
                    
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        return result.candidates[0].content.parts[0].text;
                    } else {
                        console.error("Unexpected API response structure:", result);
                        let errorMessage = "無法生成故事，可能是因為內容限制。";
                        if (result.promptFeedback && result.promptFeedback.blockReason) {
                            errorMessage += ` (原因: ${result.promptFeedback.blockReason})`;
                        }
                        return `（${errorMessage}）`; // 將錯誤訊息回傳到畫面上
                    }
                },

                calculateProcChance(baseRate) {
                    if (!this.player) return baseRate;
                    const rawLuck = this.player.stats.luck; // 僅計算原始運氣值    
                    const finalRate = baseRate + (rawLuck / 100) * 40;
                    return Math.min(finalRate, baseRate + 40); // 確保運氣加成不超過40%
                },        
                    
                giveBirth(mother) {
                    // 【防禦性檢查】
                    if (!mother || !mother.stats) {
                        this.logMessage('tribe', `一名孕母的資料異常，本次生產失敗！`, 'enemy');
                        if(mother) {
                            mother.isPregnant = false;
                            mother.pregnancyTimer = 0;
                        }
                        return;
                    }

                    // 提前創建新生兒，無論寢室是否已滿
                    const pStats = this.player.stats;
                    const mStats = mother.stats;
                    const newStats = {
                        strength: Math.floor(((pStats.strength || 0) + (mStats.strength || 0)) / 4 + (mStats.charisma || 0)),
                        agility: Math.floor(((pStats.agility || 0) + (mStats.agility || 0)) / 4 + (mStats.charisma || 0)),
                        intelligence: Math.floor(((pStats.intelligence || 0) + (mStats.intelligence || 0)) / 4 + (mStats.charisma || 0)),
                        luck: Math.floor(((pStats.luck || 0) + (mStats.luck || 0)) / 4 + (mStats.charisma || 0))
                    };
                    const newName = `(${(mother.profession || '未知')}${(mother.name || '無名')}之子)哥布林`;
                    const newPartner = new Goblin(newName, newStats);
                    newPartner.maxHp = newPartner.calculateMaxHp(this.isStarving);
                    newPartner.currentHp = newPartner.maxHp;

                    // 檢查寢室容量
                    if (this.partners.length < this.partnerCapacity) {
                        // 容量充足，直接加入
                        this.partners.push(newPartner);
                        mother.isPregnant = false;
                        mother.pregnancyTimer = 0;
                        mother.isMother = true;
                        this.player.skillPoints++;
                        this.logMessage('tribe', `${mother.name} 誕下了一個新的哥布林夥伴：${newName}！你獲得了 1 點技能點。`, 'success');
                        this.logMessage('tribe', `${mother.name} 現在開始在產房為部落貢獻奶水。`, 'info');
                        if (this.tutorial.active && !this.tutorial.finishedPartyMgmt) {
                            this.triggerTutorial('firstBirth');
                        }
                    } else {
                        // 容量不足，將決策事件加入佇列
                        this.logMessage('tribe', `${mother.name} 誕下了一個孩子，但寢室已滿！返回部落後需要您做出選擇...`, 'warning');
                        this.pendingDecisions.push({
                            type: 'partner',
                            list: [...this.partners, newPartner],
                            limit: this.partnerCapacity,
                            dungeonLimit: -1,
                            context: { mother: mother, newborn: newPartner }
                        });
                    }
                },

                // 【新增】這個全新的函式
                releaseCarriedCaptive(captiveId) {
                    if (!this.currentRaid) return;

                    const captiveIndex = this.currentRaid.carriedCaptives.findIndex(c => c.id === captiveId);
                    
                    if (captiveIndex > -1) {
                        // 先取得俘虜的名字，用於日誌記錄
                        const captiveName = this.currentRaid.carriedCaptives[captiveIndex].name;
                        
                        // 從列表中移除該俘虜
                        this.currentRaid.carriedCaptives.splice(captiveIndex, 1);
                        
                        // 在掠奪日誌中記錄此事件
                        this.logMessage('raid', `你釋放了俘虜 ${captiveName}。`, 'info');
                    }
                },
                
                releaseCaptive(captiveId) {
                    const captive = this.captives.find(c => c.id === captiveId);
                    if (captive) {
                        this.captives = this.captives.filter(c => c.id !== captiveId);
                        this.logMessage('tribe', `你拋棄了 ${captive.isMother ? '孕母' : '俘虜'} ${captive.name}。`, 'info');
                    }
                },
                moveMotherToDungeon(captiveId) {
                    const captive = this.captives.find(c => c.id === captiveId);
                    if (captive) {
                        if (captive.isPregnant) {
                            this.showCustomAlert(`${captive.name} 正在懷孕中，無法移動！`);
                            return;
                        }
                        // 【新增】檢查地牢容量
                        if (this.dungeonCaptives.length >= this.captiveCapacity) {
                            this.showCustomAlert(`地牢空間已滿 ( ${this.dungeonCaptives.length} / ${this.captiveCapacity} )，無法移入更多俘虜！`);
                            return;
                        }
                        captive.isMother = false;
                        this.logMessage('tribe', `${captive.name} 已被移回地牢，等待繁衍。`, 'info');
                    }
                },
                releasePartner(partnerId) {
                    const partner = this.partners.find(p => p.id === partnerId);
                    if (!partner) return;

                    const itemsToReturn = Object.values(partner.equipment).filter(item => item !== null);

                    if (itemsToReturn.length > 0) {
                        const availableSpace = (this.warehouseCapacity - this.warehouseInventory.length) + (this.backpackCapacity - this.player.inventory.length);
                        
                        if (itemsToReturn.length > availableSpace) {
                            // 空間不足，打開處理視窗
                            this.modals.itemManagement = {
                                isOpen: true,
                                title: `處理 ${partner.name} 的裝備`,
                                message: `倉庫與背包空間不足！請先處理以下裝備，直到剩餘數量小於等於 ${availableSpace}。`,
                                items: [...itemsToReturn], // 複製一份陣列
                                capacity: availableSpace,
                                onConfirm: () => {
                                    this.finalizeReleasePartner(partner); // 設定確認後要執行的動作
                                }
                            };
                        } else {
                            // 空間足夠，自動轉移
                            itemsToReturn.forEach(item => {
                                if (this.warehouseInventory.length < this.warehouseCapacity) {
                                    this.warehouseInventory.push(item);
                                } else {
                                    this.player.inventory.push(item);
                                }
                            });
                            this.logMessage('tribe', `已將 ${partner.name} 的 ${itemsToReturn.length} 件裝備自動移至倉庫/背包。`, 'info');
                            this.finalizeReleasePartner(partner);
                        }
                    } else {
                        // 身上沒裝備，直接逐出
                        this.finalizeReleasePartner(partner);
                    }
                },

                finalizeReleasePartner(partner) {
                    this.partners = this.partners.filter(p => p.id !== partner.id);
                    this.player.party = this.player.party.filter(p => p.id !== partner.id);
                    this.player.updateHp(this.isStarving);
                    this.logMessage('tribe', `你將 ${partner.name} 逐出了部落。`, 'info');
                },

                executeItemManagementAction(action, itemId) {
                    const modal = this.modals.itemManagement;
                    const itemIndex = modal.items.findIndex(i => i.id === itemId);
                    if (itemIndex === -1) return;

                    const [item] = modal.items.splice(itemIndex, 1);

                    if (action === 'decompose') {
                        const material = item.material;
                        const returnRate = [0.2, 0.3, 0.4, 0.5][this.buildings.armory.level - 1] || 0;
                        const resourcesBack = Math.floor(material.cost * returnRate);

                        if (material.type === 'metal') {
                            this.resources.stone += resourcesBack;
                            this.logMessage('tribe', `你分解了 [${item.name}]，回收了 ${resourcesBack} 礦石。`, 'info');
                        } else {
                            this.resources.wood += resourcesBack;
                            this.logMessage('tribe', `你分解了 [${item.name}]，回收了 ${resourcesBack} 木材。`, 'info');
                        }
                    } else if (action === 'discard') {
                        this.logMessage('tribe', `你丟棄了裝備 [${item.name}]。`, 'info');
                    }
                },

                confirmItemManagement() {
                    const modal = this.modals.itemManagement;
                    if (modal.items.length > modal.capacity) {
                        this.showCustomAlert('處理尚未完成！剩餘裝備數量仍大於可用空間。');
                        return;
                    }

                    // 將剩餘決定保留的裝備放入倉庫/背包
                    modal.items.forEach(item => {
                        if (this.warehouseInventory.length < this.warehouseCapacity) {
                            this.warehouseInventory.push(item);
                        } else {
                            this.player.inventory.push(item);
                        }
                    });
                    this.logMessage('tribe', `你處理完畢，並保留了 ${modal.items.length} 件裝備。`, 'success');

                    // 執行回呼函式 (例如：完成夥伴的逐出)
                    if (typeof modal.onConfirm === 'function') {
                        modal.onConfirm();
                    }

                    // 關閉並重置 modal
                    modal.isOpen = false;
                    modal.onConfirm = null;
                    modal.items = [];
                },

                generateMerchantGoods() {
                    const level = this.buildings.merchantCamp.level;
                    const itemCounts = [2, 4, 6, 8, 10];
                    const numItems = itemCounts[level] || 2;
                    let goods = [];

                    const materialTiers = { 0: [1,2], 1: [1,3], 2: [2,4], 3: [3,5], 4: [4,6] };
                    const possibleTiers = materialTiers[level];

                    for (let i = 0; i < numItems; i++) {
                        // 決定品質
                        const qualityRoll = randomInt(1, 100);
                        let qualityKey = 'worn'; // 7%
                        if (qualityRoll <= 5) qualityKey = 'legendary';       // 5%
                        else if (qualityRoll <= 15) qualityKey = 'epic';      // 10%
                        else if (qualityRoll <= 32) qualityKey = 'rare';      // 17%
                        else if (qualityRoll <= 58) qualityKey = 'uncommon';  // 26%
                        else if (qualityRoll <= 93) qualityKey = 'common';    // 35%

                        // 決定材質
                        const isMetal = roll(50);
                        const tier = randomInt(possibleTiers[0], possibleTiers[1]);
                        const materialType = isMetal ? 'metal' : 'wood';
                        const materialKey = Object.keys(EQUIPMENT_MATERIALS).find(key => 
                            EQUIPMENT_MATERIALS[key].tier === tier && EQUIPMENT_MATERIALS[key].type === materialType
                        );
                        if (!materialKey) continue;

                        // 決定裝備類型
                        const randomItemType = this.craftableTypes[randomInt(0, this.craftableTypes.length - 1)];
                        const newItem = this.createEquipment(materialKey, qualityKey, randomItemType.baseName);
                        goods.push(newItem);
                    }
                    this.merchant.goods = goods;
                },
                confirmPartySelection() {
                    this.player.party = this.partners.filter(p => this.modals.barracks.selectedPartyIds.includes(p.id));
                    this.player.updateHp(this.isStarving);
                    this.logMessage('tribe', `你更新了出擊隊伍，現在有 ${this.player.party.length} 名夥伴與你同行。`, 'info');

                    // 【新增】顯示一個提示框，告知玩家操作成功，增加操作回饋
                    this.showCustomAlert('出擊隊伍已更新！');
                },
                                
                addTempPoint(stat) {
                    const spentPoints = Object.values(this.tempStatIncreases).reduce((a, b) => a + b, 0);
                    if (this.player.attributePoints > spentPoints) {
                        this.tempStatIncreases[stat]++;
                    }
                },
                confirmAttributePoints() {
                    let changesLog = [];
                    for (const stat in this.tempStatIncreases) {
                        if (this.tempStatIncreases[stat] > 0) {
                            const increase = this.tempStatIncreases[stat];
                            this.player.stats[stat] += increase;
                            this.player.attributePoints -= increase;
                            changesLog.push(`${STAT_NAMES[stat]} +${increase}`);
                        }
                    }
                    this.cancelAttributePoints();
                    this.player.updateHp(this.isStarving);
                    this.logMessage('tribe', `你分配了能力點：${changesLog.join(', ')}。`, 'success');
                },
                cancelAttributePoints() {
                    this.tempStatIncreases = { strength: 0, agility: 0, intelligence: 0, luck: 0 };
                },

                raidOptions: [
                    { difficulty: 'easy', name: '簡單', description: '居民(15-20), 守軍(5-10)' },
                    { difficulty: 'normal', name: '普通', description: '居民(20-25), 守軍(10-15)' },
                    { difficulty: 'hard', name: '困難', description: '居民(25-30), 守軍(15-20)' },
                    { difficulty: 'hell', name: '地獄', description: '居民(30-35), 守軍(20-25)' },
                ],
                startRaid(difficulty) {
                    // 【修改】將步驟判斷從 4 改為 5，並將下一步指向 5.5
                    if (this.tutorial.active && this.tutorial.step === 5) {
                        if (difficulty !== 'easy') {
                            this.showCustomAlert('王，您的勇氣可嘉。那麼，您自己看著辦吧。引導教學將在部落中等您歸來。');
                            this.tutorial.active = false;
                        } else {
                            this.advanceTutorial(5.5); // 推進到偵查環境的提示
                        }
                    }

                    if (this.buildings.dungeon.level === 0) {
                        this.showCustomAlert('地牢尚未建造，無法發動掠奪來抓捕俘虜！');
                        return;
                    }
                    this.currentRaid = this.generateCity(difficulty);
                    this.screen = 'raid';
                    this.logMessage('raid', `你帶領隊伍前往 ${this.currentRaid.locationName} 進行掠奪！`, 'player');
                },

                triggerRevengeSquadBattle(difficulty, pendingBirths = []) {
                    this.postBattleBirths = pendingBirths;

                    this.showCustomAlert('警報！一支由騎士和民兵組成的復仇小隊襲擊了你的部落！');

                    // 【修改】新的隊伍組成，包含騎士團和居民
                    const squadCompositions = {
                        easy:   { knights: { '士兵': 1, '盾兵': 1 }, residents: 4 },
                        normal: { knights: { '士兵': 2, '盾兵': 1, '槍兵': 1, '弓兵': 1 }, residents: 5 },
                        hard:   { knights: { '士兵': 2, '盾兵': 1, '槍兵': 1, '弓兵': 1, '騎士': 1, '法師': 1 }, residents: 6 },
                        hell:   { knights: { '士兵': 3, '盾兵': 2, '槍兵': 2, '弓兵': 1, '騎士': 1, '法師': 1, '祭司': 1 }, residents: 7 }
                    };
                    
                    const knightStatRanges = {
                        easy: [80, 150], normal: [150, 240], hard: [240, 350], hell: [350, 450]
                    };
                    const residentStatRanges = {
                        easy: [20, 20], normal: [20, 40], hard: [40, 80], hell: [80, 160]
                    };

                    const composition = squadCompositions[difficulty];
                    const knightStatRange = knightStatRanges[difficulty];
                    const residentStatRange = residentStatRanges[difficulty];
                    let revengeSquad = [];

                    // 【新增】生成騎士團成員
                    for (const unitType in composition.knights) {
                        for (let i = 0; i < composition.knights[unitType]; i++) {
                            const totalStatPoints = randomInt(knightStatRange[0], knightStatRange[1]);
                            const unit = roll(50) 
                                ? new FemaleKnightOrderUnit(unitType, totalStatPoints, difficulty)
                                : new KnightOrderUnit(unitType, totalStatPoints, difficulty);
                            this.equipEnemy(unit, difficulty);
                            revengeSquad.push(unit);
                        }
                    }

                    // 【新增】生成居民（民兵）
                    for (let i = 0; i < composition.residents; i++) {
                        const totalStatPoints = randomInt(residentStatRange[0], residentStatRange[1]);
                        const unit = roll(50)
                            ? new FemaleHuman("復仇的居民", distributeStats(totalStatPoints, ['strength', 'agility', 'intelligence', 'luck', 'charisma']), '居民', generateVisuals(), difficulty)
                            : new MaleHuman("復仇的居民", distributeStats(totalStatPoints), '居民', difficulty);
                        this.equipEnemy(unit, difficulty);
                        revengeSquad.push(unit);
                    }
                    
                    this.combat.isReinforcementBattle = true;
                    this.startCombat(revengeSquad, true);
                },

                generateCity(difficulty) {
                    const config = {
                        // 【修改】更新各難度的居民 (pop) 數量
                        easy:    { time: 300, zones: ['外城', '內城'], pop: [10, 15], guards: [5, 10], knightStats: [80, 150] },
                        normal: { time: 240, zones: ['外城', '內城A', '內城B'], pop: [15, 25], guards: [10, 15], knightStats: [150, 240] },
                        hard:    { time: 180, zones: ['外城', '內城A', '內城B', '內城C'], pop: [25, 30], guards: [15, 20], knightStats: [240, 350] },
                        hell:    { time: 120, zones: ['外城', '內城A', '內城B', '內城C', '王城'], pop: [35, 40], guards: [20, 25], knightStats: [350, 450] }
                    };
                    const cityConfig = config[difficulty];
                    const nameConfig = CITY_NAMES[difficulty];
                    const locationName = nameConfig.prefixes[randomInt(0, nameConfig.prefixes.length - 1)] + nameConfig.suffix;

                    let city = {
                        difficulty, locationName, timeRemaining: cityConfig.time, zones: [],
                        currentZoneIndex: 0,
                        get currentZone() { return this.zones[this.currentZoneIndex]; },
                        carriedCaptives: [],
                        failedSneakTargets: new Set()
                    };

                    city.zones = cityConfig.zones.map(name => ({
                        name: name, scouted: { environment: false, targets: new Set() },
                        buildings: [], enemies: [],
                        resources: { food: 0, wood: 0, stone: 0 }
                    }));
                    
                    const gridCols = Math.floor(MAP_WIDTH / GRID_SIZE);
                    const gridRows = Math.floor(MAP_HEIGHT / GRID_SIZE);
                    // 【修改】為每個 zone 建立獨立的 grid，避免跨層干擾
                    city.zones.forEach(zone => {
                        zone.placementGrid = Array(gridRows).fill(null).map(() => Array(gridCols).fill(null));
                    });

                    const paddingTop = 60;
                    const paddingBottom = 40;
                    
                    const getFreePosition = (zone, isBuilding = false) => {
                        let attempts = 0;
                        while(attempts < 50) {
                            const r = randomInt(0, gridRows - 1);
                            const c = randomInt(0, gridCols - 1);
                            const potentialY = r * GRID_SIZE + (GRID_SIZE / 4);

                            if (potentialY < paddingTop || potentialY > MAP_HEIGHT - paddingBottom) {
                                attempts++;
                                continue;
                            }
                            
                            if (!zone.placementGrid[r][c]) {
                                zone.placementGrid[r][c] = isBuilding ? 'building' : 'unit'; 
                                return { 
                                    x: c * GRID_SIZE + (GRID_SIZE / 4), 
                                    y: potentialY
                                };
                            }
                            attempts++;
                        }
                        const safeMapHeight = MAP_HEIGHT - paddingTop - paddingBottom;
                        return { 
                            x: randomInt(20, MAP_WIDTH - 20), 
                            y: randomInt(paddingTop, paddingTop + safeMapHeight)
                        };
                    };

                    const totalResidents = randomInt(cityConfig.pop[0], cityConfig.pop[1]);
                    const totalGuards = randomInt(cityConfig.guards[0], cityConfig.guards[1]);

                    let allGuards = Array.from({ length: totalGuards }, () => {
                        const statRange = ENEMY_STAT_RANGES[difficulty].guard;
                        const totalStatPoints = randomInt(statRange[0], statRange[1]);
                        const isFemale = roll(50);
                        
                        let guard; // 先宣告一個變數來存放守軍
                        if (isFemale) {
                            guard = new FemaleHuman(FEMALE_NAMES[randomInt(0, FEMALE_NAMES.length-1)], distributeStats(totalStatPoints, ['strength', 'agility', 'intelligence', 'luck', 'charisma']), '城市守軍', generateVisuals(), difficulty);
                        } else {
                            guard = new MaleHuman(MALE_NAMES[randomInt(0, MALE_NAMES.length-1)], distributeStats(totalStatPoints), '城市守軍');
                        }

                        this.equipEnemy(guard, difficulty); // 【核心修正】為生成的守軍呼叫裝備函式

                        return guard; // 最後返回這個已經穿好裝備的守軍
                    });
                    
                    let allResidents = Array.from({ length: totalResidents }, () => {
                        const statRange = ENEMY_STAT_RANGES[difficulty].resident;
                        const isFemale = roll(50);
                        if (isFemale) {
                            const profession = PROFESSIONS[randomInt(0, PROFESSIONS.length - 1)];
                            return new FemaleHuman(FEMALE_NAMES[randomInt(0, FEMALE_NAMES.length - 1)], distributeStats(randomInt(statRange[0], statRange[1]), ['strength', 'agility', 'intelligence', 'luck', 'charisma']), profession, generateVisuals(), difficulty);
                        } else {
                            return new MaleHuman(MALE_NAMES[randomInt(0, MALE_NAMES.length - 1)], distributeStats(randomInt(statRange[0], statRange[1])), '男性居民');
                        }
                    });

                    const outerGuardsCount = Math.floor(totalGuards * 0.25);
                    const outerGuards = allGuards.slice(0, outerGuardsCount);
                    const innerGuards = allGuards.slice(outerGuardsCount);

                    if (outerGuards.length > 0) {
                        const pos = getFreePosition(city.zones[0], true);
                        city.zones[0].buildings.push({ 
                            id: crypto.randomUUID(), type: '衛兵所', occupants: outerGuards, looted: false, resources: { food: 0, wood: 0, stone: 0 },
                            scouted: false, postScoutText: '',
                            x: pos.x, y: pos.y, width: GRID_SIZE / 2, height: GRID_SIZE / 2
                        });
                    }
                    
                    const innerZones = city.zones.filter(z => z.name !== '外城' && z.name !== '王城');
                    
                    if (innerZones.length > 0) {
                        let currentGuardIndex = 0;
                        while(currentGuardIndex < innerGuards.length) {
                            const groupSize = randomInt(2, 3);
                            const patrolTeam = innerGuards.slice(currentGuardIndex, currentGuardIndex + groupSize);
                            if (patrolTeam.length > 0) {
                                const targetZone = innerZones[randomInt(0, innerZones.length - 1)];
                                const pos = getFreePosition(targetZone);
                                patrolTeam.forEach(unit => { unit.x = pos.x; unit.y = pos.y; });
                                targetZone.enemies.push(patrolTeam);
                            }
                            currentGuardIndex += groupSize;
                        }
                    }
                    
                    const buildingCount = Math.ceil(totalResidents / 1.5);
                    if (innerZones.length > 0) {
                        for (let i = 0; i < buildingCount; i++) {
                            const targetZone = innerZones[randomInt(0, innerZones.length - 1)];
                            const pos = getFreePosition(targetZone, true);
                            targetZone.buildings.push({
                                id: crypto.randomUUID(), type: BUILDING_TYPES[randomInt(0, BUILDING_TYPES.length - 2)],
                                occupants: [], looted: false, resources: { food: 0, wood: 0, stone: 0 },
                                scouted: false, postScoutText: '',
                                x: pos.x, y: pos.y, width: GRID_SIZE / 2, height: GRID_SIZE / 2
                            });
                        }
                    }

                    // 【新增】確保每層建築不少於3棟的邏輯
                    innerZones.forEach(zone => {
                        while (zone.buildings.length > 0 && zone.buildings.length < 3) {
                             const pos = getFreePosition(zone, true);
                             zone.buildings.push({
                                id: crypto.randomUUID(), type: BUILDING_TYPES[randomInt(0, BUILDING_TYPES.length - 2)],
                                occupants: [], looted: false, resources: { food: 0, wood: 0, stone: 0 },
                                scouted: false, postScoutText: '',
                                x: pos.x, y: pos.y, width: GRID_SIZE / 2, height: GRID_SIZE / 2
                            });
                        }
                    });

                    const allInnerBuildings = innerZones.flatMap(z => z.buildings);
                    allResidents.forEach(resident => {
                        let finalUnit = resident;
                        if(roll(5)) {
                            const knightStatRange = cityConfig.knightStats;
                            const knightTypes = Object.keys(KNIGHT_ORDER_UNITS);
                            const randomKnightType = knightTypes[randomInt(0, knightTypes.length - 1)];
                            const totalStatPoints = randomInt(knightStatRange[0], knightStatRange[1]);
                            finalUnit = roll(50) ? new FemaleKnightOrderUnit(randomKnightType, totalStatPoints, difficulty) : new KnightOrderUnit(randomKnightType, totalStatPoints);
                        }

                        this.equipEnemy(finalUnit, difficulty);

                        if (roll(80) && allInnerBuildings.length > 0) {
                            const randomBuilding = allInnerBuildings[randomInt(0, allInnerBuildings.length - 1)];
                            randomBuilding.occupants.push(finalUnit);
                        } else if (innerZones.length > 0) {
                            const targetZone = innerZones[randomInt(0, innerZones.length - 1)];
                            const pos = getFreePosition(targetZone);
                            finalUnit.x = pos.x;
                            finalUnit.y = pos.y;
                            targetZone.enemies.push([finalUnit]);
                        }
                    });

                    const royalCityZone = city.zones.find(z => z.name === '王城');
                    if (difficulty === 'hell' && royalCityZone) {
                        // [重要] 清空王城，確保只有我們的特殊建築
                        royalCityZone.enemies = [];
                        royalCityZone.buildings = [];

                        let castleOccupants = [];
                        
                        // 1. 生成 GDD 中定義的七位騎士團成員 (各兵種一名)
                        const knightStatRange = cityConfig.knightStats;
                        const knightTypes = Object.keys(KNIGHT_ORDER_UNITS); // ['士兵', '盾兵', '槍兵', '弓兵', '騎士', '法師', '祭司']

                        knightTypes.forEach(unitType => {
                            if (!KNIGHT_ORDER_UNITS[unitType]) return; // 避免未定義的兵種
                            const totalStatPoints = randomInt(knightStatRange[0], knightStatRange[1]);
                            // 50% 機率生成女性騎士 [cite: 89]
                            const knight = roll(50) 
                                ? new FemaleKnightOrderUnit(unitType, totalStatPoints) 
                                : new KnightOrderUnit(unitType, totalStatPoints);
                            castleOccupants.push(knight);
                        });

                        // 2. [修正] 根據 GDD 6.5 與 10.3 產生 1 至 3 位公主
                        const numPrincesses = randomInt(1, 3); // [修正] 公主數量為1-3人

                        for (let i = 0; i < numPrincesses; i++) {
                            const princessStats = {
                                strength: 20,
                                agility: 20,
                                intelligence: 20,
                                luck: 20,
                                charisma: randomInt(200, 300)
                            };
                            const princess = new FemaleHuman(
                                // 為多位公主取不同的名字
                                `${FEMALE_NAMES[randomInt(0, FEMALE_NAMES.length-1)]}公主`,
                                princessStats, 
                                '公主', 
                                generateVisuals()
                            );
                            castleOccupants.push(princess);
                        }
                        
                        // 3. 創建城堡建築，將所有單位放入 (總人數為 7 + 公主數量)
                        const pos = { x: (MAP_WIDTH / 2) - (GRID_SIZE / 2), y: 100 };
                        royalCityZone.buildings.push({
                            id: crypto.randomUUID(),
                            type: '城堡',
                            occupants: castleOccupants,
                            looted: false,
                            resources: { food: 500, wood: 500, stone: 500 },
                            scouted: false, 
                            postScoutText: '',
                            isFinalChallenge: true, // [關鍵] 特殊標記
                            x: pos.x, 
                            y: pos.y, 
                            width: GRID_SIZE,
                            height: GRID_SIZE 
                        });
                    }
                    //各難度資源量
                    const resConfig = {
                        easy: { food: [100, 200], wood: [50, 100], stone: [50, 100] },
                        normal: { food: [200, 400], wood: [100, 200], stone: [100, 200] },
                        hard: { food: [400, 800], wood: [200, 400], stone: [200, 400] },
                        hell: { food: [800, 1600], wood: [400, 800], stone: [400, 800] }
                    };
                    const totalFood = randomInt(resConfig[difficulty].food[0], resConfig[difficulty].food[1]);
                    const totalWood = randomInt(resConfig[difficulty].wood[0], resConfig[difficulty].wood[1]);
                    const totalStone = randomInt(resConfig[difficulty].stone[0], resConfig[difficulty].stone[1]);

                    const allCityBuildings = city.zones.flatMap(z => z.buildings);
                    if(allCityBuildings.length > 0) {
                        for(let i = 0; i < totalFood; i++) allCityBuildings[randomInt(0, allCityBuildings.length - 1)].resources.food++;
                        for(let i = 0; i < totalWood; i++) allCityBuildings[randomInt(0, allCityBuildings.length - 1)].resources.wood++;
                        for(let i = 0; i < totalStone; i++) allCityBuildings[randomInt(0, allCityBuildings.length - 1)].resources.stone++;
                    }

                    city.zones.forEach(zone => {
                        zone.resources.food = zone.buildings.reduce((sum, b) => sum + b.resources.food, 0);
                        zone.resources.wood = zone.buildings.reduce((sum, b) => sum + b.resources.wood, 0);
                        zone.resources.stone = zone.buildings.reduce((sum, b) => sum + b.resources.stone, 0);
                    });

                    return city;
                },
                enterThroneRoom(units) {
                    this.logMessage('raid', '你推開城堡沉重的大門，踏入了決定命運的「王座之間」！', 'system');
                    this.throneRoomUnits = units;
                    this.screen = 'throne_room';
                },

                scoutThroneUnit(unit) {
                    this.modals.throneScout.unit = unit;
                    this.modals.throneScout.isOpen = true;
                },

                getThroneUnitDialogue(unit) {
                    if (!unit) return '';
                    const dialogues = {
                        '公主': '「汝，為哥布林之王？竟敢踏足此地！」',
                        '士兵': '「以王國之名，我將斬殺你的野望！」',
                        '盾兵': '「這面盾牌將是你無法逾越的絕壁！」',
                        '槍兵': '「看來你運氣不太好呀...長槍將貫穿你的野心！」',
                        '弓兵': '「你無處可逃！箭矢將終結你！」',
                        '騎士': '「為了公主與王國的榮耀，我將在此斬除邪惡！」',
                        '法師': '「感受元素的憤怒吧，卑劣的生物！」',
                        '祭司': '「汙穢的生物，面對你的罪行吧！」'
                    };
                    return dialogues[unit.profession] || '「......」';
                },

                startFinalBattle() {
                    this.logMessage('raid', '最終決戰的號角響起！', 'enemy');
                    this.modals.throneScout.isOpen = false;
                    this.startCombat(this.throneRoomUnits, true);
                },
                scoutEnvironment() {
                    const successChance = 90 + (this.player.getTotalStat('intelligence', this.isStarving) * 1) + (this.player.party.length + 1) - (this.currentRaid.currentZoneIndex * 10);
                    if(roll(successChance)) {
                        this.currentRaid.timeRemaining -= 3;
                        this.currentRaid.currentZone.scouted.environment = true;
                        this.logMessage('raid', `環境偵查成功！(-3 分鐘)`, 'success');
                    } else {
                        this.currentRaid.timeRemaining -= 6;
                        this.logMessage('raid', `環境偵查失敗！(-6 分鐘)`, 'enemy');
                    }
                    this.checkRaidTime();

                    // 【核心修正】將步驟判斷從 4.5 改為 5.5
                    if (this.tutorial.active && this.tutorial.step === 5.5) {
                        this.tutorial.step = 0; // 暫時結束教學，等待玩家自行探索後返回部落觸發下一步
                        this.showCustomAlert('很好，王。現在您可以自由行動了，試著擊敗敵人、擄走女性，或者搜刮資源，然後『脫離城鎮』返回部落吧。');
                    }
                },
                // --- 請將舊的 scoutTarget 函數完整刪除，並貼上這個新版本 ---
                scoutTarget(targetOrGroup) {
                    // 安全檢查，防止目標為空
                    if (!targetOrGroup || (Array.isArray(targetOrGroup) && targetOrGroup.length === 0)) {
                        this.showCustomAlert("偵查目標無效！");
                        console.error("錯誤：偵查的目標為空，無法繼續。");
                        return;
                    }

                    const isGroup = Array.isArray(targetOrGroup);
                    // 【修正】無論是單體還是群組，都先取出第一個單位來進行偵查判定
                    const representativeTarget = isGroup ? targetOrGroup[0] : targetOrGroup;

                    // 如果代表目標已經被偵查過，直接開啟情報視窗
                    if (this.isTargetScouted(representativeTarget.id)) {
                        this.modals.scoutInfo.target = targetOrGroup; // 視窗顯示的是完整的群組
                        this.modals.scoutInfo.isOpen = true;
                        return;
                    }

                    // --- 偵查成功率計算 ---
                    const playerIntel = this.player.getTotalStat('intelligence', this.isStarving);
                    // 【修正】使用整個群組的平均智力來計算，而非只看第一個
                    let enemyAvgIntel = 0;
                    if (isGroup) {
                        const totalIntel = targetOrGroup.reduce((sum, unit) => sum + (unit.stats.intelligence || 0), 0);
                        enemyAvgIntel = totalIntel > 0 ? totalIntel / targetOrGroup.length : 0;
                    } else {
                        enemyAvgIntel = representativeTarget.stats.intelligence || 0;
                    }
                    
                    const successChance = 70 + (playerIntel - enemyAvgIntel) * 2 + (this.player.party.length + 1);
                    
                    // --- 執行偵查 ---
                    if (roll(successChance)) {
                        this.currentRaid.timeRemaining -= 3;
                        // 【修正】將群組內所有單位的ID都標記為已偵查
                        const targetsToMark = isGroup ? targetOrGroup : [representativeTarget];
                        targetsToMark.forEach(t => this.currentRaid.currentZone.scouted.targets.add(t.id));

                        this.logMessage('raid', `你成功偵查了 ${isGroup ? '一個隊伍' : representativeTarget.name} 的詳細情報！(-3 分鐘)`, 'success');
                        
                        // 開啟情報視窗
                        this.modals.scoutInfo.target = targetOrGroup;
                        this.modals.scoutInfo.isOpen = true;
                    } else {
                        this.currentRaid.timeRemaining -= 6;
                        this.logMessage('raid', `偵查 ${isGroup ? '一個隊伍' : representativeTarget.name} 失敗！(-6 分鐘)`, 'enemy');
                    }
                    this.checkRaidTime();
                },
                
                isTargetScouted(targetId) {
                    if (!this.currentRaid) return false;
                    return this.currentRaid.currentZone.scouted.targets.has(targetId);
                },
                lootBuilding(building) {
                    if(building.looted) return;

                    // --- 【新增】搜刮時被巡邏隊發現的機制 ---
                    const zone = this.currentRaid.currentZone;
                    const isInnerCity = zone.name.includes('內城') || zone.name === '王城';
                    const patrolsExist = zone.enemies && zone.enemies.length > 0;

                    // 規則：只在內城/王城，且還有巡邏隊時，才進行此判斷
                    if (isInnerCity && patrolsExist) {
                        const patrolGroupCount = zone.enemies.length;
                        const totalBuildingCount = zone.buildings.length;
                        
                        if (totalBuildingCount > 0) {
                            // 根據 GDD 公式計算發現機率
                            const discoveryChance = (patrolGroupCount / (totalBuildingCount * 4)) * 100;

                            if (roll(discoveryChance)) {
                                this.logMessage('raid', `你搜刮 ${building.type} 的聲音太大，驚動了附近的一支巡邏隊！`, 'enemy');
                                
                                // 隨機選擇一支巡邏隊進行戰鬥
                                const patrolToFight = zone.enemies[randomInt(0, patrolGroupCount - 1)];
                                
                                // 開始一場強制戰鬥（敵人先攻）
                                this.startCombat(patrolToFight, true);
                                
                                // 【重要】中斷搜刮，玩家不會獲得資源
                                return; 
                            }
                        }
                    }

                    this.currentRaid.timeRemaining -= 3;

                    const foodFound = building.resources.food;
                    const woodFound = building.resources.wood;
                    const stoneFound = building.resources.stone;
                    
                    this.resources.food = Math.min(this.foodCapacity, this.resources.food + foodFound);
                    this.resources.wood = Math.min(this.woodCapacity, this.resources.wood + woodFound);
                    this.resources.stone = Math.min(this.stoneCapacity, this.resources.stone + stoneFound);

                    building.looted = true;
                    building.postScoutText = ' (空)';
                    building.resources = { food: 0, wood: 0, stone: 0 };
                    
                    this.currentRaid.currentZone.resources.food -= foodFound;
                    this.currentRaid.currentZone.resources.wood -= woodFound;
                    this.currentRaid.currentZone.resources.stone -= stoneFound;
                    
                    this.logMessage('raid', `搜刮了 ${building.type} (-3 分鐘)，找到食物 ${foodFound}, 木材 ${woodFound}, 礦石 ${stoneFound}。`, 'success');
                    
                    const finalDropRate = 20 * (1 + this.player.getTotalStat('luck') / 100 * 0.5);
                    if (roll(finalDropRate)) {
                        if (this.player.inventory.length >= this.backpackCapacity) {
                            this.logMessage('raid', `你的背包已滿，無法拾取新的裝備！`, 'enemy');
                            this.checkRaidTime(); // 即使背包滿了也要檢查時間
                            return;
                        }
                        const materialTiers = {
                            easy: { metal: [1, 3], wood: [1, 3] },
                            normal: { metal: [2, 4], wood: [2, 4] },
                            hard: { metal: [3, 5], wood: [3, 5] },
                            hell: { metal: [4, 6], wood: [4, 6] },
                        };
                        const raidDifficulty = this.currentRaid.difficulty;
                        const possibleTiers = materialTiers[raidDifficulty];
                        const isMetal = roll(50);
                        const tierRange = isMetal ? possibleTiers.metal : possibleTiers.wood;
                        const tier = randomInt(tierRange[0], tierRange[1]);
                        const materialType = isMetal ? 'metal' : 'wood';
                        const materialKey = Object.keys(EQUIPMENT_MATERIALS).find(key => EQUIPMENT_MATERIALS[key].tier === tier && EQUIPMENT_MATERIALS[key].type === materialType);
                        
                        if (!materialKey) {
                            this.checkRaidTime();
                            return;
                        }

                        const qualityKey = ['common', 'uncommon'][randomInt(0, 1)];
                        
                        const randomItemType = this.craftableTypes[randomInt(0, this.craftableTypes.length - 1)];
                        const newItem = this.createEquipment(materialKey, qualityKey, randomItemType.baseName);

                        this.player.inventory.push(newItem);
                        this.logMessage('raid', `你在廢墟中找到了 <span style="color:${newItem.quality.color};">[${newItem.name}]</span>！`, 'success');
                    }
                    
                    this.checkRaidTime();
                },
                canAdvance() {
                    if (this.currentRaid && this.currentRaid.currentZone.name === '王城') {
                        const castle = this.currentRaid.currentZone.buildings.find(b => b.isFinalChallenge);
                        // 只有在城堡被偵查後，才允許前進
                        return castle && castle.scouted;
                    }
                    return this.currentRaid && this.currentRaid.currentZoneIndex < this.currentRaid.zones.length - 1 && this.currentRaid.currentZone.enemies.flat().filter(e => e.profession === '城市守軍').length === 0 && this.currentRaid.currentZone.buildings.every(b => b.occupants.filter(o => o.profession === '城市守軍').length === 0);
                },
                advanceToNextZone(force = false) {
                    const castle = this.currentRaid.currentZone.buildings.find(b => b.isFinalChallenge);
                    if (this.currentRaid.currentZone.name === '王城' && castle && castle.scouted) {
                        // [關鍵] 呼叫新函數，而不是移動到下一個zone
                        this.enterThroneRoom(castle.occupants);
                        return;
                    }
                    if (!this.canAdvance() && !force) {
                        this.showCustomAlert('必須先清除此區域的守軍才能前進！');
                        return;
                    }
                    this.currentRaid.timeRemaining -= 5;
                    this.currentRaid.currentZoneIndex++;
                    this.logMessage('raid', `你深入到了 ${this.currentRaid.currentZone.name}。(-5 分鐘)`, 'player');
                },
                sneakPastGuards() {
                    if (!this.currentRaid || this.currentRaid.currentZoneIndex !== 0) return;
                    const guardPost = this.currentRaid.currentZone.buildings.find(b => b.type === '衛兵所');
                    if (!guardPost || guardPost.occupants.length === 0) {
                        this.showCustomAlert('外城沒有守軍可以繞過。');
                        return;
                    }

                    const outerGuards = guardPost.occupants;
                    const playerAgility = this.player.getTotalStat('agility', this.isStarving);
                    const enemyAvgAgility = outerGuards.reduce((sum, e) => sum + e.stats.agility, 0) / outerGuards.length;
                    const successChance = 50 + (playerAgility - enemyAvgAgility) * 1.5 - ((this.player.party.length + 1) - outerGuards.length) * 2;

                    if (roll(successChance)) {
                        this.currentRaid.timeRemaining -= 3;
                        this.logMessage('raid', `潛行成功！你花費了 3 分鐘，悄悄地繞過了守軍。`, 'success');
                        this.advanceToNextZone(true);
                        this.checkRaidTime();
                    } else {
                        this.currentRaid.timeRemaining -= 6;
                        this.logMessage('raid', `潛行失敗！你被守軍發現了！(-6 分鐘)`, 'enemy');
                        this.startCombat(outerGuards, !this.isTargetScouted(outerGuards[0].id));
                        this.checkRaidTime();
                    }
                },
                handleRetreatAction() {
                    if (!this.currentRaid) return;

                    // 如果玩家在最外層（外城），則執行脫離城鎮的最終結算
                    if (this.currentRaid.currentZoneIndex === 0) {
                        
                        // 【新增的俘虜時間成本計算】
                        const baseCost = 5; // 基礎花費 5 分鐘
                        const captiveCost = (this.currentRaid.carriedCaptives.length || 0) * 5; // 每個俘虜額外花費 5 分鐘
                        const totalCost = baseCost + captiveCost;
                        
                        this.currentRaid.timeRemaining -= totalCost;
                        
                        this.logMessage('raid', `你帶著 ${this.currentRaid.carriedCaptives.length} 名俘虜脫離城鎮，花費了 ${totalCost} 分鐘。`, 'player');
                        
                        // 扣除時間後，立即檢查是否會觸發騎士團
                        this.checkRaidTime(); 
                        
                        // 只有在沒有觸發騎士團戰鬥的情況下，才返回部落
                        if (this.currentRaid && this.currentRaid.timeRemaining > 0) {
                            this.prepareToEndRaid();
                        }
                        
                    } else {
                        // 否則，撤退回上一層区域
                        const oldZoneName = this.currentRaid.currentZone.name;
                        this.currentRaid.currentZoneIndex--; // 區域索引減 1
                        this.currentRaid.timeRemaining -= 5; // 消耗 5 分鐘
                        const newZoneName = this.currentRaid.currentZone.name;
                        
                        this.logMessage('raid', `你從 ${oldZoneName} 撤退回了 ${newZoneName}。(-5 分鐘)`, 'player');
                        this.checkRaidTime(); // 檢查時間是否耗盡
                    }
                },
                prepareToEndRaid(wasDefeated = false) {
                    if (wasDefeated) {
                        this.endRaid(true); // 如果是戰敗，直接跳到結束流程
                        return;
                    }
                    
                    const newCaptives = this.currentRaid.carriedCaptives;
                    const currentDungeonCaptives = this.dungeonCaptives;

                    // 【修改】新的觸發條件：當地牢的現有人 + 新抓的人 > 地牢容量時
                    if (currentDungeonCaptives.length + newCaptives.length > this.captiveCapacity) {
                        
                        this.logMessage('tribe', '你帶回的俘虜過多，地牢無法容納！你需要從現有和新增的俘虜中決定去留...', 'warning');

                        // 【修改】只將「原地牢俘虜」和「新抓的俘虜」放入選擇列表
                        this.openCaptiveManagementModal(
                            'raid_return', // 使用一個新的類型來區分這個特殊情境
                            [...currentDungeonCaptives, ...newCaptives],
                            this.captiveCapacity // 上限為地牢的容量
                        );
                    } else {
                        // 容量充足，直接結束掠奪
                        this.endRaid(false);
                    }
                },
                endRaid(wasDefeated = false) {
                    // 判斷是否為玩家戰敗死亡
                    if (wasDefeated && this.player && !this.player.isAlive()) {
                        this.initiateRebirth(); // 觸發重生流程
                        this.selectedTarget = null; // 【新增】確保清除地圖目標
                        return; // 中斷後續的返回部落邏輯
                    }

                    if (this.tutorial.active) {
                        if(this.currentRaid.carriedCaptives.length > 0) {
                            this.advanceTutorial(6);
                        } else {
                            this.tutorial.active = false;
                            this.tutorial.step = 0;
                            this.showCustomAlert('王，您平安歸來了。雖然這次沒有戰利品，但您已熟悉了流程。接下來，請自由探索這個世界吧！');
                        }
                    }

                    if (!wasDefeated) {
                        this.captives.push(...this.currentRaid.carriedCaptives);
                        this.logMessage('tribe', `你帶回了 ${this.currentRaid.carriedCaptives.length} 名俘虜。`, 'player');
                    }
                    
                    this.currentRaid = null;
                    // 【新增】重置掠奪地圖上被選中的目標
                    this.selectedTarget = null; 
                    
                    this.screen = 'tribe';
                    
                    this.player.currentHp = this.player.maxHp;
                    this.partners.forEach(p => p.currentHp = p.maxHp);
                    this.logMessage('tribe', '所有夥伴的生命值都已完全恢復。', 'success');

                    this.finalizeRaidReturn();
                },
                finalizeRaidReturn() {
                    this.currentRaid = null;
                    this.screen = 'tribe';
                    
                    // 恢復所有單位生命值
                    this.player.currentHp = this.player.maxHp;
                    this.partners.forEach(p => p.currentHp = p.maxHp);
                    this.logMessage('tribe', '所有夥伴的生命值都已完全恢復。', 'success');

                    // 呼叫換日，這會增加天數並重置繁衍次數
                    this.nextDay();
                },

                checkRaidTime() {
                    if (this.currentRaid && this.currentRaid.timeRemaining <= 0 && !this.combat.isReinforcementBattle) {
                        // 防止在戰鬥中重複觸發
                        if(this.screen !== 'combat'){
                             this.triggerReinforcementBattle();
                        }
                    }
                },

                executeSneakKidnapFromModal() {
                    if (!this.modals.scoutInfo.target || !Array.isArray(this.modals.scoutInfo.target)) return;

                    const group = this.modals.scoutInfo.target;
                    // 找到群組中第一位活著的女性作為目標
                    const targetFemale = group.find(unit => unit.visual && unit.isAlive());

                    if (targetFemale) {
                        // 檢查是否已對此目標潛行失敗過
                        if (this.currentRaid.failedSneakTargets.has(targetFemale.id)) {
                            this.showCustomAlert(`你已經對 ${targetFemale.name} 潛行失敗過一次，再次嘗試會被直接發現！`);
                            return;
                        }
                        this.modals.scoutInfo.isOpen = false; // 執行前關閉視窗
                        this.sneakKidnap(targetFemale, group); // 呼叫核心潛行邏輯
                    } else {
                        this.showCustomAlert('找不到可下手的目標。');
                    }
                },

                executeSneakKidnapFromMap() {
                    if (!this.selectedTarget || !Array.isArray(this.selectedTarget)) return;

                    const group = this.selectedTarget;
                    const targetFemale = group.find(unit => unit.visual && unit.isAlive());

                    if (targetFemale) {
                        if (this.currentRaid.failedSneakTargets.has(targetFemale.id)) {
                            this.showCustomAlert(`你已經對 ${targetFemale.name} 潛行失敗過一次，再次嘗試會被直接發現！`);
                            return;
                        }
                        this.selectedTarget = null; // 執行前清除選取，隱藏選單
                        this.sneakKidnap(targetFemale, group);
                    } else {
                        // 這個訊息理論上不會出現，因為按鈕的 x-show 已經過濾掉了
                        this.showCustomAlert('該隊伍中沒有可下手的目標。');
                    }
                },

                // 新增函數：觸發騎士團增援戰
                triggerReinforcementBattle() {
                    if (!this.currentRaid) return; // 安全檢查

                    this.logMessage('raid', '時間已到！王國騎士團的增援部隊抵達了城鎮！', 'enemy');

                    // 根據 GDD 6.3 規則生成騎士團隊伍
                    const difficulty = this.currentRaid.difficulty;
                    let knightSquad = [];
                    const squadComposition = {
                        easy:   { '士兵': 3, '盾兵': 2 },
                        normal: { '士兵': 4, '盾兵': 3, '槍兵': 2, '弓兵': 1 },
                        hard:   { '士兵': 5, '盾兵': 3, '槍兵': 3, '弓兵': 2, '騎士': 1, '法師': 1 },
                        hell:   { '士兵': 6, '盾兵': 4, '槍兵': 4, '弓兵': 2, '騎士': 2, '法師': 1, '祭司': 1 }
                    };
                    const knightStatRanges = {
                        easy: [80, 150],
                        normal: [150, 240],
                        hard: [240, 350],
                        hell: [350, 450]
                    };

                    const composition = squadComposition[difficulty];
                    const statRange = knightStatRanges[difficulty];

                    if (composition) {
                        for (const unitType in composition) {
                            for (let i = 0; i < composition[unitType]; i++) {
                                const totalStatPoints = randomInt(statRange[0], statRange[1]);
                                let knight; // <--- 宣告變數
                                if (roll(50)) {
                                    knight = new FemaleKnightOrderUnit(unitType, totalStatPoints);
                                } else {
                                    knight = new KnightOrderUnit(unitType, totalStatPoints);
                                }
                                this.equipEnemy(knight, difficulty); // <--- 在此處加入呼叫
                                knightSquad.push(knight);
                            }
                        }
                    }
                    
                    // 標記這是一場無法逃脫的增援戰
                    this.combat.isReinforcementBattle = true; 
                    
                    // 開始戰鬥，設定敵人先攻
                    this.startCombat(knightSquad, true); 
                },

                sneakKidnap(target, group) {
                    const playerAgility = this.player.getTotalStat('agility', this.isStarving);
                    const enemyAgility = target.stats.agility;
                    const sneakChance = 50 + (playerAgility - enemyAgility) * 1.5 - (this.player.party.length + 1 - 1) * 2;
                    const successChance = sneakChance - 15;

                    if (roll(successChance)) {
                        this.currentRaid.timeRemaining -= 3;
                        this.logMessage('raid', `潛行擄走 ${target.name} 成功！(-3 分鐘)`, 'success');
                        this.addCaptiveToCarry(target);
                        this.gainResourcesFromEnemy(target);
                        this.currentRaid.currentZone.enemies = this.currentRaid.currentZone.enemies.map(g => g.filter(e => e.id !== target.id)).filter(g => g.length > 0);
                        this.checkRaidTime();
                    } else {
                        this.currentRaid.timeRemaining -= 6;
                        this.currentRaid.failedSneakTargets.add(target.id);
                        this.logMessage('raid', `潛行擄走 ${target.name} 失敗，你被發現了！(-6 分鐘)`, 'enemy');
                        this.startCombat(group, true);
                        this.checkRaidTime();
                    }
                },

                startCombat(enemyGroup, enemyFirstStrike = false) {
                    this.combat.allies = [this.player, ...this.player.party].filter(u => u.isAlive());
                    this.combat.enemies = enemyGroup.filter(u => u.isAlive());
                    this.combat.currentEnemyGroup = enemyGroup;
                    this.combat.turn = 1;
                    this.combat.isProcessing = false;
                    this.combat.playerActionTaken = false;
                    
                    this.screen = 'combat';
                    this.logs.combat = [];
                    this.logMessage('combat', `戰鬥開始！`, 'system');
                    
                    if(enemyFirstStrike) {
                        this.logMessage('combat', '敵人發動了突襲！', 'enemy');
                        this.executeTurn(true); 
                    } else {
                        this.logMessage('combat', '等待你的指令...', 'system');
                    }
                },
                async executePlayerAction(action) {
                    if (this.combat.isProcessing || this.combat.playerActionTaken || !this.player || !this.player.isAlive()) return;
                    this.combat.playerActionTaken = true;
                    
                    let continueToEnemyTurn = true;

                    if (action === 'attack') {
                        const livingEnemies = this.combat.enemies.filter(t => t.isAlive());
                        if (livingEnemies.length > 0) {
                            const target = livingEnemies[randomInt(0, livingEnemies.length - 1)];
                            await this.processAttack(this.player, target, false);
                        }
                    } else if (action === 'escape') {
                        const result = await this.attemptSneakEscape();
                        if (result === 'escaped') {
                            continueToEnemyTurn = false;
                        }
                    }

                    if (continueToEnemyTurn && this.combat.enemies.filter(e => e.isAlive()).length > 0) {
                        this.executeTurn(false);
                    } else if (!continueToEnemyTurn) {
                        
                    } else {
                        this.endCombat(true);
                    }
                },
                async executeTurn(isEnemyFirstStrike = false) {
                    if (this.combat.isProcessing) return;
                    this.combat.isProcessing = true;

                    if (this.combat.turn > 15) {
                        const oldestTurnToKeep = this.combat.turn - 15;
                        this.logs.combat = this.logs.combat.filter(entry => entry.turn >= oldestTurnToKeep);
                    }
                    
                    // 【修改】將消耗時間的邏輯包裹在條件判斷中
                    if (this.currentRaid) {
                        // 如果是在掠奪中，才消耗時間並顯示倒數
                        this.currentRaid.timeRemaining--;
                        this.checkRaidTime();
                        this.logMessage('combat', `--- 第 ${this.combat.turn} 回合 (-1 分鐘) ---`, 'system');
                    } else {
                        // 如果不是在掠奪中 (例如部落防衛戰)，則不消耗時間
                        this.logMessage('combat', `--- 第 ${this.combat.turn} 回合 ---`, 'system');
                    }

                    const livingEnemies = this.combat.enemies.filter(e => e.isAlive());
                    for (const unit of livingEnemies) {
                        if (!unit.isAlive()) continue;
                        await this.processAiAction(unit);
                    }
                    
                    await new Promise(res => setTimeout(res, 200));

                    if (!isEnemyFirstStrike) {
                        const livingPartners = this.combat.allies.filter(p => p.id !== this.player.id && p.isAlive());
                        for (const unit of livingPartners) {
                               if (!unit.isAlive()) continue;
                               await this.processAiAction(unit);
                        }
                    }
                    this.tickStatusEffects();
                    [...this.combat.allies, ...this.combat.enemies].forEach(u => u.tickCooldowns());

                    const livingAlliesCount = this.combat.allies.filter(u => u.isAlive()).length;
                    const livingEnemiesCount = this.combat.enemies.filter(u => u.isAlive()).length;

                    if (livingAlliesCount === 0) {
                        this.logMessage('combat', `戰鬥失敗... 你的隊伍被全滅了。`, 'enemy');
                        this.endCombat(false);
                    } else if (livingEnemiesCount === 0) {
                        this.logMessage('combat', `戰鬥勝利！`, 'success');
                        this.endCombat(true);
                    } else { // Battle continues
                    this.combat.turn++;
                    this.combat.isProcessing = false;

                    // 【核心修正】檢查哥布林王是否存活
                    if (!this.player.isAlive()) {
                        // 王陣亡，但夥伴還在，觸發自動戰鬥
                        this.logMessage('combat', '哥布林王倒下了！夥伴們將繼續戰鬥！', 'system');
                        // 延遲後自動進入下一回合
                        setTimeout(() => this.executeTurn(false), 1500); // 延遲1.5秒讓玩家閱讀戰報
                    } else {
                        // 王還活著，恢復正常流程，等待玩家指令
                        this.combat.playerActionTaken = false;
                        this.logMessage('combat', '等待你的指令...', 'system');
                    }
                }
                },
                async processAiAction(attacker) {
                    const isAlly = this.combat.allies.some(a => a.id === attacker.id);
                    const allies = isAlly ? this.combat.allies.filter(u => u.isAlive()) : this.combat.enemies.filter(u => u.isAlive());
                    const enemies = isAlly ? this.combat.enemies.filter(u => u.isAlive()) : this.combat.allies.filter(u => u.isAlive());

                    if (enemies.length === 0) return;

                    let actionTaken = false;

                    if (attacker.skills && attacker.skills.length > 0) {
                        const skill = attacker.skills[0];
                        if (skill.currentCooldown === 0) {
                            if (skill.type === 'team_heal') {
                                const totalMaxHp = allies.reduce((sum, a) => sum + a.maxHp, 0);
                                const totalCurrentHp = allies.reduce((sum, a) => sum + a.currentHp, 0);
                                if ((totalCurrentHp / totalMaxHp) < skill.triggerHp) {
                                    await this.executeSkill(skill, attacker, allies, enemies);
                                    actionTaken = true;
                                }
                            } else {
                                // 【新增檢查】檢查施法者身上是否已經有同類型的技能效果
                                const isEffectActive = attacker.statusEffects.some(e => e.type === skill.type);

                                // 只有當效果未生效時，才施放技能
                                if (!isEffectActive) {
                                    await this.executeSkill(skill, attacker, allies, enemies);
                                    actionTaken = true;
                                }
                                // 如果 isEffectActive 為 true，則 actionTaken 保持 false，AI會接著執行普通攻擊
                            }
                        }
                    }
                    
                    const chargingEffect = attacker.statusEffects.find(e => e.type === 'charge_nuke');
                    if (chargingEffect) {
                        if (chargingEffect.chargeTurns <= 0) {
                            this.logMessage('combat', `[${attacker.name}] 的 [破滅法陣] 詠唱完畢！`, 'skill');
                            const damage = Math.floor(attacker.getTotalStat('intelligence') * chargingEffect.multiplier);
                            for (const target of enemies) {
                                if (target.isAlive()) {
                                    target.currentHp = Math.max(0, target.currentHp - damage);
                                    this.logMessage('combat', `法陣衝擊了 ${target.name}，造成 ${damage} 點無法閃避的傷害。`, 'enemy');
                                    if (!target.isAlive()) this.logMessage('combat', `${target.name} 被擊敗了！`, 'system');
                                }
                            }
                            attacker.statusEffects = attacker.statusEffects.filter(e => e.type !== 'charge_nuke');
                        } else {
                            this.logMessage('combat', `${attacker.name} 正在詠唱... (剩餘 ${chargingEffect.chargeTurns} 回合)`, 'info');
                        }
                        actionTaken = true;
                    }

                    if (!actionTaken) {
                        const target = enemies[randomInt(0, enemies.length - 1)];
                        await this.processAttack(attacker, target, false);
                    }
                    
                    await new Promise(res => setTimeout(res, 300));
                },
                async processAttack(attacker, target, isMultiHit = false) {
                    const isAllyAttacking = this.combat.allies.some(a => a.id === attacker.id);
                    const enemyTeam = isAllyAttacking ? this.combat.enemies : this.combat.allies;
                    let currentTarget = target;

                    // --- 嘲諷檢查 ---
                    const taunter = enemyTeam.find(e => e.statusEffects.some(s => s.type === 'taunt'));
                    if (taunter && taunter.id !== currentTarget.id && taunter.isAlive()) {
                        this.logMessage('combat', `${attacker.name} 的攻擊被 ${taunter.name} 吸引了！`, 'info');
                        currentTarget = taunter;
                    }

                    // --- 【核心修改】格擋判定 ---
                    const targetHasShield = currentTarget.equipment?.offHand?.baseName === '盾';
                    if (targetHasShield && currentTarget.isAlive()) {
                        const luckConversionRate = 0.1; // 幸運轉換率 (10%)
                        const blockEfficiency = 0.5; // 格擋效率 (減傷50%)
                        
                        const baseBlockChance = currentTarget.equipment.offHand.stats.blockChance || 0;
                        const luckValue = currentTarget.getTotalStat('luck', this.isStarving);
                        const finalBlockChance = baseBlockChance + (luckValue / 100) * (luckConversionRate * 100);

                        if (roll(finalBlockChance)) {
                            let originalDamage = attacker.calculateDamage(this.isStarving);
                            let reducedDamage = Math.floor(originalDamage * (1 - blockEfficiency));
                            
                            this.logMessage('combat', `${currentTarget.name} 成功格擋了攻擊！`, 'skill');
                            this.logMessage('combat', `${attacker.name} 對 ${currentTarget.name} 造成了 ${reducedDamage} 點被格擋的傷害。`, isAllyAttacking ? 'player' : 'enemy');

                            currentTarget.currentHp = Math.max(0, currentTarget.currentHp - reducedDamage);
                            if (!currentTarget.isAlive()) {
                                this.logMessage('combat', `${currentTarget.name} 被擊敗了！`, 'system');
                            }
                            // 格擋成功後，攻擊流程直接結束
                            return; 
                        }
                    }

                    // --- 如果格擋未發生，則進行正常的命中與傷害計算 ---
                    const isChargingNuke = currentTarget.statusEffects.some(e => e.type === 'charge_nuke');
                    const hitChance = 75 + (attacker.getTotalStat('agility', this.isStarving) - currentTarget.getTotalStat('agility', this.isStarving)) * 2;
                    const logType = isAllyAttacking ? 'player' : 'enemy';

                    if (isChargingNuke || roll(hitChance)) {
                        if (isChargingNuke) {
                            this.logMessage('combat', `${currentTarget.name} 正在詠唱，無法閃避！`, 'info');
                        }

                        let damage = attacker.calculateDamage(this.isStarving);
                        const critChance = 5 + 10 * Math.log10(attacker.getTotalStat('luck', this.isStarving) || 1);
                        let isCrit = roll(critChance);
                        let critMultiplier = 1.5;
                        const devastatingAffix = Object.values(attacker.equipment || {}).flatMap(i => i ? i.affixes : []).find(a => a.key === 'devastating');
                        
                        if (isCrit && devastatingAffix) {
                            critMultiplier = devastatingAffix.procInfo.value;
                            this.logMessage('combat', `${attacker.name} 的 [毀滅] 詞綴觸發了！爆擊更為致命！`, 'skill');
                        }

                        if(isCrit) {
                            damage = Math.floor(damage * critMultiplier); 
                            this.logMessage('combat', `幸運觸發！ ${attacker.name} 攻擊 ${currentTarget.name}，造成 ${damage} 點爆擊傷害。`, 'crit');
                        } else {
                            this.logMessage('combat', `${attacker.name} 攻擊 ${currentTarget.name}，造成 ${damage} 點傷害。`, logType);
                        }
                        
                        // 後續的反傷、吸血等詞綴邏輯...
                        currentTarget.currentHp = Math.max(0, currentTarget.currentHp - damage);

                        if (!currentTarget.isAlive()) {
                            this.logMessage('combat', `${currentTarget.name} 被擊敗了！`, 'system');
                            if (!this.combat.allies.some(a => a.id === currentTarget.id)) {
                                this.gainResourcesFromEnemy(currentTarget);
                                this.handleLootDrop(currentTarget);
                            } else if (currentTarget.id !== this.player.id) {
                                this.handlePartnerDeath(currentTarget.id);
                            }
                        }
                    } else {
                        this.logMessage('combat', `${attacker.name} 的攻擊被 ${currentTarget.name} 閃過了！`, logType === 'player' ? 'enemy' : 'player');
                    }
                    
                    // 後續的連擊等詞綴邏輯...
                    if (attacker.isAlive() && currentTarget.isAlive() && !isMultiHit) {
                        if (attacker.equipment) {
                            const multiHitAffix = Object.values(attacker.equipment).flatMap(i => i ? i.affixes : []).find(a => a.key === 'multi_hit');
                            if (multiHitAffix && roll(this.calculateProcChance(multiHitAffix.procInfo.baseRate))) {
                                this.logMessage('combat', `${attacker.name} 的 [連擊] 詞綴觸發，發動了額外攻擊！`, 'skill');
                                await new Promise(res => setTimeout(res, 400));
                                await this.processAttack(attacker, currentTarget, true);
                            }
                        }
                    }
                },
                gainResourcesFromEnemy(enemy) {
                    // 【新增】如果不是在掠奪中 (例如部落防衛戰)，則不掉落資源，直接返回。
                    if (!this.currentRaid) {
                        return;
                    }

                    const dropConfig = {
                        easy:   { res: [5, 10],  guard: [10, 15] },
                        normal: { res: [10, 20], guard: [20, 30] },
                        hard:   { res: [20, 40], guard: [40, 60] },
                        hell:   { res: [40, 80], guard: [80, 120] },
                    };
                    const difficulty = this.currentRaid.difficulty;
                    let foodDrop = 0, woodDrop = 0, stoneDrop = 0;

                    if (enemy.profession.includes('居民')) {
                        foodDrop = randomInt(dropConfig[difficulty].res[0], dropConfig[difficulty].res[1]);
                        woodDrop = randomInt(dropConfig[difficulty].res[0], dropConfig[difficulty].res[1]);
                        this.resources.food = Math.min(this.foodCapacity, this.resources.food + foodDrop);
                        this.resources.wood = Math.min(this.woodCapacity, this.resources.wood + woodDrop);
                        this.logMessage('raid', `你獲得了 食物x${foodDrop}, 木材x${woodDrop}。`, 'success');
                    } else if (enemy.profession.includes('守軍')) {
                        foodDrop = randomInt(dropConfig[difficulty].guard[0], dropConfig[difficulty].guard[1]);
                        stoneDrop = randomInt(dropConfig[difficulty].guard[0], dropConfig[difficulty].guard[1]);
                        this.resources.food = Math.min(this.foodCapacity, this.resources.food + foodDrop);
                        this.resources.stone = Math.min(this.stoneCapacity, this.resources.stone + stoneDrop);
                        this.logMessage('raid', `你獲得了 食物x${foodDrop}, 礦石x${stoneDrop}。`, 'success');
                    }
                },
                handleLootDrop(enemy) {
                    const baseDropRates = { '居民': 10, '女性居民': 10, '城市守軍': 30 };
                    const isKnight = Object.keys(KNIGHT_ORDER_UNITS).includes(enemy.profession);
                    
                    const baseDropRate = isKnight ? 50 : (baseDropRates[enemy.profession] || 0);
                    if (baseDropRate === 0) return;

                    const finalDropRate = baseDropRate * (1 + (this.player.getTotalStat('luck') / 100) * 0.5);

                    if (roll(finalDropRate)) {
                        if (this.player.inventory.length >= this.backpackCapacity) {
                            this.logMessage('raid', `你的背包已滿，無法拾取新的裝備！`, 'enemy');
                            return;
                        }

                        // 【核心修正】智能判斷難度來源
                        let encounterDifficulty = 'easy'; // 設定一個安全的預設值
                        if (this.currentRaid) {
                            // 如果是掠奪戰，使用掠奪的難度
                            encounterDifficulty = this.currentRaid.difficulty;
                        } else if (enemy.originDifficulty) {
                            // 如果是非掠奪戰（如復仇小隊），使用敵人自身的難度屬性
                            encounterDifficulty = enemy.originDifficulty;
                        }

                        const materialTiers = {
                            easy: { metal: [1, 3], wood: [1, 3] },
                            normal: { metal: [2, 4], wood: [2, 4] },
                            hard: { metal: [3, 5], wood: [3, 5] },
                            hell: { metal: [4, 6], wood: [4, 6] },
                        };
                        const qualityTiers = {
                            '居民': ['worn', 'common'],
                            '女性居民': ['worn', 'common'],
                            '城市守軍': ['uncommon', 'rare'],
                            'knight': ['epic', 'legendary']
                        };

                        const possibleTiers = materialTiers[encounterDifficulty]; // 使用修正後的難度變數
                        
                        const isMetal = roll(50);
                        const tierRange = isMetal ? possibleTiers.metal : possibleTiers.wood;
                        const tier = randomInt(tierRange[0], tierRange[1]);
                        const materialType = isMetal ? 'metal' : 'wood';
                        const materialKey = Object.keys(EQUIPMENT_MATERIALS).find(key => EQUIPMENT_MATERIALS[key].tier === tier && EQUIPMENT_MATERIALS[key].type === materialType);
                        
                        if (!materialKey) return;

                        const qualitySource = isKnight ? 'knight' : enemy.profession;
                        const possibleQualities = qualityTiers[qualitySource] || ['worn'];
                        const qualityKey = possibleQualities[randomInt(0, possibleQualities.length - 1)];

                        const randomItemType = this.craftableTypes[randomInt(0, this.craftableTypes.length - 1)];
                        const newItem = this.createEquipment(materialKey, qualityKey, randomItemType.baseName);
                        
                        this.player.inventory.push(newItem);
                        
                        if (this.tutorial.active && !this.tutorial.finishedEquipping) {
                            this.triggerTutorial('firstLoot');
                        }
                        this.logMessage('raid', `你從 ${enemy.name} 身上獲得了 <span style="color:${newItem.quality.color};">[${newItem.name}]</span>！`, 'success');
                    }
                },
                // 【最終版本】為敵人穿戴裝備的智慧助手函式
                equipEnemy(enemy, difficulty) {
                    if (!enemy || !enemy.equipment) return;

                    const isKnight = Object.keys(KNIGHT_ORDER_UNITS).includes(enemy.profession);

                    // ------------------------------------------------------------------
                    // I. 騎士團 (Knight Order) 的專屬裝備邏輯
                    // ------------------------------------------------------------------
                    if (isKnight) {
                        const qualityKey = 'epic'; // 騎士團固定穿史詩品質

                        // 輔助函式：根據難度和可選的材質類型，獲取一個隨機材質
                        const getRandomMaterialKey = (type = null) => {
                            const materialTiers = {
                                easy:   { metal: [2, 3], wood: [2, 3] }, // 騎士團最低也從Tier 2開始
                                normal: { metal: [3, 4], wood: [3, 4] },
                                hard:   { metal: [4, 5], wood: [4, 5] },
                                hell:   { metal: [5, 6], wood: [5, 6] },
                            };
                            const possibleTiers = materialTiers[difficulty] || materialTiers['easy'];
                            
                            const materialType = type || (roll(50) ? 'metal' : 'wood');
                            const tierRange = possibleTiers[materialType];
                            const tier = randomInt(tierRange[0], tierRange[1]);
                            
                            return Object.keys(EQUIPMENT_MATERIALS).find(key => 
                                EQUIPMENT_MATERIALS[key].tier === tier && EQUIPMENT_MATERIALS[key].type === materialType
                            );
                        };

                        // 輔助函式：建立一件指定裝備
                        const createAndEquip = (slot, baseName, materialType = null) => {
                            const materialKey = getRandomMaterialKey(materialType);
                            if (!materialKey) return;
                            const item = this.createEquipment(materialKey, qualityKey, baseName, null, true);
                            enemy.equipment[slot] = item;
                        };

                        // 1. 所有騎士團成員必穿身體盔甲
                        createAndEquip('chest', '鎧甲', enemy.profession === '盾兵' ? 'wood' : null);

                        // 2. 根據職業分配武器和副手
                        switch (enemy.profession) {
                            case '士兵':
                                createAndEquip('mainHand', '劍');
                                if (roll(50)) { // 50%機率雙持
                                    createAndEquip('offHand', '劍');
                                } else { // 50%機率劍盾
                                    createAndEquip('offHand', '盾');
                                }
                                break;
                            case '盾兵':
                                // 盾兵必拿木盾，身體盔甲在上面已經指定為木材質
                                createAndEquip('offHand', '盾', 'wood');
                                break;
                            case '槍兵':
                                createAndEquip('mainHand', '長槍');
                                if (roll(50)) { // 50%機率持盾
                                    createAndEquip('offHand', '盾');
                                }
                                break;
                            case '法師':
                                createAndEquip('mainHand', '法杖');
                                break;
                            case '弓兵': // 遊戲內代碼為'弓兵'
                                createAndEquip('mainHand', '弓');
                                break;
                            case '祭司':
                                createAndEquip('mainHand', '法杖');
                                createAndEquip('offHand', '盾', 'wood'); // 副手必為木盾
                                break;
                            case '騎士':
                                if (roll(50)) { // 50%機率劍盾
                                    createAndEquip('mainHand', '劍');
                                } else { // 50%機率槍盾
                                    createAndEquip('mainHand', '長槍');
                                }
                                createAndEquip('offHand', '盾'); // 副手必為盾
                                break;
                            default: // 其他未定義的騎士團職業，給予預設裝備
                                createAndEquip('mainHand', '劍');
                                createAndEquip('offHand', '盾');
                                break;
                        }

                    // ------------------------------------------------------------------
                    // II. 守軍與居民 (Guard & Resident) 的裝備邏輯
                    // ------------------------------------------------------------------
                    } else {
                        let numPieces = 0;
                        let qualityKey = 'worn';
                        // (此處邏輯與上一版相同)
                        if (enemy.profession === '城市守軍') {
                            numPieces = randomInt(1, 2);
                            qualityKey = 'uncommon';
                        } else if (enemy.profession.includes('居民')) {
                            if (roll(50)) {
                                numPieces = 1;
                                qualityKey = 'worn';
                            } else {
                                return;
                            }
                        } else {
                            return;
                        }
                        // (後續的通用裝備生成邏輯也與上一版相同)
                        const materialTiers = {
                            easy: { metal: [1, 3], wood: [1, 3] },
                            normal: { metal: [2, 4], wood: [2, 4] },
                            hard: { metal: [3, 5], wood: [3, 5] },
                            hell: { metal: [4, 6], wood: [4, 6] },
                        };
                        const possibleTiers = materialTiers[difficulty] || materialTiers['easy'];
                        
                        let possibleSlots = ['mainHand', 'chest', 'offHand'];
                        for (let i = 0; i < numPieces; i++) {
                            if (possibleSlots.length === 0) break;
                            const slotIndex = randomInt(0, possibleSlots.length - 1);
                            const slot = possibleSlots.splice(slotIndex, 1)[0];
                            let baseItem = this.craftableTypes.find(t => t.slot === slot) || this.craftableTypes[0];
                            if (slot === 'offHand') baseItem = this.craftableTypes.find(t => t.baseName === '盾');
                            if (!baseItem) continue;

                            const isMetal = roll(50);
                            const tierRange = isMetal ? possibleTiers.metal : possibleTiers.wood;
                            const tier = randomInt(tierRange[0], tierRange[1]);
                            const materialType = isMetal ? 'metal' : 'wood';
                            const materialKey = Object.keys(EQUIPMENT_MATERIALS).find(key => 
                                EQUIPMENT_MATERIALS[key].tier === tier && EQUIPMENT_MATERIALS[key].type === materialType
                            );
                            if (!materialKey) continue;

                            const newItem = this.createEquipment(materialKey, qualityKey, baseItem.baseName, null, true);
                            enemy.equipment[slot] = newItem;
                        }
                    }

                    // ------------------------------------------------------------------
                    // III. 最後更新敵人狀態 (通用)
                    // ------------------------------------------------------------------
                    if (enemy.updateHp) {
                        enemy.updateHp(this.isStarving);
                    } else {
                        enemy.maxHp = enemy.calculateMaxHp(this.isStarving);
                        enemy.currentHp = enemy.maxHp;
                    }
                },
                createEquipment(materialKey, qualityKey, baseName, specialAffix = null, forceNoAffix = false) {
                    const material = EQUIPMENT_MATERIALS[materialKey];
                    const quality = EQUIPMENT_QUALITIES[qualityKey];
                    const baseItem = this.craftableTypes.find(t => t.baseName === baseName);
                    
                    const newItem = new Equipment(baseItem.baseName, baseItem.type, baseItem.slot, material, quality, specialAffix);
                    
                    const baseStats = BASE_EQUIPMENT_STATS[material.type][baseItem.baseName][material.tier];
                    
                    // 1. 計算基礎屬性
                    for (const stat in baseStats) {
                        newItem.stats[stat] = Math.floor(baseStats[stat] * quality.multiplier);
                    }                    
                    // 2. 如果不是特殊詛咒裝備，就生成標準詞綴
                    if (!specialAffix && !forceNoAffix) {
                        const affixCountRange = quality.affixes;
                        const affixCount = randomInt(affixCountRange[0], affixCountRange[1]);
                        
                        let availableAffixes = Object.keys(STANDARD_AFFIXES);
                        
                        for (let i = 0; i < affixCount && availableAffixes.length > 0; i++) {
                            const randomAffixKey = availableAffixes[randomInt(0, availableAffixes.length - 1)];
                            const selectedAffix = { ...STANDARD_AFFIXES[randomAffixKey], key: randomAffixKey }; // 複製一份並加上key
                            
                            newItem.affixes.push(selectedAffix);
                            
                            // 移除已選中的和所有衝突的詞綴，防止再次選中
                            availableAffixes = availableAffixes.filter(key => {
                                if (key === randomAffixKey) return false;
                                if (selectedAffix.conflicts && selectedAffix.conflicts.includes(key)) return false;
                                const otherAffix = STANDARD_AFFIXES[key];
                                if (otherAffix.conflicts && otherAffix.conflicts.includes(randomAffixKey)) return false;
                                return true;
                            });
                        }
                    }                  
                    // 3. 更新最終名稱
                    newItem.name = newItem.generateName();
                    
                    return newItem;
                },
                handlePartnerDeath(partnerId) {
                    const partner = this.partners.find(p => p.id === partnerId);
                    if (partner) {
                        this.logMessage('combat', `你的夥伴 ${partner.name} 在戰鬥中陣亡了！他將永遠離開你...`, 'enemy');
                        this.partners = this.partners.filter(p => p.id !== partnerId);
                        this.player.party = this.player.party.filter(p => p.id !== partnerId);
                        this.player.updateHp(this.isStarving);
                    }
                },
                async attemptSneakEscape() {
                    return new Promise(resolve => {
                        const playerAgility = this.player.getTotalStat('agility', this.isStarving);
                        const enemyAvgAgility = this.combat.enemies.reduce((sum, e) => sum + e.stats.agility, 0) / this.combat.enemies.length;
                        const successChance = 50 + (playerAgility - enemyAvgAgility) * 1.5 - (this.combat.allies.length - this.combat.enemies.length) * 2;
                    
                        this.logMessage('combat', '你嘗試潛行脫離戰鬥...', 'player');

                        setTimeout(() => {
                            if (roll(successChance)) {
                                this.logMessage('combat', '脫離成功！', 'success');
                                this.finishCombatCleanup();
                                resolve('escaped');
                            } else {
                                this.logMessage('combat', '脫離失敗！', 'enemy');
                                resolve('failed');
                            }
                        }, 500);
                    });
                },

                // 請用以下程式碼替換您原本的 endCombat 函式
                endCombat(victory) {
                    // --- 新增：處理非掠奪戰鬥（如復仇小隊）---
                    if (!this.currentRaid) {
                        if (victory) {
                            this.logMessage('tribe', '你成功擊退了來襲的敵人！', 'success');

                            // 處理俘虜
                            const defeatedFemales = this.combat.enemies.filter(e => e instanceof FemaleHuman && !e.isAlive());
                            if (defeatedFemales.length > 0) {
                                if ((this.dungeonCaptives.length + defeatedFemales.length) > this.captiveCapacity) {
                                    this.logMessage('tribe', '地牢空間不足，你需要決定俘虜的去留...', 'warning');
                                    this.pendingDecisions.push({
                                        type: 'dungeon',
                                        list: [...this.dungeonCaptives, ...defeatedFemales],
                                        limit: this.captiveCapacity,
                                        context: { postBattleBirths: this.postBattleBirths }
                                    });
                                } else {
                                    this.captives.push(...defeatedFemales);
                                    this.logMessage('tribe', `你俘虜了 ${defeatedFemales.length} 名戰敗的敵人。`, 'info');
                                }
                            }

                            // 恢復狀態
                            this.player.currentHp = this.player.maxHp;
                            this.partners.forEach(p => p.currentHp = p.maxHp);
                            
                            // 處理戰鬥前暫停的出生事件
                            (this.postBattleBirths || []).forEach(mother => this.giveBirth(mother));
                            this.postBattleBirths = [];

                            // 清理戰鬥狀態並返回部落畫面
                            this.finishCombatCleanup(true);

                            // **核心修正**：呼叫新函式，繼續當天的剩餘流程
                            this.continueNextDay();
                        } else {
                            // 戰敗邏輯不變，直接觸發重生
                            this.prepareToEndRaid(true);
                        }
                        return; // 結束函式，不再執行後續的掠奪邏輯
                    }

                    // --- 原有的掠奪戰鬥處理邏輯（維持不變）---
                    if (victory) {
                        const defeatedFemales = this.combat.enemies.filter(e => e instanceof FemaleHuman && !e.isAlive());
                        if (defeatedFemales.length > 0) {
                            this.currentRaid.carriedCaptives.push(...defeatedFemales);
                        }
                        
                        if (this.player && !this.player.isAlive()) {
                            this.logMessage('tribe', '夥伴們獲得了勝利！牠們將倒下的哥布林王帶回了部落。', 'success');
                        }

                        if (this.combat.isReinforcementBattle) {
                            this.logMessage('tribe', '你擊敗了騎士團增援，成功征服了城鎮！', 'success');
                            if (this.currentRaid.carriedCaptives.length > this.carryCapacity) {
                                this.openCaptiveManagementModal('raid', this.currentRaid.carriedCaptives, this.carryCapacity);
                            } else {
                                this.prepareToEndRaid(false);
                            }
                        } else {
                            if (this.currentRaid.carriedCaptives.length > this.carryCapacity) {
                                this.openCaptiveManagementModal('raid', this.currentRaid.carriedCaptives, this.carryCapacity);
                            } else {
                                this.finishCombatCleanup();
                            }
                        }
                    } else { 
                        this.prepareToEndRaid(true);
                    }
                },

                tickStatusEffects() {
                    const allUnitsForRegen = [...this.combat.allies, ...this.combat.enemies];
                    allUnitsForRegen.forEach(unit => {
                        if (!unit.isAlive() || !unit.equipment) return;
                        
                        const regeneratingAffix = Object.values(unit.equipment).flatMap(i => i ? i.affixes : []).find(a => a.key === 'regenerating');
                        if (regeneratingAffix) {
                            const healAmount = Math.floor(unit.maxHp * regeneratingAffix.procInfo.value);
                            if (healAmount > 0) {
                                unit.currentHp = Math.min(unit.maxHp, unit.currentHp + healAmount);
                                this.logMessage('combat', `${unit.name} 的 [再生] 詞綴發動，恢復了 ${healAmount} 點生命。`, 'skill');
                            }
                        }
                    });
                    const allUnits = [...this.combat.allies, ...this.combat.enemies];
                    allUnits.forEach(unit => {
                        if (!unit.statusEffects) unit.statusEffects = [];
                        unit.statusEffects.forEach(effect => {
                            if(effect.duration > 0) effect.duration--;
                            if(effect.type === 'charge_nuke' && effect.chargeTurns > 0) effect.chargeTurns--;
                        });
                        unit.statusEffects = unit.statusEffects.filter(effect => effect.duration > 0);
                    });
                },
                async executeSkill(skill, caster, allies, enemies) {
                    this.logMessage('combat', `${caster.name} 施放了 <span class="text-pink-400">[${skill.name}]</span>！`, 'skill');
                    if(caster.skills[0]) caster.skills[0].currentCooldown = skill.cd;

                    switch (skill.type) {
                        case 'aoe_str':
                        case 'aoe_agi':
                            const damageStat = skill.type === 'aoe_str' ? 'strength' : 'agility';
                            const damage = Math.floor(caster.getTotalStat(damageStat) * skill.multiplier);
                            for (const target of enemies) {
                                if (target.isAlive()) {
                                    target.currentHp = Math.max(0, target.currentHp - damage);
                                    this.logMessage('combat', `[${skill.name}] 對 ${target.name} 造成了 ${damage} 點傷害。`, 'enemy');
                                    if (!target.isAlive()) this.logMessage('combat', `${target.name} 被擊敗了！`, 'system');
                                }
                            }
                            break;
                        case 'taunt':
                            caster.statusEffects.push({ type: 'taunt', duration: skill.duration + 1 });
                            this.logMessage('combat', `${caster.name} 吸引了所有人的注意！`, 'info');
                            break;
                        case 'reflect_buff':
                            const existingBuff = allies.some(a => a.statusEffects.some(e => e.type === 'reflect_buff'));
                            if (!existingBuff) {
                                allies.forEach(ally => ally.statusEffects.push({ type: 'reflect_buff', duration: skill.duration, damagePercent: skill.damagePercent }));
                                this.logMessage('combat', '騎士團啟用了槍陣，攻擊他們將會反噬自身！', 'info');
                            }
                            break;
                        case 'king_nuke':
                            const king = enemies.find(e => e.id === this.player.id);
                            if (king && king.isAlive()) {
                                const kingDamage = caster.getTotalStat('strength') + caster.getTotalStat('agility');
                                king.currentHp = Math.max(0, king.currentHp - kingDamage);
                                this.logMessage('combat', `[騎士道] 無視了你的夥伴，對哥布林王造成了 ${kingDamage} 點巨大傷害！`, 'enemy');
                                if (!king.isAlive()) this.logMessage('combat', `${king.name} 被擊敗了！`, 'system');
                            }
                            break;
                        case 'charge_nuke':
                            caster.statusEffects.push({ type: 'charge_nuke', duration: skill.chargeTime + 1, chargeTurns: skill.chargeTime });
                            this.logMessage('combat', `${caster.name} 開始詠唱咒文，空氣變得凝重起來...`, 'info');
                            break;
                        case 'team_heal':
                            const healAmount = caster.getTotalStat('intelligence') * allies.length;
                            allies.forEach(ally => {
                                if(ally.isAlive()) {
                                    ally.currentHp = Math.min(ally.maxHp, ally.currentHp + healAmount);
                                }
                            });
                            this.logMessage('combat', `聖光籠罩了騎士團，每名成員恢復了 ${healAmount} 點生命！`, 'success');
                            break;
                    }
                    await new Promise(res => setTimeout(res, 500));
                },
                addCaptiveToCarry(newCaptives) {
                    const captivesToAdd = Array.isArray(newCaptives) ? newCaptives : [newCaptives];
                    const tempCarried = [...this.currentRaid.carriedCaptives, ...captivesToAdd];

                    if (tempCarried.length > this.carryCapacity) {
                        // 【修正】在呼叫時，將 this.carryCapacity 作為第三個參數傳遞進去
                        this.openCaptiveManagementModal('raid', tempCarried, this.carryCapacity);
                    } else {
                        this.currentRaid.carriedCaptives = tempCarried;
                        this.finishCombatCleanup();
                    }
                },
                
                openCaptiveManagementModal(type, list, limit, dungeonLimit = -1, context = null) {
                    const modal = this.modals.captiveManagement;
                    modal.type = type;
                    modal.list = list;
                    modal.limit = limit;
                    modal.dungeonLimit = dungeonLimit;
                    modal.context = context; // 儲存額外資訊 (母親和新生兒)

                    if (type === 'raid') {
                        modal.title = '攜帶量已滿';
                        modal.selectedIds = list.slice(0, limit).map(c => c.id);
                    } else if (type === 'partner') {
                        modal.title = '寢室空間不足';
                        // 預設選取所有舊的夥伴，不選新生兒
                        modal.selectedIds = list.filter(p => p.id !== context.newborn.id).map(p => p.id);
                    } else { // dungeon
                        modal.title = '地牢已滿';
                        modal.selectedIds = list.filter(c => this.captives.some(existing => existing.id === c.id)).map(c => c.id);
                    }
                    // 自動調整預選，確保不超過地牢上限 (這段邏輯對夥伴管理無影響，但保留是安全的)
                    if (dungeonLimit > -1) {
                        let selectedDungeonCaptives = modal.list.filter(c => modal.selectedIds.includes(c.id) && !c.isPregnant && !c.isMother);
                        while (selectedDungeonCaptives.length > dungeonLimit) {
                            const captiveToRemove = selectedDungeonCaptives.pop();
                            modal.selectedIds = modal.selectedIds.filter(id => id !== captiveToRemove.id);
                        }
                    }

                    modal.isOpen = true;
                },
                // 請用這個【新版本】完整替換舊的 confirmCaptiveSelection 函式
                confirmCaptiveSelection() {
                    const modal = this.modals.captiveManagement;
                    const selectedSet = new Set(modal.selectedIds);
                    
                    if (modal.type === 'raid') {
                        // 這是舊的邏輯：在掠奪地圖上，攜帶量滿了
                        this.currentRaid.carriedCaptives = modal.list.filter(c => selectedSet.has(c.id));
                        this.logMessage('raid', `你選擇保留 ${this.currentRaid.carriedCaptives.length} 名俘虜，拋棄了其餘的。`, 'info');
                        this.finishCombatCleanup();
                    } 
                    else if (modal.type === 'raid_return') {
                        // 【新增】這是新的邏輯：從掠奪返回部落，地牢滿了
                        const keptDungeonCaptives = modal.list.filter(c => selectedSet.has(c.id));
                        
                        // 將保留下來的俘虜與產房裡的孕母合併成最終名單
                        this.captives = [...this.mothers, ...keptDungeonCaptives];
                        
                        this.logMessage('tribe', `你整理了地牢，最終留下了 ${keptDungeonCaptives.length} 名俘虜。`, 'success');
                        this.finalizeRaidReturn(); // 執行返回部落的最終流程
                    }
                    else { 
                        // 這是舊的邏輯：從掠奪返回部落，總容量滿了 (現在較少觸發)
                        this.captives = modal.list.filter(c => selectedSet.has(c.id));
                        this.logMessage('tribe', `你帶回並整理了俘虜，最終部落擁有 ${this.captives.length} 名俘虜。`, 'player');
                        this.finalizeRaidReturn();
                    }
                    
                    this.modals.captiveManagement.isOpen = false;
                },
                openPartnerManagementModal(list, limit, context) {
                    const modal = this.modals.partnerManagement;
                    modal.list = list;
                    modal.limit = limit;
                    modal.context = context;
                    modal.newbornId = context.newborn.id;
                    // 預設選取所有舊的夥伴，不選新生兒
                    modal.selectedIds = list.filter(p => p.id !== context.newborn.id).map(p => p.id);
                    modal.isOpen = true;
                },

                confirmPartnerSelectionDecision() {
                    const modal = this.modals.partnerManagement;
                    const selectedSet = new Set(modal.selectedIds);
                    const { mother, newborn } = modal.context;

                    // 【第一步】找出被放棄的夥伴
                    const discardedPartners = modal.list.filter(p => !selectedSet.has(p.id));
                    
                    // 【第二步】收集所有被放棄夥伴身上的裝備
                    const itemsToReturn = discardedPartners.flatMap(p => Object.values(p.equipment).filter(item => item !== null));

                    // 【第三步】檢查空間並處理裝備 (與 releasePartner 函式邏輯相同)
                    if (itemsToReturn.length > 0) {
                        const availableSpace = (this.warehouseCapacity - this.warehouseInventory.length) + (this.backpackCapacity - this.player.inventory.length);
                        
                        if (itemsToReturn.length > availableSpace) {
                            // 空間不足，打開處理視窗
                            this.modals.itemManagement = {
                                isOpen: true,
                                title: `處理被放棄夥伴的裝備`,
                                message: `為新生兒騰出空間前，需先處理被放棄夥伴身上的裝備。請先處理以下物品，直到剩餘數量小於等於 ${availableSpace}。`,
                                items: [...itemsToReturn],
                                capacity: availableSpace,
                                onConfirm: () => {
                                    // 當玩家在物品管理視窗處理完畢後，再執行最終的夥伴確認
                                    this.finalizePartnerSelection();
                                }
                            };
                            // 暫時關閉夥伴選擇視窗，讓位給物品管理視窗
                            modal.isOpen = false;
                            return; // 中斷函式，等待玩家處理裝備
                        } else {
                            // 空間足夠，自動轉移
                            itemsToReturn.forEach(item => {
                                if (this.warehouseInventory.length < this.warehouseCapacity) {
                                    this.warehouseInventory.push(item);
                                } else {
                                    this.player.inventory.push(item);
                                }
                            });
                            this.logMessage('tribe', `已將被放棄夥伴的 ${itemsToReturn.length} 件裝備自動移至倉庫/背包。`, 'info');
                        }
                    }

                    // 如果不需要處理裝備或已處理完畢，直接執行最終確認
                    this.finalizePartnerSelection();
                },
                // 【新增】用於新生兒決策的最終執行函式
                finalizePartnerSelection() {
                    const modal = this.modals.partnerManagement;
                    const selectedSet = new Set(modal.selectedIds);
                    const { mother, newborn } = modal.context;

                    const keptPartners = modal.list.filter(p => selectedSet.has(p.id));
                    const wasNewbornKept = keptPartners.some(p => p.id === newborn.id);                  
                    
                    // 更新部落的夥伴總列表
                    this.partners = keptPartners;
                    
                    if (wasNewbornKept) {
                        this.player.skillPoints++;
                        this.logMessage('tribe', `你為 ${newborn.name} 在寢室中騰出了空間！你獲得了 1 點技能點。`, 'success');
                        if (this.tutorial.active && !this.tutorial.finishedPartyMgmt) {
                            this.triggerTutorial('firstBirth');
                        }
                    } else {
                        this.logMessage('tribe', `你決定放棄 ${mother.name} 的孩子，為更強的夥伴保留了位置。`, 'info');
                    }                    
                    
                    mother.isPregnant = false;
                    mother.pregnancyTimer = 0;
                    mother.isMother = true;
                    this.logMessage('tribe', `${mother.name} 現在開始在產房為部落貢獻奶水。`, 'info');

                    modal.isOpen = false;
                    
                    // 【核心修正】採用更簡潔、更穩定的方式來更新出擊隊伍
                    const keptPartnerIds = new Set(this.partners.map(p => p.id));
                    this.player.party = this.player.party.filter(p => keptPartnerIds.has(p.id));
                    this.player.updateHp(this.isStarving);
                },
                // 1. 在函式定義中，加入一個帶有「預設值」的參數
                finishCombatCleanup(returnToTribe = false) {
                    if (this.currentRaid) {
                        this.currentRaid.currentZone.buildings.forEach(b => {
                            b.occupants = b.occupants.filter(o => o.isAlive());
                            if (b.scouted && b.occupants.length === 0) {
                                b.postScoutText = b.looted ? ' (空)' : ' (可搜刮)';
                            }
                        });
                        
                        const newEnemiesList = [];
                        for (const group of this.currentRaid.currentZone.enemies) {
                            const livingMembers = group.filter(member => member.isAlive());
                            if (livingMembers.length > 0) {
                                newEnemiesList.push(livingMembers);
                            }
                        }
                        this.currentRaid.currentZone.enemies = newEnemiesList;
                    }
                    
                    this.combat.allies = [];
                    this.combat.enemies = [];
                    this.combat.turn = 0;
                    this.combat.log = [];
                    this.combat.isProcessing = false;
                    this.combat.currentEnemyGroup = [];
                    this.combat.playerActionTaken = false;
                    this.combat.isReinforcementBattle = false; // 統一在此處重置

                    this.screen = returnToTribe ? 'tribe' : 'raid';
                },
                showCustomAlert(message, onConfirmCallback = null) {
                    this.modals.customAlert.message = message;
                    this.modals.customAlert.onConfirm = onConfirmCallback;
                    this.modals.customAlert.isOpen = true;
                },
                confirmCustomAlert() {
                    this.modals.customAlert.isOpen = false;
                    if (typeof this.modals.customAlert.onConfirm === 'function') {
                        setTimeout(() => {
                            this.modals.customAlert.onConfirm();
                            this.modals.customAlert.onConfirm = null;
                        }, 100);
                    }
                },
                processNextDecision() {
                    if (this.pendingDecisions.length === 0) return;

                    const decision = this.pendingDecisions.shift();

                    if (decision.type === 'partner') {
                        // 如果是夥伴寢室已滿的決策，呼叫新的夥伴管理視窗
                        this.openPartnerManagementModal(decision.list, decision.limit, decision.context);
                    } else {
                        // 否則，維持舊的邏輯，呼叫統一俘虜管理視窗
                        this.openCaptiveManagementModal(
                            decision.type,
                            decision.list,
                            decision.limit,
                            decision.dungeonLimit,
                            decision.context
                        );
                    }
                },
                logMessage(panelKey, message, type = 'system') {
                    const logArray = this.logs[panelKey];
                    if (logArray) {
                        const logEntry = { id: crypto.randomUUID(), message, type };
                        
                        if (panelKey === 'combat') {
                            logEntry.turn = this.combat.turn;
                        }
                        
                        logArray.push(logEntry);
                        
                        if (logArray.length > 100) {
                            logArray.shift();
                        }
                    }
                },
                saveGame() {
                    const saveData = {
                        player: this.player,
                        warehouseInventory: this.warehouseInventory, // 儲存倉庫物品
                        partners: this.partners,
                        captives: this.captives,
                        resources: this.resources,
                        buildings: this.buildings,
                        day: this.day,
                        narrativeMemory: this.narrativeMemory,
                        tutorial: this.tutorial,
                        breedingChargesLeft: this.breedingChargesLeft,
                        merchant: this.merchant,// 儲存更完整的商人資訊
                        tempStatIncreases: this.tempStatIncreases,//能力點
                    };
                    localStorage.setItem('goblinKingSaveFile', JSON.stringify(saveData));
                    this.showCustomAlert('遊戲進度已儲存！');
                    this.hasSaveFile = true;
                },
                // 【新增】存檔拯救函式，用於修復汙染的舊存檔
                // 【最終修正】存檔拯救函式，增加強制ID清洗功能
                salvageSaveData() {
                    console.log("Running final save data salvage and ID sanitation...");
                    
                    const processedItems = new Set(); // 用於追蹤已處理過的物品，避免重複操作
                    let itemsSanitized = 0;

                    // 建立一個函式，遞迴地處理所有可能包含物品的地方
                    const sanitizeAndRegenerateIds = (data) => {
                        // 如果是物品物件 (有 id 和 baseName)
                        if (data && data.id && data.baseName) {
                            // 如果這個物品物件的參照我們已經處理過了，就跳過
                            if (processedItems.has(data)) {
                                return data;
                            }
                            // 為該物品生成一個全新的 ID
                            data.id = crypto.randomUUID();
                            processedItems.add(data); // 標記為已處理
                            itemsSanitized++;
                            return data;
                        }
                        // 如果是陣列，就遞迴處理陣列中的每個元素
                        if (Array.isArray(data)) {
                            return data.map(item => sanitizeAndRegenerateIds(item));
                        }
                        // 如果是物件，就遞迴處理物件的每個屬性值
                        if (typeof data === 'object' && data !== null) {
                            Object.keys(data).forEach(key => {
                                data[key] = sanitizeAndRegenerateIds(data[key]);
                            });
                            return data;
                        }
                        // 如果是基本類型，直接返回
                        return data;
                    };

                    // 從遊戲資料的根層級開始，對所有物品進行 ID 清洗
                    this.warehouseInventory = sanitizeAndRegenerateIds(this.warehouseInventory);
                    this.player = sanitizeAndRegenerateIds(this.player);
                    this.partners = sanitizeAndRegenerateIds(this.partners);

                    console.log(`ID Sanitation complete: Regenerated IDs for ${itemsSanitized} item instances.`);
                    if (itemsSanitized > 0) {
                        this.logMessage('tribe', `系統偵測到並修復了 ${itemsSanitized} 個存檔中的物品ID衝突。`, 'system');
                    }
                },

                migrateSaveData() {
                    // 【修正】使用 Map 來收集所有物品，以確保每個物品的唯一性
                    const allKnownItems = new Map();

                    // 1. 定義一個輔助函式來安全地添加物品到 Map 中
                    const addItem = (item) => {
                        // 確保 item 有效、有 id 且尚未被添加過
                        if (item && item.id && !allKnownItems.has(item.id)) {
                            allKnownItems.set(item.id, item);
                        }
                    };

                    // 2. 遍歷所有可能的物品來源，並使用輔助函式添加
                    this.player.inventory.forEach(addItem);
                    this.warehouseInventory.forEach(addItem);
                    Object.values(this.player.equipment).forEach(addItem);
                    
                    this.partners.forEach(p => {
                        Object.values(p.equipment).forEach(addItem);
                        // 確保 p.inventory 存在且為陣列
                        if (Array.isArray(p.inventory)) {
                            p.inventory.forEach(addItem);
                        }
                    });

                    // 3. 從 Map 中取得獨一無二的物品列表，這將是乾淨無重複的
                    const allItems = Array.from(allKnownItems.values());

                    const migrateItem = (item) => {
                        // (遷移邏輯維持不變)
                        if (item && item.baseName === '盾' && typeof item.stats.blockChance === 'undefined') {
                            const materialTier = item.material.tier;
                            const materialType = item.material.type;
                            
                            const correctBlockChance = BASE_EQUIPMENT_STATS[materialType]['盾'][materialTier]?.blockChance;

                            if (correctBlockChance) {
                                item.stats.blockChance = correctBlockChance;
                            }
                        }
                    };

                    allItems.forEach(migrateItem);
                    console.log("Save data migration check complete.");
                },

                loadGame() {
                    const savedData = localStorage.getItem('goblinKingSaveFile');
                    if (!savedData) {
                        this.showCustomAlert('找不到存檔文件！');
                        return;
                    }

                    try {
                        this.isNewGame = false;
                        const parsedData = JSON.parse(savedData);

                        if (!parsedData.player) {
                            throw new Error("存檔中缺少玩家資料！");
                        }

                        // 【核心修正】建立一個輔助函式，用於將純資料物件還原為 Equipment 類別實例
                        const rehydrateEquipment = (itemData) => {
                            if (!itemData) return null;
                            // 建立一個新的 Equipment 實例
                            const newItem = new Equipment(itemData.baseName, itemData.type, itemData.slot, itemData.material, itemData.quality, itemData.specialAffix);
                            // 將存檔中的所有屬性複製過去
                            Object.assign(newItem, itemData);
                            return newItem;
                        };

                        const safelyAssign = (target, source) => {
                            if (!source || typeof source !== 'object') return;
                            for (const key in source) {
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    if (typeof target[key] !== 'function') {
                                        // 對裝備相關的屬性進行特殊處理
                                        if (key === 'equipment') {
                                            target.equipment.mainHand = rehydrateEquipment(source.equipment.mainHand);
                                            target.equipment.offHand = rehydrateEquipment(source.equipment.offHand);
                                            target.equipment.chest = rehydrateEquipment(source.equipment.chest);
                                        } else if (key === 'inventory') {
                                            target.inventory = source.inventory.map(itemData => rehydrateEquipment(itemData));
                                        } else {
                                            target[key] = source[key];
                                        }
                                    }
                                }
                            }
                        };
                        
                        // 還原倉庫物品
                        this.warehouseInventory = (parsedData.warehouseInventory || []).map(itemData => rehydrateEquipment(itemData));

                        // 還原夥伴
                        this.partners = (parsedData.partners || []).map(pData => {
                            const partner = new Goblin(pData.name, pData.stats || {});
                            safelyAssign(partner, pData);
                            return partner;
                        });

                        // 還原俘虜
                        this.captives = (parsedData.captives || []).map(cData => {
                            const captive = new FemaleHuman(cData.name, cData.stats || {}, cData.profession, cData.visual);
                            safelyAssign(captive, cData);
                            return captive;
                        });

                        // 還原玩家
                        const loadedPlayerInstance = new Player(parsedData.player.name, parsedData.player.stats || {});
                        safelyAssign(loadedPlayerInstance, parsedData.player);
                        this.player = loadedPlayerInstance;

                        // 還原隊伍
                        const partnersMap = new Map(this.partners.map(p => [p.id, p]));
                        this.player.party = (parsedData.player.party || [])
                            .map(pData => partnersMap.get(pData.id))
                            .filter(Boolean);
                        
                        // --- 繼續載入其他遊戲數據 ---
                        this.resources = parsedData.resources;
                        
                        const defaultBuildings = {
                            dungeon: { level: 0, name: "地牢" }, warehouse: { level: 0, name: "倉庫" },
                            barracks: { level: 0, name: "寢室" }, armory: { level: 0, name: "兵工廠" },
                            maternity: { level: 0, name: "產房" }, trainingGround: { level: 0, name: "訓練場" }, 
                            merchantCamp: { level: 0, name: "商人營地" },
                        };
                        this.buildings = { ...defaultBuildings, ...parsedData.buildings };

                        this.day = parsedData.day;
                        this.narrativeMemory = parsedData.narrativeMemory;
                        this.tutorial = { ...{ active: false, step: 0, merchantMet: false }, ...parsedData.tutorial };
                        this.breedingChargesLeft = parsedData.breedingChargesLeft;
                        this.merchant = { ...this.merchant, ...parsedData.merchant };
                        
                        this.player.updateHp(this.isStarving);
                        this.partners.forEach(p => p.updateHp(this.isStarving));

                        if (parsedData.tempStatIncreases) {
                            this.tempStatIncreases = parsedData.tempStatIncreases;
                        } else {
                            this.cancelAttributePoints();
                        }
                        
                        this.salvageSaveData();
                        this.migrateSaveData();
                            
                        this.screen = 'tribe';
                        this.showCustomAlert('遊戲進度已讀取！');

                    } catch (e) {
                        console.error("讀取存檔失敗:", e);
                        this.showCustomAlert(`讀取存檔失敗！檔案可能已損毀。錯誤訊息: ${e.message}`);
                    }
                },

                checkForSaveFile() {
                    if (localStorage.getItem('goblinKingSaveFile')) {
                        this.hasSaveFile = true;
                    }
                },
                
                craftableTypes: [
                    { baseName: '劍', type: 'weapon', slot: 'mainHand' },
                    { baseName: '雙手劍', type: 'weapon', slot: 'mainHand' },
                    { baseName: '長槍', type: 'weapon', slot: 'mainHand' },
                    { baseName: '弓', type: 'weapon', slot: 'mainHand' },
                    { baseName: '法杖', type: 'weapon', slot: 'mainHand' },
                    { baseName: '盾', type: 'weapon', slot: 'offHand' },
                    { baseName: '鎧甲', type: 'armor', slot: 'chest' },
                ],
                get availableMaterials() {
                    if (this.buildings.armory.level === 0) return [];
                    const tierMap = [0, 1, 3, 5, 7];
                    const maxTier = tierMap[this.buildings.armory.level] || 0;
                    return Object.entries(EQUIPMENT_MATERIALS)
                        .filter(([key, mat]) => mat.tier <= maxTier)
                        .map(([key, mat]) => ({ key: key, name: mat.name }));
                },
                getCraftingCost() {
                    const materialKey = this.modals.armory.craftingMaterial;
                    if (!materialKey || !EQUIPMENT_MATERIALS[materialKey]) {
                        return { amount: 0, type: '' };
                    }
                    const material = EQUIPMENT_MATERIALS[materialKey];
                    return {
                        amount: material.cost,
                        type: material.type === 'metal' ? '礦石' : '木材'
                    };
                },
                get canAffordCraft() {
                    const cost = this.getCraftingCost();
                    if (cost.type === '礦石') {
                        return this.resources.stone >= cost.amount;
                    }
                    if (cost.type === '木材') {
                        return this.resources.wood >= cost.amount;
                    }
                    return false;
                },
                craftItem() {
                    if (!this.canAffordCraft) {
                        this.showCustomAlert('資源不足！');
                        return;
                    }
                    // 【修正】將 equipmentCapacity 改為正確的 backpackCapacity，以正確檢查背包容量
                    if (this.player.inventory.length >= this.backpackCapacity) {
                        this.showCustomAlert('你的背包已滿，無法製作新裝備！');
                        return;
                    }
                    const cost = this.getCraftingCost();
                    if (cost.type === '礦石') {
                        this.resources.stone -= cost.amount;
                    } else {
                        this.resources.wood -= cost.amount;
                    }

                    const roll = randomInt(1, 100);
                    let qualityKey = 'worn';
                    if (roll <= 5) qualityKey = 'legendary';      // GDD 13.5 機率為 5%
                    else if (roll <= 15) qualityKey = 'epic';     // GDD 13.5 機率為 10%
                    else if (roll <= 32) qualityKey = 'rare';     // GDD 13.5 機率為 17%
                    else if (roll <= 58) qualityKey = 'uncommon'; // GDD 13.5 機率為 26%
                    else if (roll <= 93) qualityKey = 'common';   // GDD 13.5 機率為 35%
                                                                // 剩下 7% 為 worn

                    const newItem = this.createEquipment(
                        this.modals.armory.craftingMaterial,
                        qualityKey,
                        this.modals.armory.craftingType
                    );

                    this.player.inventory.push(newItem);
                    this.logMessage('tribe', `你成功製作了 <span style="color:${newItem.quality.color};">[${newItem.name}]</span>！`, 'success');

                    // 【新增】顯示一個包含詳細結果的提示框，給予玩家即時回饋
                    this.showCustomAlert(`製作成功！\n你獲得了 [${newItem.name}]`);
                },
                decomposeItem(itemId) {
                    if (this.buildings.armory.level === 0) {
                        this.showCustomAlert('你需要先建造兵工廠才能分解裝備！');
                        return;
                    }
                    let itemIndex = this.player.inventory.findIndex(i => i.id === itemId);
                    let sourceArray = this.player.inventory;
                    if (itemIndex === -1) {
                        itemIndex = this.warehouseInventory.findIndex(i => i.id === itemId);
                        sourceArray = this.warehouseInventory;
                    }
                    if (itemIndex === -1) return;

                    const item = sourceArray[itemIndex];

                    const material = item.material;
                    const returnRate = [0.2, 0.3, 0.4, 0.5][this.buildings.armory.level - 1] || 0;
                    const resourcesBack = Math.floor(material.cost * returnRate);

                    if (material.type === 'metal') {
                        this.resources.stone += resourcesBack;
                        this.logMessage('tribe', `你分解了 [${item.name}]，回收了 ${resourcesBack} 礦石。`, 'info');
                    } else {
                        this.resources.wood += resourcesBack;
                        this.logMessage('tribe', `你分解了 [${item.name}]，回收了 ${resourcesBack} 木材。`, 'info');
                    }

                    sourceArray.splice(itemIndex, 1);
                },
                openDiscardConfirm(itemId) {
                    const item = this.player.inventory.find(i => i.id === itemId) || this.warehouseInventory.find(i => i.id === itemId);
                    if (item) {
                        this.modals.discardConfirm.itemId = itemId;
                        this.modals.discardConfirm.itemName = item.name;
                        this.modals.discardConfirm.isOpen = true;
                    }
                },
                executeDiscardItem() {
                    const itemId = this.modals.discardConfirm.itemId;
                    let itemIndex = this.player.inventory.findIndex(i => i.id === itemId);
                    if (itemIndex > -1) {
                        const itemName = this.player.inventory[itemIndex].name;
                        this.player.inventory.splice(itemIndex, 1);
                        this.logMessage('tribe', `你從背包丟棄了 [${itemName}]。`, 'info');
                    } else {
                        itemIndex = this.warehouseInventory.findIndex(i => i.id === itemId);
                        if (itemIndex > -1) {
                            const itemName = this.warehouseInventory[itemIndex].name;
                            this.warehouseInventory.splice(itemIndex, 1);
                            this.logMessage('tribe', `你從倉庫丟棄了 [${itemName}]。`, 'info');
                        }
                    }
                    this.modals.discardConfirm.isOpen = false;
                    this.modals.discardConfirm.itemId = null;
                    this.modals.discardConfirm.itemName = '';
                },

                equipItem(itemId, targetUnit) {
                    if (!targetUnit) return;
                    
                    let itemIndex = this.player.inventory.findIndex(i => i.id === itemId);
                    let sourceArray = this.player.inventory;
                    if (itemIndex === -1) {
                        itemIndex = this.warehouseInventory.findIndex(i => i.id === itemId);
                        sourceArray = this.warehouseInventory;
                    }
                    if (itemIndex === -1) return;

                    const itemToEquip = sourceArray[itemIndex];
                    let slot = itemToEquip.slot; 

                    const mainHandWeapon = targetUnit.equipment.mainHand;
                    if (itemToEquip.baseName === '劍' && mainHandWeapon?.baseName === '劍' && !targetUnit.equipment.offHand) {
                        slot = 'offHand';
                    }
                    
                    if (!slot || !targetUnit.equipment.hasOwnProperty(slot)) return;

                    if (slot === 'offHand') {
                        if (mainHandWeapon && TWO_HANDED_WEAPONS.includes(mainHandWeapon.baseName)) {
                            this.showCustomAlert(`裝備 ${mainHandWeapon.baseName} 時無法使用副手裝備！`);
                            return;
                        }
                        if (itemToEquip.baseName === '劍' && mainHandWeapon?.baseName !== '劍') {
                            this.showCustomAlert('只有在主手裝備單手劍時，才能在副手裝備另一把劍！');
                            return;
                        }
                    }

                    if (slot === 'mainHand' && TWO_HANDED_WEAPONS.includes(itemToEquip.baseName)) {
                        if (targetUnit.equipment.offHand) {
                            this.logMessage('tribe', `裝備雙手武器時自動卸下了 ${targetUnit.equipment.offHand.name}。`, 'info');
                            this.unequipItem('offHand', targetUnit, true);
                        }
                    }

                    if (targetUnit.equipment[slot]) {
                        this.unequipItem(slot, targetUnit, true);
                    }

                    targetUnit.equipment[slot] = itemToEquip;
                    sourceArray.splice(itemIndex, 1);
                    
                    if (targetUnit.updateHp) targetUnit.updateHp(this.isStarving);
                    this.logMessage('tribe', `${targetUnit.name} 裝備了 <span style="color:${itemToEquip.quality.color};">[${itemToEquip.name}]</span>。`, 'success');
                    
                },

                unequipItem(slot, targetUnit, silent = false) {
                    if (!targetUnit || !targetUnit.equipment[slot]) return;
                    
                    const itemToUnequip = targetUnit.equipment[slot];

                    if (this.screen === 'raid') {
                        // 在掠奪中 -> 卸到背包
                        if (this.player.inventory.length >= this.backpackCapacity) {
                            this.showCustomAlert('你的背包已滿，無法卸下裝備！');
                            return;
                        }
                        this.player.inventory.push(itemToUnequip);
                        if (!silent) {
                             this.logMessage('raid', `${targetUnit.name} 卸下了 <span style="color:${itemToUnequip.quality.color};">[${itemToUnequip.name}]</span>，物品已放入背包。`, 'info');
                        }
                    } else {
                        if (this.warehouseInventory.length >= this.warehouseCapacity) {
                            this.showCustomAlert('倉庫已滿，無法卸下裝備！');
                            return;
                        }
                        this.warehouseInventory.push(itemToUnequip);
                        if (!silent) {
                            this.logMessage('tribe', `${targetUnit.name} 卸下了 <span style="color:${itemToUnequip.quality.color};">[${itemToUnequip.name}]</span>，物品已存入倉庫。`, 'info');
                        }
                    }
                    
                    targetUnit.equipment[slot] = null;

                    if (targetUnit.updateHp) {
                        targetUnit.updateHp(this.isStarving);
                    } else if (targetUnit.id === this.player.id) { 
                        this.player.updateHp(this.isStarving);
                    }
                },

                moveToBackpack(itemId) {
                    const itemIndex = this.warehouseInventory.findIndex(i => i.id === itemId);
                    if (itemIndex > -1) {
                        if (this.player.inventory.length >= this.backpackCapacity) {
                            this.showCustomAlert('你的背包已滿！');
                            return;
                        }
                        const [item] = this.warehouseInventory.splice(itemIndex, 1);
                        this.player.inventory.push(item);
                    }
                },

                moveToWarehouse(itemId) {
                    const itemIndex = this.player.inventory.findIndex(i => i.id === itemId);
                    if (itemIndex > -1) {
                        if (this.warehouseInventory.length >= this.warehouseCapacity) {
                            this.showCustomAlert('倉庫已滿！');
                            return;
                        }
                        const [item] = this.player.inventory.splice(itemIndex, 1);
                        this.warehouseInventory.push(item);
                    }
                },
               getItemStatsString(item) {
                    if (!item) return '';
                    let parts = [];
                    // 顯示基礎屬性
                    if (item.stats && Object.keys(item.stats).length > 0) {
                        const statsString = Object.entries(item.stats).map(([key, value]) => {
                            if (key === 'blockChance') {
                                return `${STAT_NAMES[key] || key} +${value}%`;
                            }
                            return `${STAT_NAMES[key] || key} +${value}`;
                        }).join(', ');
                        parts.push(statsString);
                    }
                    // 顯示詞綴效果
                    item.affixes.forEach(affix => {
                        if (affix.type === 'stat') {
                            const effectString = affix.effects.map(e => {
                                const statName = e.stat === 'all' ? '全能力' : (STAT_NAMES[e.stat] || e.stat);
                                return e.type === 'multiplier' ? `${statName} x${e.value}` : `${statName} +${e.value}`;
                            }).join('/');
                            parts.push(`<span class="text-green-400">${affix.name}: ${effectString}</span>`);
                        } else if (affix.type === 'proc') {
                            parts.push(`<span class="text-blue-400">${affix.name} (機率性效果)</span>`);
                        }
                    });
                    // 顯示特殊詛咒詞綴效果
                    if (item.specialAffix) {
                        const affixDesc = {
                            'strength_curse': '脫力(基礎力=0時+10力, 否則全能力-10)',
                            'agility_curse': '遲鈍(基礎敏=0時+10敏, 否則全能力-10)',
                            'intelligence_curse': '愚鈍(基礎智=0時+10智, 否則全能力-10)',
                            'luck_curse': '不幸(基礎運=0時+10運, 否則全能力-10)',
                            'gundam_curse': '肛蛋(基礎2項=0時, 該2項+8, 否則全能力-8)',
                            'henshin_curse': '變身(基礎3項=0時, 該3項+5, 否則全能力-5)',
                        }[item.specialAffix] || '';
                        if (affixDesc) {
                            parts.push(`<span class="text-red-400">${affixDesc}</span>`);
                        }
                    }

                    return parts.join('<br>');
                }
            }
        }
    </script>
</div></body>
</html>
